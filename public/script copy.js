document.addEventListener("DOMContentLoaded", (() => { const e = document.getElementById("carousel-style-1"); if (e) { new Glide(e, { direction: (() => "rtl" == document.dir ? "rtl" : "ltr")(), type: "carousel", perView: 4, gap: 20, breakpoints: { 640: { perView: 1 }, 768: { perView: 2 } } }).mount() } const t = document.getElementById("ckeditor"); t && ClassicEditor.create(t); let n = null; if (n = document.getElementById("sortable-style-1"), n) { Sortable.create(n, { animation: 150 }) } if (n = document.getElementById("sortable-style-2"), n) { Sortable.create(n, { handle: ".handle", animation: 150 }) } if (n = document.getElementById("sortable-style-3"), n) { Sortable.create(n, { animation: 150 }) } const r = document.getElementById("calendar"); if (r) { new FullCalendar.Calendar(r, { headerToolbar: { left: "prev,next today", center: "title", right: "dayGridMonth,timeGridWeek,timeGridDay" }, initialDate: "2023-01-12", navLinks: !0, editable: !0, dayMaxEvents: !0, events: [{ title: "All Day Event", start: "2023-01-01" }, { title: "Long Event", start: "2023-01-07", end: "2023-01-10" }, { groupId: 999, title: "Repeating Event", start: "2023-01-09T16:00:00" }, { groupId: 999, title: "Repeating Event", start: "2023-01-16T16:00:00" }, { title: "Conference", start: "2023-01-11", end: "2023-01-13" }, { title: "Meeting", start: "2023-01-12T10:30:00", end: "2023-01-12T12:30:00" }, { title: "Lunch", start: "2023-01-12T12:00:00" }, { title: "Meeting", start: "2023-01-12T14:30:00" }, { title: "Happy Hour", start: "2023-01-12T17:30:00" }, { title: "Dinner", start: "2023-01-12T20:00:00" }, { title: "Birthday Party", start: "2023-01-13T07:00:00" }, { title: "Click for Google", url: "http://google.com/", start: "2023-01-28" }] }).render() } }));
/*!
FullCalendar Standard Bundle v6.1.8
Docs & License: https://fullcalendar.io/docs/initialize-globals
(c) 2023 Adam Shaw
*/
var FullCalendar = function (e) { "use strict"; var t, n, r, i, o, s, a, l, d, c = {}, u = [], h = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i; function f(e, t) { for (var n in t) e[n] = t[n]; return e } function g(e) { var t = e.parentNode; t && t.removeChild(e) } function p(e, n, r) { var i, o, s, a = {}; for (s in n) "key" == s ? i = n[s] : "ref" == s ? o = n[s] : a[s] = n[s]; if (arguments.length > 2 && (a.children = arguments.length > 3 ? t.call(arguments, 2) : r), "function" == typeof e && null != e.defaultProps) for (s in e.defaultProps) void 0 === a[s] && (a[s] = e.defaultProps[s]); return m(e, a, i, o, null) } function m(e, t, i, o, s) { var a = { type: e, props: t, key: i, ref: o, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == s ? ++r : s }; return null == s && null != n.vnode && n.vnode(a), a } function v(e) { return e.children } function y(e, t, n) { "-" === t[0] ? e.setProperty(t, null == n ? "" : n) : e[t] = null == n ? "" : "number" != typeof n || h.test(t) ? n : n + "px" } function b(e, t, n, r, i) { var o; e: if ("style" === t) if ("string" == typeof n) e.style.cssText = n; else { if ("string" == typeof r && (e.style.cssText = r = ""), r) for (t in r) n && t in n || y(e.style, t, ""); if (n) for (t in n) r && n[t] === r[t] || y(e.style, t, n[t]) } else if ("o" === t[0] && "n" === t[1]) o = t !== (t = t.replace(/Capture$/, "")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + o] = n, n ? r || e.addEventListener(t, o ? S : E, o) : e.removeEventListener(t, o ? S : E, o); else if ("dangerouslySetInnerHTML" !== t) { if (i) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if ("width" !== t && "height" !== t && "href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && t in e) try { e[t] = null == n ? "" : n; break e } catch (e) { } "function" == typeof n || (null == n || !1 === n && -1 == t.indexOf("-") ? e.removeAttribute(t) : e.setAttribute(t, n)) } } function E(e) { o = !0; try { return this.l[e.type + !1](n.event ? n.event(e) : e) } finally { o = !1 } } function S(e) { o = !0; try { return this.l[e.type + !0](n.event ? n.event(e) : e) } finally { o = !1 } } function C(e, t) { this.props = e, this.context = t } function w(e, t) { if (null == t) return e.__ ? w(e.__, e.__.__k.indexOf(e) + 1) : null; for (var n; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) return n.__e; return "function" == typeof e.type ? w(e) : null } function A(e) { var t, n; if (null != (e = e.__) && null != e.__c) { for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) { e.__e = e.__c.base = n.__e; break } return A(e) } } function D(e) { o ? setTimeout(e) : l(e) } function R(e) { (!e.__d && (e.__d = !0) && s.push(e) && !x.__r++ || a !== n.debounceRendering) && ((a = n.debounceRendering) || D)(x) } function x() { var e, t, n, r, i, o, a, l; for (s.sort((function (e, t) { return e.__v.__b - t.__v.__b })); e = s.shift();)e.__d && (t = s.length, r = void 0, i = void 0, a = (o = (n = e).__v).__e, (l = n.__P) && (r = [], (i = f({}, o)).__v = o.__v + 1, O(l, o, i, n.__n, void 0 !== l.ownerSVGElement, null != o.__h ? [a] : null, r, null == a ? w(o) : a, o.__h), N(r, o), o.__e != a && A(o)), s.length > t && s.sort((function (e, t) { return e.__v.__b - t.__v.__b }))); x.__r = 0 } function T(e, t, n, r, i, o, s, a, l, d) { var h, f, g, p, y, b, E, S = r && r.__k || u, C = S.length; for (n.__k = [], h = 0; h < t.length; h++)if (null != (p = n.__k[h] = null == (p = t[h]) || "boolean" == typeof p ? null : "string" == typeof p || "number" == typeof p || "bigint" == typeof p ? m(null, p, null, null, p) : Array.isArray(p) ? m(v, { children: p }, null, null, null) : p.__b > 0 ? m(p.type, p.props, p.key, p.ref ? p.ref : null, p.__v) : p)) { if (p.__ = n, p.__b = n.__b + 1, null === (g = S[h]) || g && p.key == g.key && p.type === g.type) S[h] = void 0; else for (f = 0; f < C; f++) { if ((g = S[f]) && p.key == g.key && p.type === g.type) { S[f] = void 0; break } g = null } O(e, p, g = g || c, i, o, s, a, l, d), y = p.__e, (f = p.ref) && g.ref != f && (E || (E = []), g.ref && E.push(g.ref, null, p), E.push(f, p.__c || y, p)), null != y ? (null == b && (b = y), "function" == typeof p.type && p.__k === g.__k ? p.__d = l = k(p, l, e) : l = M(e, p, g, S, y, l), "function" == typeof n.type && (n.__d = l)) : l && g.__e == l && l.parentNode != e && (l = w(g)) } for (n.__e = b, h = C; h--;)null != S[h] && ("function" == typeof n.type && null != S[h].__e && S[h].__e == n.__d && (n.__d = I(r).nextSibling), B(S[h], S[h])); if (E) for (h = 0; h < E.length; h++)P(E[h], E[++h], E[++h]) } function k(e, t, n) { for (var r, i = e.__k, o = 0; i && o < i.length; o++)(r = i[o]) && (r.__ = e, t = "function" == typeof r.type ? k(r, t, n) : M(n, r, r, i, r.__e, t)); return t } function _(e, t) { return t = t || [], null == e || "boolean" == typeof e || (Array.isArray(e) ? e.some((function (e) { _(e, t) })) : t.push(e)), t } function M(e, t, n, r, i, o) { var s, a, l; if (void 0 !== t.__d) s = t.__d, t.__d = void 0; else if (null == n || i != o || null == i.parentNode) e: if (null == o || o.parentNode !== e) e.appendChild(i), s = null; else { for (a = o, l = 0; (a = a.nextSibling) && l < r.length; l += 1)if (a == i) break e; e.insertBefore(i, o), s = o } return void 0 !== s ? s : i.nextSibling } function I(e) { var t, n, r; if (null == e.type || "string" == typeof e.type) return e.__e; if (e.__k) for (t = e.__k.length - 1; t >= 0; t--)if ((n = e.__k[t]) && (r = I(n))) return r; return null } function O(e, t, r, i, o, s, a, l, d) { var c, u, h, g, p, m, y, b, E, S, w, A, D, R, x, k = t.type; if (void 0 !== t.constructor) return null; null != r.__h && (d = r.__h, l = t.__e = r.__e, t.__h = null, s = [l]), (c = n.__b) && c(t); try { e: if ("function" == typeof k) { if (b = t.props, E = (c = k.contextType) && i[c.__c], S = c ? E ? E.props.value : c.__ : i, r.__c ? y = (u = t.__c = r.__c).__ = u.__E : ("prototype" in k && k.prototype.render ? t.__c = u = new k(b, S) : (t.__c = u = new C(b, S), u.constructor = k, u.render = L), E && E.sub(u), u.props = b, u.state || (u.state = {}), u.context = S, u.__n = i, h = u.__d = !0, u.__h = [], u._sb = []), null == u.__s && (u.__s = u.state), null != k.getDerivedStateFromProps && (u.__s == u.state && (u.__s = f({}, u.__s)), f(u.__s, k.getDerivedStateFromProps(b, u.__s))), g = u.props, p = u.state, u.__v = t, h) null == k.getDerivedStateFromProps && null != u.componentWillMount && u.componentWillMount(), null != u.componentDidMount && u.__h.push(u.componentDidMount); else { if (null == k.getDerivedStateFromProps && b !== g && null != u.componentWillReceiveProps && u.componentWillReceiveProps(b, S), !u.__e && null != u.shouldComponentUpdate && !1 === u.shouldComponentUpdate(b, u.__s, S) || t.__v === r.__v) { for (t.__v !== r.__v && (u.props = b, u.state = u.__s, u.__d = !1), t.__e = r.__e, t.__k = r.__k, t.__k.forEach((function (e) { e && (e.__ = t) })), w = 0; w < u._sb.length; w++)u.__h.push(u._sb[w]); u._sb = [], u.__h.length && a.push(u); break e } null != u.componentWillUpdate && u.componentWillUpdate(b, u.__s, S), null != u.componentDidUpdate && u.__h.push((function () { u.componentDidUpdate(g, p, m) })) } if (u.context = S, u.props = b, u.__P = e, A = n.__r, D = 0, "prototype" in k && k.prototype.render) { for (u.state = u.__s, u.__d = !1, A && A(t), c = u.render(u.props, u.state, u.context), R = 0; R < u._sb.length; R++)u.__h.push(u._sb[R]); u._sb = [] } else do { u.__d = !1, A && A(t), c = u.render(u.props, u.state, u.context), u.state = u.__s } while (u.__d && ++D < 25); u.state = u.__s, null != u.getChildContext && (i = f(f({}, i), u.getChildContext())), h || null == u.getSnapshotBeforeUpdate || (m = u.getSnapshotBeforeUpdate(g, p)), x = null != c && c.type === v && null == c.key ? c.props.children : c, T(e, Array.isArray(x) ? x : [x], t, r, i, o, s, a, l, d), u.base = t.__e, t.__h = null, u.__h.length && a.push(u), y && (u.__E = u.__ = null), u.__e = !1 } else null == s && t.__v === r.__v ? (t.__k = r.__k, t.__e = r.__e) : t.__e = H(r.__e, t, r, i, o, s, a, d); (c = n.diffed) && c(t) } catch (e) { t.__v = null, (d || null != s) && (t.__e = l, t.__h = !!d, s[s.indexOf(l)] = null), n.__e(e, t, r) } } function N(e, t) { n.__c && n.__c(t, e), e.some((function (t) { try { e = t.__h, t.__h = [], e.some((function (e) { e.call(t) })) } catch (e) { n.__e(e, t.__v) } })) } function H(e, n, r, i, o, s, a, l) { var d, u, h, f = r.props, p = n.props, m = n.type, v = 0; if ("svg" === m && (o = !0), null != s) for (; v < s.length; v++)if ((d = s[v]) && "setAttribute" in d == !!m && (m ? d.localName === m : 3 === d.nodeType)) { e = d, s[v] = null; break } if (null == e) { if (null === m) return document.createTextNode(p); e = o ? document.createElementNS("http://www.w3.org/2000/svg", m) : document.createElement(m, p.is && p), s = null, l = !1 } if (null === m) f === p || l && e.data === p || (e.data = p); else { if (s = s && t.call(e.childNodes), u = (f = r.props || c).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !l) { if (null != s) for (f = {}, v = 0; v < e.attributes.length; v++)f[e.attributes[v].name] = e.attributes[v].value; (h || u) && (h && (u && h.__html == u.__html || h.__html === e.innerHTML) || (e.innerHTML = h && h.__html || "")) } if (function (e, t, n, r, i) { var o; for (o in n) "children" === o || "key" === o || o in t || b(e, o, null, n[o], r); for (o in t) i && "function" != typeof t[o] || "children" === o || "key" === o || "value" === o || "checked" === o || n[o] === t[o] || b(e, o, t[o], n[o], r) }(e, p, f, o, l), h) n.__k = []; else if (v = n.props.children, T(e, Array.isArray(v) ? v : [v], n, r, i, o && "foreignObject" !== m, s, a, s ? s[0] : r.__k && w(r, 0), l), null != s) for (v = s.length; v--;)null != s[v] && g(s[v]); l || ("value" in p && void 0 !== (v = p.value) && (v !== e.value || "progress" === m && !v || "option" === m && v !== f.value) && b(e, "value", v, f.value, !1), "checked" in p && void 0 !== (v = p.checked) && v !== e.checked && b(e, "checked", v, f.checked, !1)) } return e } function P(e, t, r) { try { "function" == typeof e ? e(t) : e.current = t } catch (e) { n.__e(e, r) } } function B(e, t, r) { var i, o; if (n.unmount && n.unmount(e), (i = e.ref) && (i.current && i.current !== e.__e || P(i, null, t)), null != (i = e.__c)) { if (i.componentWillUnmount) try { i.componentWillUnmount() } catch (e) { n.__e(e, t) } i.base = i.__P = null, e.__c = void 0 } if (i = e.__k) for (o = 0; o < i.length; o++)i[o] && B(i[o], t, r || "function" != typeof e.type); r || null == e.__e || g(e.__e), e.__ = e.__e = e.__d = void 0 } function L(e, t, n) { return this.constructor(e, n) } function W(e, r, i) { var o, s, a; n.__ && n.__(e, r), s = (o = "function" == typeof i) ? null : i && i.__k || r.__k, a = [], O(r, e = (!o && i || r).__k = p(v, null, [e]), s || c, c, void 0 !== r.ownerSVGElement, !o && i ? [i] : s ? null : r.firstChild ? t.call(r.childNodes) : null, a, !o && i ? i : s ? s.__e : r.firstChild, o), N(a, e) } t = u.slice, n = { __e: function (e, t, n, r) { for (var i, o, s; t = t.__;)if ((i = t.__c) && !i.__) try { if ((o = i.constructor) && null != o.getDerivedStateFromError && (i.setState(o.getDerivedStateFromError(e)), s = i.__d), null != i.componentDidCatch && (i.componentDidCatch(e, r || {}), s = i.__d), s) return i.__E = i } catch (t) { e = t } throw e } }, r = 0, i = function (e) { return null != e && void 0 === e.constructor }, o = !1, C.prototype.setState = function (e, t) { var n; n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = f({}, this.state), "function" == typeof e && (e = e(f({}, n), this.props)), e && f(n, e), null != e && this.__v && (t && this._sb.push(t), R(this)) }, C.prototype.forceUpdate = function (e) { this.__v && (this.__e = !0, e && this.__h.push(e), R(this)) }, C.prototype.render = v, s = [], l = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, x.__r = 0, d = 0; var z, j, U, F = [], V = [], G = n.__b, q = n.__r, Y = n.diffed, Q = n.__c, Z = n.unmount; function X() { for (var e; e = F.shift();)if (e.__P && e.__H) try { e.__H.__h.forEach(K), e.__H.__h.forEach(ee), e.__H.__h = [] } catch (t) { e.__H.__h = [], n.__e(t, e.__v) } } n.__b = function (e) { z = null, G && G(e) }, n.__r = function (e) { q && q(e); var t = (z = e.__c).__H; t && (j === z ? (t.__h = [], z.__h = [], t.__.forEach((function (e) { e.__N && (e.__ = e.__N), e.__V = V, e.__N = e.i = void 0 }))) : (t.__h.forEach(K), t.__h.forEach(ee), t.__h = [])), j = z }, n.diffed = function (e) { Y && Y(e); var t = e.__c; t && t.__H && (t.__H.__h.length && (1 !== F.push(t) && U === n.requestAnimationFrame || ((U = n.requestAnimationFrame) || J)(X)), t.__H.__.forEach((function (e) { e.i && (e.__H = e.i), e.__V !== V && (e.__ = e.__V), e.i = void 0, e.__V = V }))), j = z = null }, n.__c = function (e, t) { t.some((function (e) { try { e.__h.forEach(K), e.__h = e.__h.filter((function (e) { return !e.__ || ee(e) })) } catch (r) { t.some((function (e) { e.__h && (e.__h = []) })), t = [], n.__e(r, e.__v) } })), Q && Q(e, t) }, n.unmount = function (e) { Z && Z(e); var t, r = e.__c; r && r.__H && (r.__H.__.forEach((function (e) { try { K(e) } catch (e) { t = e } })), r.__H = void 0, t && n.__e(t, r.__v)) }; var $ = "function" == typeof requestAnimationFrame; function J(e) { var t, n = function () { clearTimeout(r), $ && cancelAnimationFrame(t), setTimeout(e) }, r = setTimeout(n, 100); $ && (t = requestAnimationFrame(n)) } function K(e) { var t = z, n = e.__c; "function" == typeof n && (e.__c = void 0, n()), z = t } function ee(e) { var t = z; e.__c = e.__(), z = t } function te(e, t) { for (var n in e) if ("__source" !== n && !(n in t)) return !0; for (var r in t) if ("__source" !== r && e[r] !== t[r]) return !0; return !1 } function ne(e) { this.props = e } (ne.prototype = new C).isPureReactComponent = !0, ne.prototype.shouldComponentUpdate = function (e, t) { return te(this.props, e) || te(this.state, t) }; var re = n.__b; n.__b = function (e) { e.type && e.type.__f && e.ref && (e.props.ref = e.ref, e.ref = null), re && re(e) }; var ie = n.__e; n.__e = function (e, t, n, r) { if (e.then) for (var i, o = t; o = o.__;)if ((i = o.__c) && i.__c) return null == t.__e && (t.__e = n.__e, t.__k = n.__k), i.__c(e, t); ie(e, t, n, r) }; var oe = n.unmount; function se() { this.__u = 0, this.t = null, this.__b = null } function ae(e) { var t = e.__.__c; return t && t.__a && t.__a(e) } function le() { this.u = null, this.o = null } n.unmount = function (e) { var t = e.__c; t && t.__R && t.__R(), t && !0 === e.__h && (e.type = null), oe && oe(e) }, (se.prototype = new C).__c = function (e, t) { var n = t.__c, r = this; null == r.t && (r.t = []), r.t.push(n); var i = ae(r.__v), o = !1, s = function () { o || (o = !0, n.__R = null, i ? i(a) : a()) }; n.__R = s; var a = function () { if (!--r.__u) { if (r.state.__a) { var e = r.state.__a; r.__v.__k[0] = function e(t, n, r) { return t && (t.__v = null, t.__k = t.__k && t.__k.map((function (t) { return e(t, n, r) })), t.__c && t.__c.__P === n && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t }(e, e.__c.__P, e.__c.__O) } var t; for (r.setState({ __a: r.__b = null }); t = r.t.pop();)t.forceUpdate() } }, l = !0 === t.__h; r.__u++ || l || r.setState({ __a: r.__b = r.__v.__k[0] }), e.then(s, s) }, se.prototype.componentWillUnmount = function () { this.t = [] }, se.prototype.render = function (e, t) { if (this.__b) { if (this.__v.__k) { var n = document.createElement("div"), r = this.__v.__k[0].__c; this.__v.__k[0] = function e(t, n, r) { return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach((function (e) { "function" == typeof e.__c && e.__c() })), t.__c.__H = null), null != (t = function (e, t) { for (var n in t) e[n] = t[n]; return e }({}, t)).__c && (t.__c.__P === r && (t.__c.__P = n), t.__c = null), t.__k = t.__k && t.__k.map((function (t) { return e(t, n, r) }))), t }(this.__b, n, r.__O = r.__P) } this.__b = null } var i = t.__a && p(v, null, e.fallback); return i && (i.__h = null), [p(v, null, t.__a ? null : e.children), i] }; var de = function (e, t, n) { if (++n[1] === n[0] && e.o.delete(t), e.props.revealOrder && ("t" !== e.props.revealOrder[0] || !e.o.size)) for (n = e.u; n;) { for (; n.length > 3;)n.pop()(); if (n[1] < n[0]) break; e.u = n = n[2] } }; function ce(e) { return this.getChildContext = function () { return e.context }, e.children } function ue(e) { var t = this, n = e.i; t.componentWillUnmount = function () { W(null, t.l), t.l = null, t.i = null }, t.i && t.i !== n && t.componentWillUnmount(), e.__v ? (t.l || (t.i = n, t.l = { nodeType: 1, parentNode: n, childNodes: [], appendChild: function (e) { this.childNodes.push(e), t.i.appendChild(e) }, insertBefore: function (e, n) { this.childNodes.push(e), t.i.appendChild(e) }, removeChild: function (e) { this.childNodes.splice(this.childNodes.indexOf(e) >>> 1, 1), t.i.removeChild(e) } }), W(p(ce, { context: t.context }, e.__v), t.l)) : t.l && t.componentWillUnmount() } function he(e, t) { var n = p(ue, { __v: e, i: t }); return n.containerInfo = t, n } (le.prototype = new C).__a = function (e) { var t = this, n = ae(t.__v), r = t.o.get(e); return r[0]++, function (i) { var o = function () { t.props.revealOrder ? (r.push(i), de(t, e, r)) : i() }; n ? n(o) : o() } }, le.prototype.render = function (e) { this.u = null, this.o = new Map; var t = _(e.children); e.revealOrder && "b" === e.revealOrder[0] && t.reverse(); for (var n = t.length; n--;)this.o.set(t[n], this.u = [1, 0, this.u]); return e.children }, le.prototype.componentDidUpdate = le.prototype.componentDidMount = function () { var e = this; this.o.forEach((function (t, n) { de(e, n, t) })) }; var fe = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, ge = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, pe = "undefined" != typeof document, me = function (e) { return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(e) }; C.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach((function (e) { Object.defineProperty(C.prototype, e, { configurable: !0, get: function () { return this["UNSAFE_" + e] }, set: function (t) { Object.defineProperty(this, e, { configurable: !0, writable: !0, value: t }) } }) })); var ve = n.event; function ye() { } function be() { return this.cancelBubble } function Ee() { return this.defaultPrevented } n.event = function (e) { return ve && (e = ve(e)), e.persist = ye, e.isPropagationStopped = be, e.isDefaultPrevented = Ee, e.nativeEvent = e }; var Se = { configurable: !0, get: function () { return this.class } }, Ce = n.vnode; n.vnode = function (e) { var t = e.type, n = e.props, r = n; if ("string" == typeof t) { var i = -1 === t.indexOf("-"); for (var o in r = {}, n) { var s = n[o]; pe && "children" === o && "noscript" === t || "value" === o && "defaultValue" in n && null == s || ("defaultValue" === o && "value" in n && null == n.value ? o = "value" : "download" === o && !0 === s ? s = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !me(n.type) ? o = "oninput" : /^onfocus$/i.test(o) ? o = "onfocusin" : /^onblur$/i.test(o) ? o = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o) ? o = o.toLowerCase() : i && ge.test(o) ? o = o.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === s && (s = void 0), /^oninput$/i.test(o) && (o = o.toLowerCase(), r[o] && (o = "oninputCapture")), r[o] = s) } "select" == t && r.multiple && Array.isArray(r.value) && (r.value = _(n.children).forEach((function (e) { e.props.selected = -1 != r.value.indexOf(e.props.value) }))), "select" == t && null != r.defaultValue && (r.value = _(n.children).forEach((function (e) { e.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(e.props.value) : r.defaultValue == e.props.value }))), e.props = r, n.class != n.className && (Se.enumerable = "className" in n, null != n.className && (r.class = n.className), Object.defineProperty(r, "className", Se)) } e.$$typeof = fe, Ce && Ce(e) }; var we = n.__r; n.__r = function (e) { we && we(e), e.__c }; const Ae = [], De = new Map; function Re(e) { Ae.push(e), De.forEach((t => { Te(t, e) })) } function xe(e) { let t = De.get(e); if (!t || !t.isConnected) { if (t = e.querySelector("style[data-fullcalendar]"), !t) { t = document.createElement("style"), t.setAttribute("data-fullcalendar", ""); const n = (void 0 === ke && (ke = function () { const e = document.querySelector('meta[name="csp-nonce"]'); if (e && e.hasAttribute("content")) return e.getAttribute("content"); const t = document.querySelector("script[nonce]"); return t && t.nonce || "" }()), ke); n && (t.nonce = n); const r = e === document ? document.head : e, i = e === document ? r.querySelector("script,link[rel=stylesheet],link[as=style],style") : r.firstChild; r.insertBefore(t, i) } De.set(e, t), function (e) { for (const t of Ae) Te(e, t) }(t) } } function Te(e, t) { const { sheet: n } = e, r = n.cssRules.length; t.split("}").forEach(((e, t) => { (e = e.trim()) && n.insertRule(e + "}", r + t) })) } let ke; function _e(e) { e.parentNode && e.parentNode.removeChild(e) } function Me(e, t) { if (e.closest) return e.closest(t); if (!document.documentElement.contains(e)) return null; do { if (Ie(e, t)) return e; e = e.parentElement || e.parentNode } while (null !== e && 1 === e.nodeType); return null } function Ie(e, t) { return (e.matches || e.matchesSelector || e.msMatchesSelector).call(e, t) } function Oe(e, t) { let n = e instanceof HTMLElement ? [e] : e, r = []; for (let e = 0; e < n.length; e += 1) { let i = n[e].querySelectorAll(t); for (let e = 0; e < i.length; e += 1)r.push(i[e]) } return r } "undefined" != typeof document && xe(document), Re(':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}'); const Ne = /(top|left|right|bottom|width|height)$/i; function He(e, t) { for (let n in t) Pe(e, n, t[n]) } function Pe(e, t, n) { null == n ? e.style[t] = "" : "number" == typeof n && Ne.test(t) ? e.style[t] = n + "px" : e.style[t] = n } function Be(e) { var t, n; return null !== (n = null === (t = e.composedPath) || void 0 === t ? void 0 : t.call(e)[0]) && void 0 !== n ? n : e.target } let Le = 0; function We() { return Le += 1, "fc-dom-" + Le } function ze(e) { e.preventDefault() } function je(e, t, n, r) { let i = function (e, t) { return n => { let r = Me(n.target, e); r && t.call(r, n, r) } }(n, r); return e.addEventListener(t, i), () => { e.removeEventListener(t, i) } } const Ue = ["webkitTransitionEnd", "otransitionend", "oTransitionEnd", "msTransitionEnd", "transitionend"]; function Fe(e, t) { let n = r => { t(r), Ue.forEach((t => { e.removeEventListener(t, n) })) }; Ue.forEach((t => { e.addEventListener(t, n) })) } function Ve(e) { return Object.assign({ onClick: e }, Ge(e)) } function Ge(e) { return { tabIndex: 0, onKeyDown(t) { "Enter" !== t.key && " " !== t.key || (e(t), t.preventDefault()) } } } let qe = 0; function Ye() { return qe += 1, String(qe) } function Qe() { document.body.classList.add("fc-not-allowed") } function Ze() { document.body.classList.remove("fc-not-allowed") } function Xe(e) { e.style.userSelect = "none", e.addEventListener("selectstart", ze) } function $e(e) { e.style.userSelect = "", e.removeEventListener("selectstart", ze) } function Je(e) { e.addEventListener("contextmenu", ze) } function Ke(e) { e.removeEventListener("contextmenu", ze) } function et(e) { let t, n, r = [], i = []; for ("string" == typeof e ? i = e.split(/\s*,\s*/) : "function" == typeof e ? i = [e] : Array.isArray(e) && (i = e), t = 0; t < i.length; t += 1)n = i[t], "string" == typeof n ? r.push("-" === n.charAt(0) ? { field: n.substring(1), order: -1 } : { field: n, order: 1 }) : "function" == typeof n && r.push({ func: n }); return r } function tt(e, t, n) { let r, i; for (r = 0; r < n.length; r += 1)if (i = nt(e, t, n[r]), i) return i; return 0 } function nt(e, t, n) { return n.func ? n.func(e, t) : rt(e[n.field], t[n.field]) * (n.order || 1) } function rt(e, t) { return e || t ? null == t ? -1 : null == e ? 1 : "string" == typeof e || "string" == typeof t ? String(e).localeCompare(String(t)) : e - t : 0 } function it(e, t) { let n = String(e); return "000".substr(0, t - n.length) + n } function ot(e, t, n) { return "function" == typeof e ? e(...t) : "string" == typeof e ? t.reduce(((e, t, n) => e.replace("$" + n, t || "")), e) : n } function st(e, t) { return e - t } function at(e) { return e % 1 == 0 } function lt(e) { let t = e.querySelector(".fc-scrollgrid-shrink-frame"), n = e.querySelector(".fc-scrollgrid-shrink-cushion"); if (!t) throw new Error("needs fc-scrollgrid-shrink-frame className"); if (!n) throw new Error("needs fc-scrollgrid-shrink-cushion className"); return e.getBoundingClientRect().width - t.getBoundingClientRect().width + n.getBoundingClientRect().width } const dt = ["years", "months", "days", "milliseconds"], ct = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/; function ut(e, t) { return "string" == typeof e ? function (e) { let t = ct.exec(e); if (t) { let e = t[1] ? -1 : 1; return { years: 0, months: 0, days: e * (t[2] ? parseInt(t[2], 10) : 0), milliseconds: e * (60 * (t[3] ? parseInt(t[3], 10) : 0) * 60 * 1e3 + 60 * (t[4] ? parseInt(t[4], 10) : 0) * 1e3 + 1e3 * (t[5] ? parseInt(t[5], 10) : 0) + (t[6] ? parseInt(t[6], 10) : 0)) } } return null }(e) : "object" == typeof e && e ? ht(e) : "number" == typeof e ? ht({ [t || "milliseconds"]: e }) : null } function ht(e) { let t = { years: e.years || e.year || 0, months: e.months || e.month || 0, days: e.days || e.day || 0, milliseconds: 60 * (e.hours || e.hour || 0) * 60 * 1e3 + 60 * (e.minutes || e.minute || 0) * 1e3 + 1e3 * (e.seconds || e.second || 0) + (e.milliseconds || e.millisecond || e.ms || 0) }, n = e.weeks || e.week; return n && (t.days += 7 * n, t.specifiedWeeks = !0), t } function ft(e, t) { return { years: e.years + t.years, months: e.months + t.months, days: e.days + t.days, milliseconds: e.milliseconds + t.milliseconds } } function gt(e, t) { return { years: e.years * t, months: e.months * t, days: e.days * t, milliseconds: e.milliseconds * t } } function pt(e) { return mt(e) / 864e5 } function mt(e) { return 31536e6 * e.years + 2592e6 * e.months + 864e5 * e.days + e.milliseconds } function vt(e, t) { let n = null; for (let r = 0; r < dt.length; r += 1) { let i = dt[r]; if (t[i]) { let r = e[i] / t[i]; if (!at(r) || null !== n && n !== r) return null; n = r } else if (e[i]) return null } return n } function yt(e) { let t = e.milliseconds; if (t) { if (t % 1e3 != 0) return { unit: "millisecond", value: t }; if (t % 6e4 != 0) return { unit: "second", value: t / 1e3 }; if (t % 36e5 != 0) return { unit: "minute", value: t / 6e4 }; if (t) return { unit: "hour", value: t / 36e5 } } return e.days ? e.specifiedWeeks && e.days % 7 == 0 ? { unit: "week", value: e.days / 7 } : { unit: "day", value: e.days } : e.months ? { unit: "month", value: e.months } : e.years ? { unit: "year", value: e.years } : { unit: "millisecond", value: 0 } } const { hasOwnProperty: bt } = Object.prototype; function Et(e, t) { let n = {}; if (t) for (let r in t) if (t[r] === wn) { let t = []; for (let i = e.length - 1; i >= 0; i -= 1) { let o = e[i][r]; if ("object" == typeof o && o) t.unshift(o); else if (void 0 !== o) { n[r] = o; break } } t.length && (n[r] = Et(t)) } for (let t = e.length - 1; t >= 0; t -= 1) { let r = e[t]; for (let e in r) e in n || (n[e] = r[e]) } return n } function St(e, t) { let n = {}; for (let r in e) t(e[r], r) && (n[r] = e[r]); return n } function Ct(e, t) { let n = {}; for (let r in e) n[r] = t(e[r], r); return n } function wt(e) { let t = {}; for (let n of e) t[n] = !0; return t } function At(e) { let t = []; for (let n in e) t.push(e[n]); return t } function Dt(e, t) { if (e === t) return !0; for (let n in e) if (bt.call(e, n) && !(n in t)) return !1; for (let n in t) if (bt.call(t, n) && e[n] !== t[n]) return !1; return !0 } const Rt = /^on[A-Z]/; function xt(e, t) { let n = []; for (let r in e) bt.call(e, r) && (r in t || n.push(r)); for (let r in t) bt.call(t, r) && e[r] !== t[r] && n.push(r); return n } function Tt(e, t, n = {}) { if (e === t) return !0; for (let r in t) if (!(r in e) || !kt(e[r], t[r], n[r])) return !1; for (let n in e) if (!(n in t)) return !1; return !0 } function kt(e, t, n) { return e === t || !0 === n || !!n && n(e, t) } function _t(e, t = 0, n, r = 1) { let i = []; null == n && (n = Object.keys(e).length); for (let o = t; o < n; o += r) { let t = e[o]; void 0 !== t && i.push(t) } return i } function Mt(e, t, n) { if (e === t) return !0; let r, i = e.length; if (i !== t.length) return !1; for (r = 0; r < i; r += 1)if (!(n ? n(e[r], t[r]) : e[r] === t[r])) return !1; return !0 } const It = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"]; function Ot(e, t) { let n = qt(e); return n[2] += 7 * t, Yt(n) } function Nt(e, t) { let n = qt(e); return n[2] += t, Yt(n) } function Ht(e, t) { let n = qt(e); return n[6] += t, Yt(n) } function Pt(e, t) { return Bt(e, t) / 7 } function Bt(e, t) { return (t.valueOf() - e.valueOf()) / 864e5 } function Lt(e, t) { let n = jt(e), r = jt(t); return { years: 0, months: 0, days: Math.round(Bt(n, r)), milliseconds: t.valueOf() - r.valueOf() - (e.valueOf() - n.valueOf()) } } function Wt(e, t) { let n = zt(e, t); return null !== n && n % 7 == 0 ? n / 7 : null } function zt(e, t) { return Zt(e) === Zt(t) ? Math.round(Bt(e, t)) : null } function jt(e) { return Yt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()]) } function Ut(e, t, n, r) { let i = Yt([t, 0, 1 + Ft(t, n, r)]), o = jt(e), s = Math.round(Bt(i, o)); return Math.floor(s / 7) + 1 } function Ft(e, t, n) { let r = 7 + t - n; return -(7 + Yt([e, 0, r]).getUTCDay() - t) % 7 + r - 1 } function Vt(e) { return [e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()] } function Gt(e) { return new Date(e[0], e[1] || 0, null == e[2] ? 1 : e[2], e[3] || 0, e[4] || 0, e[5] || 0) } function qt(e) { return [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()] } function Yt(e) { return 1 === e.length && (e = e.concat([0])), new Date(Date.UTC(...e)) } function Qt(e) { return !isNaN(e.valueOf()) } function Zt(e) { return 1e3 * e.getUTCHours() * 60 * 60 + 1e3 * e.getUTCMinutes() * 60 + 1e3 * e.getUTCSeconds() + e.getUTCMilliseconds() } function Xt(e, t, n = !1) { let r = e.toISOString(); return r = r.replace(".000", ""), n && (r = r.replace("T00:00:00Z", "")), r.length > 10 && (null == t ? r = r.replace("Z", "") : 0 !== t && (r = r.replace("Z", en(t, !0)))), r } function $t(e) { return e.toISOString().replace(/T.*$/, "") } function Jt(e) { return e.toISOString().match(/^\d{4}-\d{2}/)[0] } function Kt(e) { return it(e.getUTCHours(), 2) + ":" + it(e.getUTCMinutes(), 2) + ":" + it(e.getUTCSeconds(), 2) } function en(e, t = !1) { let n = e < 0 ? "-" : "+", r = Math.abs(e), i = Math.floor(r / 60), o = Math.round(r % 60); return t ? `${n + it(i, 2)}:${it(o, 2)}` : `GMT${n}${i}${o ? ":" + it(o, 2) : ""}` } function tn(e, t, n) { let r, i; return function (...o) { if (r) { if (!Mt(r, o)) { n && n(i); let r = e.apply(this, o); t && t(r, i) || (i = r) } } else i = e.apply(this, o); return r = o, i } } function nn(e, t, n) { let r, i; return o => { if (r) { if (!Dt(r, o)) { n && n(i); let r = e.call(this, o); t && t(r, i) || (i = r) } } else i = e.call(this, o); return r = o, i } } const rn = { week: 3, separator: 0, omitZeroMinute: 0, meridiem: 0, omitCommas: 0 }, on = { timeZoneName: 7, era: 6, year: 5, month: 4, day: 2, weekday: 2, hour: 1, minute: 1, second: 1 }, sn = /\s*([ap])\.?m\.?/i, an = /,/g, ln = /\s+/g, dn = /\u200e/g, cn = /UTC|GMT/; class un { constructor(e) { let t = {}, n = {}, r = 0; for (let i in e) i in rn ? (n[i] = e[i], r = Math.max(rn[i], r)) : (t[i] = e[i], i in on && (r = Math.max(on[i], r))); this.standardDateProps = t, this.extendedSettings = n, this.severity = r, this.buildFormattingFunc = tn(hn) } format(e, t) { return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, t)(e) } formatRange(e, t, n, r) { let { standardDateProps: i, extendedSettings: o } = this, s = function (e, t, n) { return n.getMarkerYear(e) !== n.getMarkerYear(t) ? 5 : n.getMarkerMonth(e) !== n.getMarkerMonth(t) ? 4 : n.getMarkerDay(e) !== n.getMarkerDay(t) ? 2 : Zt(e) !== Zt(t) ? 1 : 0 }(e.marker, t.marker, n.calendarSystem); if (!s) return this.format(e, n); let a = s; !(a > 1) || "numeric" !== i.year && "2-digit" !== i.year || "numeric" !== i.month && "2-digit" !== i.month || "numeric" !== i.day && "2-digit" !== i.day || (a = 1); let l = this.format(e, n), d = this.format(t, n); if (l === d) return l; let c = hn(function (e, t) { let n = {}; for (let r in e) (!(r in on) || on[r] <= t) && (n[r] = e[r]); return n }(i, a), o, n), u = c(e), h = c(t), f = function (e, t, n, r) { let i = 0; for (; i < e.length;) { let o = e.indexOf(t, i); if (-1 === o) break; let s = e.substr(0, o); i = o + t.length; let a = e.substr(i), l = 0; for (; l < n.length;) { let e = n.indexOf(r, l); if (-1 === e) break; let t = n.substr(0, e); l = e + r.length; let i = n.substr(l); if (s === t && a === i) return { before: s, after: a } } } return null }(l, u, d, h), g = o.separator || r || n.defaultSeparator || ""; return f ? f.before + u + g + h + f.after : l + g + d } getLargestUnit() { switch (this.severity) { case 7: case 6: case 5: return "year"; case 4: return "month"; case 3: return "week"; case 2: return "day"; default: return "time" } } } function hn(e, t, n) { let r = Object.keys(e).length; return 1 === r && "short" === e.timeZoneName ? e => en(e.timeZoneOffset) : 0 === r && t.week ? e => function (e, t, n, r, i) { let o = []; return "long" === i ? o.push(n) : "short" !== i && "narrow" !== i || o.push(t), "long" !== i && "short" !== i || o.push(" "), o.push(r.simpleNumberFormat.format(e)), "rtl" === r.options.direction && o.reverse(), o.join("") }(n.computeWeekNumber(e.marker), n.weekText, n.weekTextLong, n.locale, t.week) : function (e, t, n) { e = Object.assign({}, e), t = Object.assign({}, t), function (e, t) { e.timeZoneName && (e.hour || (e.hour = "2-digit"), e.minute || (e.minute = "2-digit")), "long" === e.timeZoneName && (e.timeZoneName = "short"), t.omitZeroMinute && (e.second || e.millisecond) && delete t.omitZeroMinute }(e, t), e.timeZone = "UTC"; let r, i = new Intl.DateTimeFormat(n.locale.codes, e); if (t.omitZeroMinute) { let t = Object.assign({}, e); delete t.minute, r = new Intl.DateTimeFormat(n.locale.codes, t) } return o => { let s, { marker: a } = o; return s = r && !a.getUTCMinutes() ? r : i, function (e, t, n, r, i) { return e = e.replace(dn, ""), "short" === n.timeZoneName && (e = function (e, t) { let n = !1; return e = e.replace(cn, (() => (n = !0, t))), n || (e += " " + t), e }(e, "UTC" === i.timeZone || null == t.timeZoneOffset ? "UTC" : en(t.timeZoneOffset))), r.omitCommas && (e = e.replace(an, "").trim()), r.omitZeroMinute && (e = e.replace(":00", "")), !1 === r.meridiem ? e = e.replace(sn, "").trim() : "narrow" === r.meridiem ? e = e.replace(sn, ((e, t) => t.toLocaleLowerCase())) : "short" === r.meridiem ? e = e.replace(sn, ((e, t) => t.toLocaleLowerCase() + "m")) : "lowercase" === r.meridiem && (e = e.replace(sn, (e => e.toLocaleLowerCase()))), (e = e.replace(ln, " ")).trim() }(s.format(a), o, e, t, n) } }(e, t, n) } function fn(e, t) { let n = t.markerToArray(e.marker); return { marker: e.marker, timeZoneOffset: e.timeZoneOffset, array: n, year: n[0], month: n[1], day: n[2], hour: n[3], minute: n[4], second: n[5], millisecond: n[6] } } function gn(e, t, n, r) { let i = fn(e, n.calendarSystem); return { date: i, start: i, end: t ? fn(t, n.calendarSystem) : null, timeZone: n.timeZone, localeCodes: n.locale.codes, defaultSeparator: r || n.defaultSeparator } } class pn { constructor(e) { this.cmdStr = e } format(e, t, n) { return t.cmdFormatter(this.cmdStr, gn(e, null, t, n)) } formatRange(e, t, n, r) { return n.cmdFormatter(this.cmdStr, gn(e, t, n, r)) } } class mn { constructor(e) { this.func = e } format(e, t, n) { return this.func(gn(e, null, t, n)) } formatRange(e, t, n, r) { return this.func(gn(e, t, n, r)) } } function vn(e) { return "object" == typeof e && e ? new un(e) : "string" == typeof e ? new pn(e) : "function" == typeof e ? new mn(e) : null } const yn = { navLinkDayClick: Tn, navLinkWeekClick: Tn, duration: ut, bootstrapFontAwesome: Tn, buttonIcons: Tn, customButtons: Tn, defaultAllDayEventDuration: ut, defaultTimedEventDuration: ut, nextDayThreshold: ut, scrollTime: ut, scrollTimeReset: Boolean, slotMinTime: ut, slotMaxTime: ut, dayPopoverFormat: vn, slotDuration: ut, snapDuration: ut, headerToolbar: Tn, footerToolbar: Tn, defaultRangeSeparator: String, titleRangeSeparator: String, forceEventDuration: Boolean, dayHeaders: Boolean, dayHeaderFormat: vn, dayHeaderClassNames: Tn, dayHeaderContent: Tn, dayHeaderDidMount: Tn, dayHeaderWillUnmount: Tn, dayCellClassNames: Tn, dayCellContent: Tn, dayCellDidMount: Tn, dayCellWillUnmount: Tn, initialView: String, aspectRatio: Number, weekends: Boolean, weekNumberCalculation: Tn, weekNumbers: Boolean, weekNumberClassNames: Tn, weekNumberContent: Tn, weekNumberDidMount: Tn, weekNumberWillUnmount: Tn, editable: Boolean, viewClassNames: Tn, viewDidMount: Tn, viewWillUnmount: Tn, nowIndicator: Boolean, nowIndicatorClassNames: Tn, nowIndicatorContent: Tn, nowIndicatorDidMount: Tn, nowIndicatorWillUnmount: Tn, showNonCurrentDates: Boolean, lazyFetching: Boolean, startParam: String, endParam: String, timeZoneParam: String, timeZone: String, locales: Tn, locale: Tn, themeSystem: String, dragRevertDuration: Number, dragScroll: Boolean, allDayMaintainDuration: Boolean, unselectAuto: Boolean, dropAccept: Tn, eventOrder: et, eventOrderStrict: Boolean, handleWindowResize: Boolean, windowResizeDelay: Number, longPressDelay: Number, eventDragMinDistance: Number, expandRows: Boolean, height: Tn, contentHeight: Tn, direction: String, weekNumberFormat: vn, eventResizableFromStart: Boolean, displayEventTime: Boolean, displayEventEnd: Boolean, weekText: String, weekTextLong: String, progressiveEventRendering: Boolean, businessHours: Tn, initialDate: Tn, now: Tn, eventDataTransform: Tn, stickyHeaderDates: Tn, stickyFooterScrollbar: Tn, viewHeight: Tn, defaultAllDay: Boolean, eventSourceFailure: Tn, eventSourceSuccess: Tn, eventDisplay: String, eventStartEditable: Boolean, eventDurationEditable: Boolean, eventOverlap: Tn, eventConstraint: Tn, eventAllow: Tn, eventBackgroundColor: String, eventBorderColor: String, eventTextColor: String, eventColor: String, eventClassNames: Tn, eventContent: Tn, eventDidMount: Tn, eventWillUnmount: Tn, selectConstraint: Tn, selectOverlap: Tn, selectAllow: Tn, droppable: Boolean, unselectCancel: String, slotLabelFormat: Tn, slotLaneClassNames: Tn, slotLaneContent: Tn, slotLaneDidMount: Tn, slotLaneWillUnmount: Tn, slotLabelClassNames: Tn, slotLabelContent: Tn, slotLabelDidMount: Tn, slotLabelWillUnmount: Tn, dayMaxEvents: Tn, dayMaxEventRows: Tn, dayMinWidth: Number, slotLabelInterval: ut, allDayText: String, allDayClassNames: Tn, allDayContent: Tn, allDayDidMount: Tn, allDayWillUnmount: Tn, slotMinWidth: Number, navLinks: Boolean, eventTimeFormat: vn, rerenderDelay: Number, moreLinkText: Tn, moreLinkHint: Tn, selectMinDistance: Number, selectable: Boolean, selectLongPressDelay: Number, eventLongPressDelay: Number, selectMirror: Boolean, eventMaxStack: Number, eventMinHeight: Number, eventMinWidth: Number, eventShortHeight: Number, slotEventOverlap: Boolean, plugins: Tn, firstDay: Number, dayCount: Number, dateAlignment: String, dateIncrement: ut, hiddenDays: Tn, fixedWeekCount: Boolean, validRange: Tn, visibleRange: Tn, titleFormat: Tn, eventInteractive: Boolean, noEventsText: String, viewHint: Tn, navLinkHint: Tn, closeHint: String, timeHint: String, eventHint: String, moreLinkClick: Tn, moreLinkClassNames: Tn, moreLinkContent: Tn, moreLinkDidMount: Tn, moreLinkWillUnmount: Tn, monthStartFormat: vn, handleCustomRendering: Tn, customRenderingMetaMap: Tn, customRenderingReplacesEl: Boolean }, bn = { eventDisplay: "auto", defaultRangeSeparator: " - ", titleRangeSeparator: " â€“ ", defaultTimedEventDuration: "01:00:00", defaultAllDayEventDuration: { day: 1 }, forceEventDuration: !1, nextDayThreshold: "00:00:00", dayHeaders: !0, initialView: "", aspectRatio: 1.35, headerToolbar: { start: "title", center: "", end: "today prev,next" }, weekends: !0, weekNumbers: !1, weekNumberCalculation: "local", editable: !1, nowIndicator: !1, scrollTime: "06:00:00", scrollTimeReset: !0, slotMinTime: "00:00:00", slotMaxTime: "24:00:00", showNonCurrentDates: !0, lazyFetching: !0, startParam: "start", endParam: "end", timeZoneParam: "timeZone", timeZone: "local", locales: [], locale: "", themeSystem: "standard", dragRevertDuration: 500, dragScroll: !0, allDayMaintainDuration: !1, unselectAuto: !0, dropAccept: "*", eventOrder: "start,-duration,allDay,title", dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" }, handleWindowResize: !0, windowResizeDelay: 100, longPressDelay: 1e3, eventDragMinDistance: 5, expandRows: !1, navLinks: !1, selectable: !1, eventMinHeight: 15, eventMinWidth: 30, eventShortHeight: 30, monthStartFormat: { month: "long", day: "numeric" } }, En = { datesSet: Tn, eventsSet: Tn, eventAdd: Tn, eventChange: Tn, eventRemove: Tn, windowResize: Tn, eventClick: Tn, eventMouseEnter: Tn, eventMouseLeave: Tn, select: Tn, unselect: Tn, loading: Tn, _unmount: Tn, _beforeprint: Tn, _afterprint: Tn, _noEventDrop: Tn, _noEventResize: Tn, _resize: Tn, _scrollRequest: Tn }, Sn = { buttonText: Tn, buttonHints: Tn, views: Tn, plugins: Tn, initialEvents: Tn, events: Tn, eventSources: Tn }, Cn = { headerToolbar: wn, footerToolbar: wn, buttonText: wn, buttonHints: wn, buttonIcons: wn, dateIncrement: wn, plugins: An, events: An, eventSources: An, resources: An }; function wn(e, t) { return "object" == typeof e && "object" == typeof t && e && t ? Dt(e, t) : e === t } function An(e, t) { return Array.isArray(e) && Array.isArray(t) ? Mt(e, t) : e === t } const Dn = { type: String, component: Tn, buttonText: String, buttonTextKey: String, dateProfileGeneratorClass: Tn, usesMinMaxTime: Boolean, classNames: Tn, content: Tn, didMount: Tn, willUnmount: Tn }; function Rn(e) { return Et(e, Cn) } function xn(e, t) { let n = {}, r = {}; for (let r in t) r in e && (n[r] = t[r](e[r])); for (let n in e) n in t || (r[n] = e[n]); return { refined: n, extra: r } } function Tn(e) { return e } function kn(e, t, n, r) { return { instanceId: Ye(), defId: e, range: t, forcedStartTzo: null == n ? null : n, forcedEndTzo: null == r ? null : r } } function _n(e, t, n) { let { dateEnv: r, pluginHooks: i, options: o } = n, { defs: s, instances: a } = e; a = St(a, (e => !s[e.defId].recurringDef)); for (let e in s) { let n = s[e]; if (n.recurringDef) { let { duration: s } = n.recurringDef; s || (s = n.allDay ? o.defaultAllDayEventDuration : o.defaultTimedEventDuration); let l = Mn(n, s, t, r, i.recurringTypes); for (let t of l) { let n = kn(e, { start: t, end: r.add(t, s) }); a[n.instanceId] = n } } } return { defs: s, instances: a } } function Mn(e, t, n, r, i) { let o = i[e.recurringDef.typeId].expand(e.recurringDef.typeData, { start: r.subtract(n.start, t), end: n.end }, r); return e.allDay && (o = o.map(jt)), o } function In(e, t, n, r, i, o) { let s = { defs: {}, instances: {} }, a = Qn(n); for (let l of e) { let e = qn(l, t, n, r, a, i, o); e && On(e, s) } return s } function On(e, t = { defs: {}, instances: {} }) { return t.defs[e.def.defId] = e.def, e.instance && (t.instances[e.instance.instanceId] = e.instance), t } function Nn(e, t) { let n = e.instances[t]; if (n) { let t = e.defs[n.defId], r = Pn(e, (e => { return n = t, r = e, Boolean(n.groupId && n.groupId === r.groupId); var n, r })); return r.defs[t.defId] = t, r.instances[n.instanceId] = n, r } return { defs: {}, instances: {} } } function Hn(e, t) { return { defs: Object.assign(Object.assign({}, e.defs), t.defs), instances: Object.assign(Object.assign({}, e.instances), t.instances) } } function Pn(e, t) { let n = St(e.defs, t), r = St(e.instances, (e => n[e.defId])); return { defs: n, instances: r } } function Bn(e) { return Array.isArray(e) ? e : "string" == typeof e ? e.split(/\s+/) : [] } const Ln = { display: String, editable: Boolean, startEditable: Boolean, durationEditable: Boolean, constraint: Tn, overlap: Tn, allow: Tn, className: Bn, classNames: Bn, color: String, backgroundColor: String, borderColor: String, textColor: String }, Wn = { display: null, startEditable: null, durationEditable: null, constraints: [], overlap: null, allows: [], backgroundColor: "", borderColor: "", textColor: "", classNames: [] }; function zn(e, t) { let n = function (e, t) { return Array.isArray(e) ? In(e, null, t, !0) : "object" == typeof e && e ? In([e], null, t, !0) : null != e ? String(e) : null }(e.constraint, t); return { display: e.display || null, startEditable: null != e.startEditable ? e.startEditable : e.editable, durationEditable: null != e.durationEditable ? e.durationEditable : e.editable, constraints: null != n ? [n] : [], overlap: null != e.overlap ? e.overlap : null, allows: null != e.allow ? [e.allow] : [], backgroundColor: e.backgroundColor || e.color || "", borderColor: e.borderColor || e.color || "", textColor: e.textColor || "", classNames: (e.className || []).concat(e.classNames || []) } } function jn(e) { return e.reduce(Un, Wn) } function Un(e, t) { return { display: null != t.display ? t.display : e.display, startEditable: null != t.startEditable ? t.startEditable : e.startEditable, durationEditable: null != t.durationEditable ? t.durationEditable : e.durationEditable, constraints: e.constraints.concat(t.constraints), overlap: "boolean" == typeof t.overlap ? t.overlap : e.overlap, allows: e.allows.concat(t.allows), backgroundColor: t.backgroundColor || e.backgroundColor, borderColor: t.borderColor || e.borderColor, textColor: t.textColor || e.textColor, classNames: e.classNames.concat(t.classNames) } } const Fn = { id: String, groupId: String, title: String, url: String, interactive: Boolean }, Vn = { start: Tn, end: Tn, date: Tn, allDay: Boolean }, Gn = Object.assign(Object.assign(Object.assign({}, Fn), Vn), { extendedProps: Tn }); function qn(e, t, n, r, i = Qn(n), o, s) { let { refined: a, extra: l } = Yn(e, n, i), d = function (e, t) { let n = null; return e && (n = e.defaultAllDay), null == n && (n = t.options.defaultAllDay), n }(t, n), c = function (e, t, n, r) { for (let i = 0; i < r.length; i += 1) { let o = r[i].parse(e, n); if (o) { let { allDay: n } = e; return null == n && (n = t, null == n && (n = o.allDayGuess, null == n && (n = !1))), { allDay: n, duration: o.duration, typeData: o.typeData, typeId: i } } } return null }(a, d, n.dateEnv, n.pluginHooks.recurringTypes); if (c) { let e = Zn(a, l, t ? t.sourceId : "", c.allDay, Boolean(c.duration), n, o); return e.recurringDef = { typeId: c.typeId, typeData: c.typeData, duration: c.duration }, { def: e, instance: null } } let u = function (e, t, n, r) { let i, o, { allDay: s } = e, a = null, l = !1, d = null, c = null != e.start ? e.start : e.date; if (i = n.dateEnv.createMarkerMeta(c), i) a = i.marker; else if (!r) return null; return null != e.end && (o = n.dateEnv.createMarkerMeta(e.end)), null == s && (s = null != t ? t : (!i || i.isTimeUnspecified) && (!o || o.isTimeUnspecified)), s && a && (a = jt(a)), o && (d = o.marker, s && (d = jt(d)), a && d <= a && (d = null)), d ? l = !0 : r || (l = n.options.forceEventDuration || !1, d = n.dateEnv.add(a, s ? n.options.defaultAllDayEventDuration : n.options.defaultTimedEventDuration)), { allDay: s, hasEnd: l, range: { start: a, end: d }, forcedStartTzo: i ? i.forcedTzo : null, forcedEndTzo: o ? o.forcedTzo : null } }(a, d, n, r); if (u) { let e = Zn(a, l, t ? t.sourceId : "", u.allDay, u.hasEnd, n, o), r = kn(e.defId, u.range, u.forcedStartTzo, u.forcedEndTzo); return s && e.publicId && s[e.publicId] && (r.instanceId = s[e.publicId]), { def: e, instance: r } } return null } function Yn(e, t, n = Qn(t)) { return xn(e, n) } function Qn(e) { return Object.assign(Object.assign(Object.assign({}, Ln), Gn), e.pluginHooks.eventRefiners) } function Zn(e, t, n, r, i, o, s) { let a = { title: e.title || "", groupId: e.groupId || "", publicId: e.id || "", url: e.url || "", recurringDef: null, defId: (s && e.id ? s[e.id] : "") || Ye(), sourceId: n, allDay: r, hasEnd: i, interactive: e.interactive, ui: zn(e, o), extendedProps: Object.assign(Object.assign({}, e.extendedProps || {}), t) }; for (let t of o.pluginHooks.eventDefMemberAdders) Object.assign(a, t(e)); return Object.freeze(a.ui.classNames), Object.freeze(a.extendedProps), a } const Xn = { startTime: "09:00", endTime: "17:00", daysOfWeek: [1, 2, 3, 4, 5], display: "inverse-background", classNames: "fc-non-business", groupId: "_businessHours" }; function $n(e, t) { return In(function (e) { let t; return t = !0 === e ? [{}] : Array.isArray(e) ? e.filter((e => e.daysOfWeek)) : "object" == typeof e && e ? [e] : [], t = t.map((e => Object.assign(Object.assign({}, Xn), e))), t }(e), null, t) } function Jn(e) { let t = Math.floor(Bt(e.start, e.end)) || 1, n = jt(e.start); return { start: n, end: Nt(n, t) } } function Kn(e, t = ut(0)) { let n = null, r = null; if (e.end) { r = jt(e.end); let n = e.end.valueOf() - r.valueOf(); n && n >= mt(t) && (r = Nt(r, 1)) } return e.start && (n = jt(e.start), r && r <= n && (r = Nt(n, 1))), { start: n, end: r } } function er(e) { let t = Kn(e); return Bt(t.start, t.end) > 1 } function tr(e, t, n, r) { return "year" === r ? ut(n.diffWholeYears(e, t), "year") : "month" === r ? ut(n.diffWholeMonths(e, t), "month") : Lt(e, t) } function nr(e, t) { return e.left >= t.left && e.left < t.right && e.top >= t.top && e.top < t.bottom } function rr(e, t) { let n = { left: Math.max(e.left, t.left), right: Math.min(e.right, t.right), top: Math.max(e.top, t.top), bottom: Math.min(e.bottom, t.bottom) }; return n.left < n.right && n.top < n.bottom && n } function ir(e, t) { return { left: Math.min(Math.max(e.left, t.left), t.right), top: Math.min(Math.max(e.top, t.top), t.bottom) } } function or(e) { return { left: (e.left + e.right) / 2, top: (e.top + e.bottom) / 2 } } function sr(e, t) { return { left: e.left - t.left, top: e.top - t.top } } let ar; function lr() { return null == ar && (ar = function () { if ("undefined" == typeof document) return !0; let e = document.createElement("div"); e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.innerHTML = "<table><tr><td><div></div></td></tr></table>", e.querySelector("table").style.height = "100px", e.querySelector("div").style.height = "100%", document.body.appendChild(e); let t = e.querySelector("div").offsetHeight > 0; return document.body.removeChild(e), t }()), ar } const dr = { defs: {}, instances: {} }; class cr { constructor() { this.getKeysForEventDefs = tn(this._getKeysForEventDefs), this.splitDateSelection = tn(this._splitDateSpan), this.splitEventStore = tn(this._splitEventStore), this.splitIndividualUi = tn(this._splitIndividualUi), this.splitEventDrag = tn(this._splitInteraction), this.splitEventResize = tn(this._splitInteraction), this.eventUiBuilders = {} } splitProps(e) { let t = this.getKeyInfo(e), n = this.getKeysForEventDefs(e.eventStore), r = this.splitDateSelection(e.dateSelection), i = this.splitIndividualUi(e.eventUiBases, n), o = this.splitEventStore(e.eventStore, n), s = this.splitEventDrag(e.eventDrag), a = this.splitEventResize(e.eventResize), l = {}; this.eventUiBuilders = Ct(t, ((e, t) => this.eventUiBuilders[t] || tn(ur))); for (let n in t) { let d = t[n], c = o[n] || dr, u = this.eventUiBuilders[n]; l[n] = { businessHours: d.businessHours || e.businessHours, dateSelection: r[n] || null, eventStore: c, eventUiBases: u(e.eventUiBases[""], d.ui, i[n]), eventSelection: c.instances[e.eventSelection] ? e.eventSelection : "", eventDrag: s[n] || null, eventResize: a[n] || null } } return l } _splitDateSpan(e) { let t = {}; if (e) { let n = this.getKeysForDateSpan(e); for (let r of n) t[r] = e } return t } _getKeysForEventDefs(e) { return Ct(e.defs, (e => this.getKeysForEventDef(e))) } _splitEventStore(e, t) { let { defs: n, instances: r } = e, i = {}; for (let e in n) for (let r of t[e]) i[r] || (i[r] = { defs: {}, instances: {} }), i[r].defs[e] = n[e]; for (let e in r) { let n = r[e]; for (let r of t[n.defId]) i[r] && (i[r].instances[e] = n) } return i } _splitIndividualUi(e, t) { let n = {}; for (let r in e) if (r) for (let i of t[r]) n[i] || (n[i] = {}), n[i][r] = e[r]; return n } _splitInteraction(e) { let t = {}; if (e) { let n = this._splitEventStore(e.affectedEvents, this._getKeysForEventDefs(e.affectedEvents)), r = this._getKeysForEventDefs(e.mutatedEvents), i = this._splitEventStore(e.mutatedEvents, r), o = r => { t[r] || (t[r] = { affectedEvents: n[r] || dr, mutatedEvents: i[r] || dr, isEvent: e.isEvent }) }; for (let e in n) o(e); for (let e in i) o(e) } return t } } function ur(e, t, n) { let r = []; e && r.push(e), t && r.push(t); let i = { "": jn(r) }; return n && Object.assign(i, n), i } function hr(e, t) { let n, r, i = [], { start: o } = t; for (e.sort(fr), n = 0; n < e.length; n += 1)r = e[n], r.start > o && i.push({ start: o, end: r.start }), r.end > o && (o = r.end); return o < t.end && i.push({ start: o, end: t.end }), i } function fr(e, t) { return e.start.valueOf() - t.start.valueOf() } function gr(e, t) { let { start: n, end: r } = e, i = null; return null !== t.start && (n = null === n ? t.start : new Date(Math.max(n.valueOf(), t.start.valueOf()))), null != t.end && (r = null === r ? t.end : new Date(Math.min(r.valueOf(), t.end.valueOf()))), (null === n || null === r || n < r) && (i = { start: n, end: r }), i } function pr(e, t) { return (null === e.start ? null : e.start.valueOf()) === (null === t.start ? null : t.start.valueOf()) && (null === e.end ? null : e.end.valueOf()) === (null === t.end ? null : t.end.valueOf()) } function mr(e, t) { return (null === e.end || null === t.start || e.end > t.start) && (null === e.start || null === t.end || e.start < t.end) } function vr(e, t) { return (null === e.start || null !== t.start && t.start >= e.start) && (null === e.end || null !== t.end && t.end <= e.end) } function yr(e, t) { return (null === e.start || t >= e.start) && (null === e.end || t < e.end) } function br(e, t, n, r) { return { dow: e.getUTCDay(), isDisabled: Boolean(r && !yr(r.activeRange, e)), isOther: Boolean(r && !yr(r.currentRange, e)), isToday: Boolean(t && yr(t, e)), isPast: Boolean(n ? e < n : !!t && e < t.start), isFuture: Boolean(n ? e > n : !!t && e >= t.end) } } function Er(e, t) { let n = ["fc-day", "fc-day-" + It[e.dow]]; return e.isDisabled ? n.push("fc-day-disabled") : (e.isToday && (n.push("fc-day-today"), n.push(t.getClass("today"))), e.isPast && n.push("fc-day-past"), e.isFuture && n.push("fc-day-future"), e.isOther && n.push("fc-day-other")), n } const Sr = vn({ year: "numeric", month: "long", day: "numeric" }), Cr = vn({ week: "long" }); function wr(e, t, n = "day", r = !0) { const { dateEnv: i, options: o, calendarApi: s } = e; let a = i.format(t, "week" === n ? Cr : Sr); if (o.navLinks) { let e = i.toDate(t); const l = e => { let r = "day" === n ? o.navLinkDayClick : "week" === n ? o.navLinkWeekClick : null; "function" == typeof r ? r.call(s, i.toDate(t), e) : ("string" == typeof r && (n = r), s.zoomTo(t, n)) }; return Object.assign({ title: ot(o.navLinkHint, [a, e], a), "data-navlink": "" }, r ? Ve(l) : { onClick: l }) } return { "aria-label": a } } let Ar, Dr = null; function Rr() { return null === Dr && (Dr = function () { let e = document.createElement("div"); He(e, { position: "absolute", top: -1e3, left: 0, border: 0, padding: 0, overflow: "scroll", direction: "rtl" }), e.innerHTML = "<div></div>", document.body.appendChild(e); let t = e.firstChild.getBoundingClientRect().left > e.getBoundingClientRect().left; return _e(e), t }()), Dr } function xr() { return Ar || (Ar = function () { let e = document.createElement("div"); e.style.overflow = "scroll", e.style.position = "absolute", e.style.top = "-9999px", e.style.left = "-9999px", document.body.appendChild(e); let t = Tr(e); return document.body.removeChild(e), t }()), Ar } function Tr(e) { return { x: e.offsetHeight - e.clientHeight, y: e.offsetWidth - e.clientWidth } } function kr(e, t = !1) { let n = window.getComputedStyle(e), r = parseInt(n.borderLeftWidth, 10) || 0, i = parseInt(n.borderRightWidth, 10) || 0, o = parseInt(n.borderTopWidth, 10) || 0, s = parseInt(n.borderBottomWidth, 10) || 0, a = Tr(e), l = a.y - r - i, d = { borderLeft: r, borderRight: i, borderTop: o, borderBottom: s, scrollbarBottom: a.x - o - s, scrollbarLeft: 0, scrollbarRight: 0 }; return Rr() && "rtl" === n.direction ? d.scrollbarLeft = l : d.scrollbarRight = l, t && (d.paddingLeft = parseInt(n.paddingLeft, 10) || 0, d.paddingRight = parseInt(n.paddingRight, 10) || 0, d.paddingTop = parseInt(n.paddingTop, 10) || 0, d.paddingBottom = parseInt(n.paddingBottom, 10) || 0), d } function _r(e, t = !1, n) { let r = n ? e.getBoundingClientRect() : Mr(e), i = kr(e, t), o = { left: r.left + i.borderLeft + i.scrollbarLeft, right: r.right - i.borderRight - i.scrollbarRight, top: r.top + i.borderTop, bottom: r.bottom - i.borderBottom - i.scrollbarBottom }; return t && (o.left += i.paddingLeft, o.right -= i.paddingRight, o.top += i.paddingTop, o.bottom -= i.paddingBottom), o } function Mr(e) { let t = e.getBoundingClientRect(); return { left: t.left + window.pageXOffset, top: t.top + window.pageYOffset, right: t.right + window.pageXOffset, bottom: t.bottom + window.pageYOffset } } function Ir(e) { let t = []; for (; e instanceof HTMLElement;) { let n = window.getComputedStyle(e); if ("fixed" === n.position) break; /(auto|scroll)/.test(n.overflow + n.overflowY + n.overflowX) && t.push(e), e = e.parentNode } return t } function Or(e, t, n) { let r = !1, i = function (e) { r || (r = !0, t(e)) }, o = function (e) { r || (r = !0, n(e)) }, s = e(i, o); s && "function" == typeof s.then && s.then(i, o) } class Nr { constructor() { this.handlers = {}, this.thisContext = null } setThisContext(e) { this.thisContext = e } setOptions(e) { this.options = e } on(e, t) { !function (e, t, n) { (e[t] || (e[t] = [])).push(n) }(this.handlers, e, t) } off(e, t) { !function (e, t, n) { n ? e[t] && (e[t] = e[t].filter((e => e !== n))) : delete e[t] }(this.handlers, e, t) } trigger(e, ...t) { let n = this.handlers[e] || [], r = this.options && this.options[e], i = [].concat(r || [], n); for (let e of i) e.apply(this.thisContext, t) } hasHandlers(e) { return Boolean(this.handlers[e] && this.handlers[e].length || this.options && this.options[e]) } } class Hr { constructor(e, t, n, r) { this.els = t; let i = this.originClientRect = e.getBoundingClientRect(); n && this.buildElHorizontals(i.left), r && this.buildElVerticals(i.top) } buildElHorizontals(e) { let t = [], n = []; for (let r of this.els) { let i = r.getBoundingClientRect(); t.push(i.left - e), n.push(i.right - e) } this.lefts = t, this.rights = n } buildElVerticals(e) { let t = [], n = []; for (let r of this.els) { let i = r.getBoundingClientRect(); t.push(i.top - e), n.push(i.bottom - e) } this.tops = t, this.bottoms = n } leftToIndex(e) { let t, { lefts: n, rights: r } = this, i = n.length; for (t = 0; t < i; t += 1)if (e >= n[t] && e < r[t]) return t } topToIndex(e) { let t, { tops: n, bottoms: r } = this, i = n.length; for (t = 0; t < i; t += 1)if (e >= n[t] && e < r[t]) return t } getWidth(e) { return this.rights[e] - this.lefts[e] } getHeight(e) { return this.bottoms[e] - this.tops[e] } similarTo(e) { return Pr(this.tops || [], e.tops || []) && Pr(this.bottoms || [], e.bottoms || []) && Pr(this.lefts || [], e.lefts || []) && Pr(this.rights || [], e.rights || []) } } function Pr(e, t) { const n = e.length; if (n !== t.length) return !1; for (let r = 0; r < n; r++)if (Math.round(e[r]) !== Math.round(t[r])) return !1; return !0 } class Br { getMaxScrollTop() { return this.getScrollHeight() - this.getClientHeight() } getMaxScrollLeft() { return this.getScrollWidth() - this.getClientWidth() } canScrollVertically() { return this.getMaxScrollTop() > 0 } canScrollHorizontally() { return this.getMaxScrollLeft() > 0 } canScrollUp() { return this.getScrollTop() > 0 } canScrollDown() { return this.getScrollTop() < this.getMaxScrollTop() } canScrollLeft() { return this.getScrollLeft() > 0 } canScrollRight() { return this.getScrollLeft() < this.getMaxScrollLeft() } } class Lr extends Br { constructor(e) { super(), this.el = e } getScrollTop() { return this.el.scrollTop } getScrollLeft() { return this.el.scrollLeft } setScrollTop(e) { this.el.scrollTop = e } setScrollLeft(e) { this.el.scrollLeft = e } getScrollWidth() { return this.el.scrollWidth } getScrollHeight() { return this.el.scrollHeight } getClientHeight() { return this.el.clientHeight } getClientWidth() { return this.el.clientWidth } } class Wr extends Br { getScrollTop() { return window.pageYOffset } getScrollLeft() { return window.pageXOffset } setScrollTop(e) { window.scroll(window.pageXOffset, e) } setScrollLeft(e) { window.scroll(e, window.pageYOffset) } getScrollWidth() { return document.documentElement.scrollWidth } getScrollHeight() { return document.documentElement.scrollHeight } getClientHeight() { return document.documentElement.clientHeight } getClientWidth() { return document.documentElement.clientWidth } } class zr { constructor(e) { this.iconOverrideOption && this.setIconOverride(e[this.iconOverrideOption]) } setIconOverride(e) { let t, n; if ("object" == typeof e && e) { for (n in t = Object.assign({}, this.iconClasses), e) t[n] = this.applyIconOverridePrefix(e[n]); this.iconClasses = t } else !1 === e && (this.iconClasses = {}) } applyIconOverridePrefix(e) { let t = this.iconOverridePrefix; return t && 0 !== e.indexOf(t) && (e = t + e), e } getClass(e) { return this.classes[e] || "" } getIconClass(e, t) { let n; return n = t && this.rtlIconClasses && this.rtlIconClasses[e] || this.iconClasses[e], n ? `${this.baseIconClass} ${n}` : "" } getCustomButtonIconClass(e) { let t; return this.iconOverrideCustomButtonOption && (t = e[this.iconOverrideCustomButtonOption], t) ? `${this.baseIconClass} ${this.applyIconOverridePrefix(t)}` : "" } } function jr(e) { e(); let t = n.debounceRendering, r = []; for (n.debounceRendering = function (e) { r.push(e) }, W(p(Ur, {}), document.createElement("div")); r.length;)r.shift()(); n.debounceRendering = t } zr.prototype.classes = {}, zr.prototype.iconClasses = {}, zr.prototype.baseIconClass = "", zr.prototype.iconOverridePrefix = ""; class Ur extends C { render() { return p("div", {}) } componentDidMount() { this.setState({}) } } function Fr(e) { let t = function (e, t) { var n = { __c: t = "__cC" + d++, __: e, Consumer: function (e, t) { return e.children(t) }, Provider: function (e) { var n, r; return this.getChildContext || (n = [], (r = {})[t] = this, this.getChildContext = function () { return r }, this.shouldComponentUpdate = function (e) { this.props.value !== e.value && n.some((function (e) { e.__e = !0, R(e) })) }, this.sub = function (e) { n.push(e); var t = e.componentWillUnmount; e.componentWillUnmount = function () { n.splice(n.indexOf(e), 1), t && t.call(e) } }), e.children } }; return n.Provider.__ = n.Consumer.contextType = n }(e), n = t.Provider; return t.Provider = function () { let e = !this.getChildContext, t = n.apply(this, arguments); if (e) { let e = []; this.shouldComponentUpdate = t => { this.props.value !== t.value && e.forEach((e => { e.context = t.value, e.forceUpdate() })) }, this.sub = t => { e.push(t); let n = t.componentWillUnmount; t.componentWillUnmount = () => { e.splice(e.indexOf(t), 1), n && n.call(t) } } } return t }, t } class Vr { constructor(e, t, n, r) { this.execFunc = e, this.emitter = t, this.scrollTime = n, this.scrollTimeReset = r, this.handleScrollRequest = e => { this.queuedRequest = Object.assign({}, this.queuedRequest || {}, e), this.drain() }, t.on("_scrollRequest", this.handleScrollRequest), this.fireInitialScroll() } detach() { this.emitter.off("_scrollRequest", this.handleScrollRequest) } update(e) { e && this.scrollTimeReset ? this.fireInitialScroll() : this.drain() } fireInitialScroll() { this.handleScrollRequest({ time: this.scrollTime }) } drain() { this.queuedRequest && this.execFunc(this.queuedRequest) && (this.queuedRequest = null) } } const Gr = Fr({}); function qr(e, t, n, r, i, o, s, a, l, d, c, u, h) { return { dateEnv: i, options: n, pluginHooks: s, emitter: d, dispatch: a, getCurrentData: l, calendarApi: c, viewSpec: e, viewApi: t, dateProfileGenerator: r, theme: o, isRtl: "rtl" === n.direction, addResizeHandler(e) { d.on("_resize", e) }, removeResizeHandler(e) { d.off("_resize", e) }, createScrollResponder: e => new Vr(e, d, ut(n.scrollTime), n.scrollTimeReset), registerInteractiveComponent: u, unregisterInteractiveComponent: h } } class Yr extends C { shouldComponentUpdate(e, t) { return this.debug && console.log(xt(e, this.props), xt(t, this.state)), !Tt(this.props, e, this.propEquality) || !Tt(this.state, t, this.stateEquality) } safeSetState(e) { Tt(this.state, Object.assign(Object.assign({}, this.state), e), this.stateEquality) || this.setState(e) } } Yr.addPropsEquality = function (e) { let t = Object.create(this.prototype.propEquality); Object.assign(t, e), this.prototype.propEquality = t }, Yr.addStateEquality = function (e) { let t = Object.create(this.prototype.stateEquality); Object.assign(t, e), this.prototype.stateEquality = t }, Yr.contextType = Gr, Yr.prototype.propEquality = {}, Yr.prototype.stateEquality = {}; class Qr extends Yr { } function Zr(e, t) { "function" == typeof e ? e(t) : e && (e.current = t) } Qr.contextType = Gr; class Xr extends Qr { constructor() { super(...arguments), this.uid = Ye() } prepareHits() { } queryHit(e, t, n, r) { return null } isValidSegDownEl(e) { return !this.props.eventDrag && !this.props.eventResize && !Me(e, ".fc-event-mirror") } isValidDateDownEl(e) { return !(Me(e, ".fc-event:not(.fc-bg-event)") || Me(e, ".fc-more-link") || Me(e, "a[data-navlink]") || Me(e, ".fc-popover")) } } function $r(e, t) { return "function" == typeof e && (e = e()), null == e ? t.createNowMarker() : t.createMarker(e) } class Jr { constructor(e) { this.props = e, this.nowDate = $r(e.nowInput, e.dateEnv), this.initHiddenDays() } buildPrev(e, t, n) { let { dateEnv: r } = this.props, i = r.subtract(r.startOf(t, e.currentRangeUnit), e.dateIncrement); return this.build(i, -1, n) } buildNext(e, t, n) { let { dateEnv: r } = this.props, i = r.add(r.startOf(t, e.currentRangeUnit), e.dateIncrement); return this.build(i, 1, n) } build(e, t, n = !0) { let r, i, o, s, a, l, { props: d } = this; var c, u; return r = this.buildValidRange(), r = this.trimHiddenDays(r), n && (c = e, e = null != (u = r).start && c < u.start ? u.start : null != u.end && c >= u.end ? new Date(u.end.valueOf() - 1) : c), i = this.buildCurrentRangeInfo(e, t), o = /^(year|month|week|day)$/.test(i.unit), s = this.buildRenderRange(this.trimHiddenDays(i.range), i.unit, o), s = this.trimHiddenDays(s), a = s, d.showNonCurrentDates || (a = gr(a, i.range)), a = this.adjustActiveRange(a), a = gr(a, r), l = mr(i.range, r), yr(s, e) || (e = s.start), { currentDate: e, validRange: r, currentRange: i.range, currentRangeUnit: i.unit, isRangeAllDay: o, activeRange: a, renderRange: s, slotMinTime: d.slotMinTime, slotMaxTime: d.slotMaxTime, isValid: l, dateIncrement: this.buildDateIncrement(i.duration) } } buildValidRange() { let e = this.props.validRangeInput, t = "function" == typeof e ? e.call(this.props.calendarApi, this.nowDate) : e; return this.refineRange(t) || { start: null, end: null } } buildCurrentRangeInfo(e, t) { let n, { props: r } = this, i = null, o = null, s = null; return r.duration ? (i = r.duration, o = r.durationUnit, s = this.buildRangeFromDuration(e, t, i, o)) : (n = this.props.dayCount) ? (o = "day", s = this.buildRangeFromDayCount(e, t, n)) : (s = this.buildCustomVisibleRange(e)) ? o = r.dateEnv.greatestWholeUnit(s.start, s.end).unit : (i = this.getFallbackDuration(), o = yt(i).unit, s = this.buildRangeFromDuration(e, t, i, o)), { duration: i, unit: o, range: s } } getFallbackDuration() { return ut({ day: 1 }) } adjustActiveRange(e) { let { dateEnv: t, usesMinMaxTime: n, slotMinTime: r, slotMaxTime: i } = this.props, { start: o, end: s } = e; return n && (pt(r) < 0 && (o = jt(o), o = t.add(o, r)), pt(i) > 1 && (s = jt(s), s = Nt(s, -1), s = t.add(s, i))), { start: o, end: s } } buildRangeFromDuration(e, t, n, r) { let i, o, s, { dateEnv: a, dateAlignment: l } = this.props; if (!l) { let { dateIncrement: e } = this.props; l = e && mt(e) < mt(n) ? yt(e).unit : r } function d() { i = a.startOf(e, l), o = a.add(i, n), s = { start: i, end: o } } return pt(n) <= 1 && this.isHiddenDay(i) && (i = this.skipHiddenDays(i, t), i = jt(i)), d(), this.trimHiddenDays(s) || (e = this.skipHiddenDays(e, t), d()), s } buildRangeFromDayCount(e, t, n) { let r, { dateEnv: i, dateAlignment: o } = this.props, s = 0, a = e; o && (a = i.startOf(a, o)), a = jt(a), a = this.skipHiddenDays(a, t), r = a; do { r = Nt(r, 1), this.isHiddenDay(r) || (s += 1) } while (s < n); return { start: a, end: r } } buildCustomVisibleRange(e) { let { props: t } = this, n = t.visibleRangeInput, r = "function" == typeof n ? n.call(t.calendarApi, t.dateEnv.toDate(e)) : n, i = this.refineRange(r); return !i || null != i.start && null != i.end ? i : null } buildRenderRange(e, t, n) { return e } buildDateIncrement(e) { let t, { dateIncrement: n } = this.props; return n || ((t = this.props.dateAlignment) ? ut(1, t) : e || ut({ days: 1 })) } refineRange(e) { if (e) { let t = function (e, t) { let n = null, r = null; return e.start && (n = t.createMarker(e.start)), e.end && (r = t.createMarker(e.end)), n || r ? n && r && r < n ? null : { start: n, end: r } : null }(e, this.props.dateEnv); return t && (t = Kn(t)), t } return null } initHiddenDays() { let e, t = this.props.hiddenDays || [], n = [], r = 0; for (!1 === this.props.weekends && t.push(0, 6), e = 0; e < 7; e += 1)(n[e] = -1 !== t.indexOf(e)) || (r += 1); if (!r) throw new Error("invalid hiddenDays"); this.isHiddenDayHash = n } trimHiddenDays(e) { let { start: t, end: n } = e; return t && (t = this.skipHiddenDays(t)), n && (n = this.skipHiddenDays(n, -1, !0)), null == t || null == n || t < n ? { start: t, end: n } : null } isHiddenDay(e) { return e instanceof Date && (e = e.getUTCDay()), this.isHiddenDayHash[e] } skipHiddenDays(e, t = 1, n = !1) { for (; this.isHiddenDayHash[(e.getUTCDay() + (n ? t : 0) + 7) % 7];)e = Nt(e, t); return e } } function Kr(e, t, n) { n.emitter.trigger("select", Object.assign(Object.assign({}, ei(e, n)), { jsEvent: t ? t.origEvent : null, view: n.viewApi || n.calendarApi.view })) } function ei(e, t) { let n = {}; for (let r of t.pluginHooks.dateSpanTransforms) Object.assign(n, r(e, t)); var r, i; return Object.assign(n, (r = e, i = t.dateEnv, Object.assign(Object.assign({}, Ti(r.range, i, r.allDay)), { allDay: r.allDay }))), n } function ti(e, t, n) { let { dateEnv: r, options: i } = n, o = t; return e ? (o = jt(o), o = r.add(o, i.defaultAllDayEventDuration)) : o = r.add(o, i.defaultTimedEventDuration), o } function ni(e, t, n, r) { let i = fi(e.defs, t), o = { defs: {}, instances: {} }; for (let t in e.defs) { let s = e.defs[t]; o.defs[t] = ri(s, i[t], n, r) } for (let t in e.instances) { let s = e.instances[t], a = o.defs[s.defId]; o.instances[t] = ii(s, a, i[s.defId], n, r) } return o } function ri(e, t, n, r) { let i = n.standardProps || {}; null == i.hasEnd && t.durationEditable && (n.startDelta || n.endDelta) && (i.hasEnd = !0); let o = Object.assign(Object.assign(Object.assign({}, e), i), { ui: Object.assign(Object.assign({}, e.ui), i.ui) }); n.extendedProps && (o.extendedProps = Object.assign(Object.assign({}, o.extendedProps), n.extendedProps)); for (let e of r.pluginHooks.eventDefMutationAppliers) e(o, n, r); return !o.hasEnd && r.options.forceEventDuration && (o.hasEnd = !0), o } function ii(e, t, n, r, i) { let { dateEnv: o } = i, s = r.standardProps && !0 === r.standardProps.allDay, a = r.standardProps && !1 === r.standardProps.hasEnd, l = Object.assign({}, e); return s && (l.range = Jn(l.range)), r.datesDelta && n.startEditable && (l.range = { start: o.add(l.range.start, r.datesDelta), end: o.add(l.range.end, r.datesDelta) }), r.startDelta && n.durationEditable && (l.range = { start: o.add(l.range.start, r.startDelta), end: l.range.end }), r.endDelta && n.durationEditable && (l.range = { start: l.range.start, end: o.add(l.range.end, r.endDelta) }), a && (l.range = { start: l.range.start, end: ti(t.allDay, l.range.start, i) }), t.allDay && (l.range = { start: jt(l.range.start), end: jt(l.range.end) }), l.range.end < l.range.start && (l.range.end = ti(t.allDay, l.range.start, i)), l } class oi { constructor(e, t) { this.context = e, this.internalEventSource = t } remove() { this.context.dispatch({ type: "REMOVE_EVENT_SOURCE", sourceId: this.internalEventSource.sourceId }) } refetch() { this.context.dispatch({ type: "FETCH_EVENT_SOURCES", sourceIds: [this.internalEventSource.sourceId], isRefetch: !0 }) } get id() { return this.internalEventSource.publicId } get url() { return this.internalEventSource.meta.url } get format() { return this.internalEventSource.meta.format } } class si { constructor(e, t, n) { this._context = e, this._def = t, this._instance = n || null } setProp(e, t) { if (e in Vn) console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead."); else if ("id" === e) t = Fn[e](t), this.mutate({ standardProps: { publicId: t } }); else if (e in Fn) t = Fn[e](t), this.mutate({ standardProps: { [e]: t } }); else if (e in Ln) { let n = Ln[e](t); n = "color" === e ? { backgroundColor: t, borderColor: t } : "editable" === e ? { startEditable: t, durationEditable: t } : { [e]: t }, this.mutate({ standardProps: { ui: n } }) } else console.warn(`Could not set prop '${e}'. Use setExtendedProp instead.`) } setExtendedProp(e, t) { this.mutate({ extendedProps: { [e]: t } }) } setStart(e, t = {}) { let { dateEnv: n } = this._context, r = n.createMarker(e); if (r && this._instance) { let e = tr(this._instance.range.start, r, n, t.granularity); t.maintainDuration ? this.mutate({ datesDelta: e }) : this.mutate({ startDelta: e }) } } setEnd(e, t = {}) { let n, { dateEnv: r } = this._context; if ((null == e || (n = r.createMarker(e), n)) && this._instance) if (n) { let e = tr(this._instance.range.end, n, r, t.granularity); this.mutate({ endDelta: e }) } else this.mutate({ standardProps: { hasEnd: !1 } }) } setDates(e, t, n = {}) { let r, { dateEnv: i } = this._context, o = { allDay: n.allDay }, s = i.createMarker(e); var a, l; if (s && (null == t || (r = i.createMarker(t), r)) && this._instance) { let e = this._instance.range; !0 === n.allDay && (e = Jn(e)); let t = tr(e.start, s, i, n.granularity); if (r) { let s = tr(e.end, r, i, n.granularity); l = s, (a = t).years === l.years && a.months === l.months && a.days === l.days && a.milliseconds === l.milliseconds ? this.mutate({ datesDelta: t, standardProps: o }) : this.mutate({ startDelta: t, endDelta: s, standardProps: o }) } else o.hasEnd = !1, this.mutate({ datesDelta: t, standardProps: o }) } } moveStart(e) { let t = ut(e); t && this.mutate({ startDelta: t }) } moveEnd(e) { let t = ut(e); t && this.mutate({ endDelta: t }) } moveDates(e) { let t = ut(e); t && this.mutate({ datesDelta: t }) } setAllDay(e, t = {}) { let n = { allDay: e }, { maintainDuration: r } = t; null == r && (r = this._context.options.allDayMaintainDuration), this._def.allDay !== e && (n.hasEnd = r), this.mutate({ standardProps: n }) } formatRange(e) { let { dateEnv: t } = this._context, n = this._instance, r = vn(e); return this._def.hasEnd ? t.formatRange(n.range.start, n.range.end, r, { forcedStartTzo: n.forcedStartTzo, forcedEndTzo: n.forcedEndTzo }) : t.format(n.range.start, r, { forcedTzo: n.forcedStartTzo }) } mutate(e) { let t = this._instance; if (t) { let n = this._def, r = this._context, { eventStore: i } = r.getCurrentData(), o = Nn(i, t.instanceId); o = ni(o, { "": { display: "", startEditable: !0, durationEditable: !0, constraints: [], overlap: null, allows: [], backgroundColor: "", borderColor: "", textColor: "", classNames: [] } }, e, r); let s = new si(r, n, t); this._def = o.defs[n.defId], this._instance = o.instances[t.instanceId], r.dispatch({ type: "MERGE_EVENTS", eventStore: o }), r.emitter.trigger("eventChange", { oldEvent: s, event: this, relatedEvents: li(o, r, t), revert() { r.dispatch({ type: "RESET_EVENTS", eventStore: i }) } }) } } remove() { let e = this._context, t = ai(this); e.dispatch({ type: "REMOVE_EVENTS", eventStore: t }), e.emitter.trigger("eventRemove", { event: this, relatedEvents: [], revert() { e.dispatch({ type: "MERGE_EVENTS", eventStore: t }) } }) } get source() { let { sourceId: e } = this._def; return e ? new oi(this._context, this._context.getCurrentData().eventSources[e]) : null } get start() { return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null } get end() { return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null } get startStr() { let e = this._instance; return e ? this._context.dateEnv.formatIso(e.range.start, { omitTime: this._def.allDay, forcedTzo: e.forcedStartTzo }) : "" } get endStr() { let e = this._instance; return e && this._def.hasEnd ? this._context.dateEnv.formatIso(e.range.end, { omitTime: this._def.allDay, forcedTzo: e.forcedEndTzo }) : "" } get id() { return this._def.publicId } get groupId() { return this._def.groupId } get allDay() { return this._def.allDay } get title() { return this._def.title } get url() { return this._def.url } get display() { return this._def.ui.display || "auto" } get startEditable() { return this._def.ui.startEditable } get durationEditable() { return this._def.ui.durationEditable } get constraint() { return this._def.ui.constraints[0] || null } get overlap() { return this._def.ui.overlap } get allow() { return this._def.ui.allows[0] || null } get backgroundColor() { return this._def.ui.backgroundColor } get borderColor() { return this._def.ui.borderColor } get textColor() { return this._def.ui.textColor } get classNames() { return this._def.ui.classNames } get extendedProps() { return this._def.extendedProps } toPlainObject(e = {}) { let t = this._def, { ui: n } = t, { startStr: r, endStr: i } = this, o = { allDay: t.allDay }; return t.title && (o.title = t.title), r && (o.start = r), i && (o.end = i), t.publicId && (o.id = t.publicId), t.groupId && (o.groupId = t.groupId), t.url && (o.url = t.url), n.display && "auto" !== n.display && (o.display = n.display), e.collapseColor && n.backgroundColor && n.backgroundColor === n.borderColor ? o.color = n.backgroundColor : (n.backgroundColor && (o.backgroundColor = n.backgroundColor), n.borderColor && (o.borderColor = n.borderColor)), n.textColor && (o.textColor = n.textColor), n.classNames.length && (o.classNames = n.classNames), Object.keys(t.extendedProps).length && (e.collapseExtendedProps ? Object.assign(o, t.extendedProps) : o.extendedProps = t.extendedProps), o } toJSON() { return this.toPlainObject() } } function ai(e) { let t = e._def, n = e._instance; return { defs: { [t.defId]: t }, instances: n ? { [n.instanceId]: n } : {} } } function li(e, t, n) { let { defs: r, instances: i } = e, o = [], s = n ? n.instanceId : ""; for (let e in i) { let n = i[e], a = r[n.defId]; n.instanceId !== s && o.push(new si(t, a, n)) } return o } function di(e, t, n, r) { let i = {}, o = {}, s = {}, a = [], l = [], d = fi(e.defs, t); for (let t in e.defs) { let n = e.defs[t]; "inverse-background" === d[n.defId].display && (n.groupId ? (i[n.groupId] = [], s[n.groupId] || (s[n.groupId] = n)) : o[t] = []) } for (let t in e.instances) { let s = e.instances[t], c = e.defs[s.defId], u = d[c.defId], h = s.range, f = !c.allDay && r ? Kn(h, r) : h, g = gr(f, n); g && ("inverse-background" === u.display ? c.groupId ? i[c.groupId].push(g) : o[s.defId].push(g) : "none" !== u.display && ("background" === u.display ? a : l).push({ def: c, ui: u, instance: s, range: g, isStart: f.start && f.start.valueOf() === g.start.valueOf(), isEnd: f.end && f.end.valueOf() === g.end.valueOf() })) } for (let e in i) { let t = hr(i[e], n); for (let n of t) { let t = s[e], r = d[t.defId]; a.push({ def: t, ui: r, instance: null, range: n, isStart: !1, isEnd: !1 }) } } for (let t in o) { let r = hr(o[t], n); for (let n of r) a.push({ def: e.defs[t], ui: d[t], instance: null, range: n, isStart: !1, isEnd: !1 }) } return { bg: a, fg: l } } function ci(e) { return "background" === e.ui.display || "inverse-background" === e.ui.display } function ui(e, t) { e.fcSeg = t } function hi(e) { return e.fcSeg || e.parentNode.fcSeg || null } function fi(e, t) { return Ct(e, (e => gi(e, t))) } function gi(e, t) { let n = []; return t[""] && n.push(t[""]), t[e.defId] && n.push(t[e.defId]), n.push(e.ui), jn(n) } function pi(e, t) { let n = e.map(mi); return n.sort(((e, n) => tt(e, n, t))), n.map((e => e._seg)) } function mi(e) { let { eventRange: t } = e, n = t.def, r = t.instance ? t.instance.range : t.range, i = r.start ? r.start.valueOf() : 0, o = r.end ? r.end.valueOf() : 0; return Object.assign(Object.assign(Object.assign({}, n.extendedProps), n), { id: n.publicId, start: i, end: o, duration: o - i, allDay: Number(n.allDay), _seg: e }) } function vi(e, t) { let { pluginHooks: n } = t, r = n.isDraggableTransformers, { def: i, ui: o } = e.eventRange, s = o.startEditable; for (let e of r) s = e(s, i, o, t); return s } function yi(e, t) { return e.isStart && e.eventRange.ui.durationEditable && t.options.eventResizableFromStart } function bi(e, t) { return e.isEnd && e.eventRange.ui.durationEditable } function Ei(e, t, n, r, i, o, s) { let { dateEnv: a, options: l } = n, { displayEventTime: d, displayEventEnd: c } = l, u = e.eventRange.def, h = e.eventRange.instance; null == d && (d = !1 !== r), null == c && (c = !1 !== i); let f = h.range.start, g = h.range.end, p = o || e.start || e.eventRange.range.start, m = s || e.end || e.eventRange.range.end, v = jt(f).valueOf() === jt(p).valueOf(), y = jt(Ht(g, -1)).valueOf() === jt(Ht(m, -1)).valueOf(); return d && !u.allDay && (v || y) ? (p = v ? f : p, m = y ? g : m, c && u.hasEnd ? a.formatRange(p, m, t, { forcedStartTzo: o ? null : h.forcedStartTzo, forcedEndTzo: s ? null : h.forcedEndTzo }) : a.format(p, t, { forcedTzo: o ? null : h.forcedStartTzo })) : "" } function Si(e, t, n) { let r = e.eventRange.range; return { isPast: r.end < (n || t.start), isFuture: r.start >= (n || t.end), isToday: t && yr(t, r.start) } } function Ci(e) { let t = ["fc-event"]; return e.isMirror && t.push("fc-event-mirror"), e.isDraggable && t.push("fc-event-draggable"), (e.isStartResizable || e.isEndResizable) && t.push("fc-event-resizable"), e.isDragging && t.push("fc-event-dragging"), e.isResizing && t.push("fc-event-resizing"), e.isSelected && t.push("fc-event-selected"), e.isStart && t.push("fc-event-start"), e.isEnd && t.push("fc-event-end"), e.isPast && t.push("fc-event-past"), e.isToday && t.push("fc-event-today"), e.isFuture && t.push("fc-event-future"), t } function wi(e) { return e.instance ? e.instance.instanceId : `${e.def.defId}:${e.range.start.toISOString()}` } function Ai(e, t) { let { def: n, instance: r } = e.eventRange, { url: i } = n; if (i) return { href: i }; let { emitter: o, options: s } = t, { eventInteractive: a } = s; return null == a && (a = n.interactive, null == a && (a = Boolean(o.hasHandlers("eventClick")))), a ? Ge((e => { o.trigger("eventClick", { el: e.target, event: new si(t, n, r), jsEvent: e, view: t.viewApi }) })) : {} } const Di = { start: Tn, end: Tn, allDay: Boolean }; function Ri(e, t) { return pr(e.range, t.range) && e.allDay === t.allDay && function (e, t) { for (let n in t) if ("range" !== n && "allDay" !== n && e[n] !== t[n]) return !1; for (let n in e) if (!(n in t)) return !1; return !0 }(e, t) } function xi(e, t, n) { return Object.assign(Object.assign({}, Ti(e, t, n)), { timeZone: t.timeZone }) } function Ti(e, t, n) { return { start: t.toDate(e.start), end: t.toDate(e.end), startStr: t.formatIso(e.start, { omitTime: n }), endStr: t.formatIso(e.end, { omitTime: n }) } } let ki = {}; var _i; _i = class { getMarkerYear(e) { return e.getUTCFullYear() } getMarkerMonth(e) { return e.getUTCMonth() } getMarkerDay(e) { return e.getUTCDate() } arrayToMarker(e) { return Yt(e) } markerToArray(e) { return qt(e) } }, ki.gregory = _i; const Mi = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/; function Ii(e) { let t = Mi.exec(e); if (t) { let e = new Date(Date.UTC(Number(t[1]), t[3] ? Number(t[3]) - 1 : 0, Number(t[5] || 1), Number(t[7] || 0), Number(t[8] || 0), Number(t[10] || 0), t[12] ? 1e3 * Number("0." + t[12]) : 0)); if (Qt(e)) { let n = null; return t[13] && (n = ("-" === t[15] ? -1 : 1) * (60 * Number(t[16] || 0) + Number(t[18] || 0))), { marker: e, isTimeUnspecified: !t[6], timeZoneOffset: n } } } return null } class Oi { constructor(e) { let t = this.timeZone = e.timeZone, n = "local" !== t && "UTC" !== t; e.namedTimeZoneImpl && n && (this.namedTimeZoneImpl = new e.namedTimeZoneImpl(t)), this.canComputeOffset = Boolean(!n || this.namedTimeZoneImpl), this.calendarSystem = function (e) { return new ki[e] }(e.calendarSystem), this.locale = e.locale, this.weekDow = e.locale.week.dow, this.weekDoy = e.locale.week.doy, "ISO" === e.weekNumberCalculation && (this.weekDow = 1, this.weekDoy = 4), "number" == typeof e.firstDay && (this.weekDow = e.firstDay), "function" == typeof e.weekNumberCalculation && (this.weekNumberFunc = e.weekNumberCalculation), this.weekText = null != e.weekText ? e.weekText : e.locale.options.weekText, this.weekTextLong = (null != e.weekTextLong ? e.weekTextLong : e.locale.options.weekTextLong) || this.weekText, this.cmdFormatter = e.cmdFormatter, this.defaultSeparator = e.defaultSeparator } createMarker(e) { let t = this.createMarkerMeta(e); return null === t ? null : t.marker } createNowMarker() { return this.canComputeOffset ? this.timestampToMarker((new Date).valueOf()) : Yt(Vt(new Date)) } createMarkerMeta(e) { if ("string" == typeof e) return this.parse(e); let t = null; return "number" == typeof e ? t = this.timestampToMarker(e) : e instanceof Date ? (e = e.valueOf(), isNaN(e) || (t = this.timestampToMarker(e))) : Array.isArray(e) && (t = Yt(e)), null !== t && Qt(t) ? { marker: t, isTimeUnspecified: !1, forcedTzo: null } : null } parse(e) { let t = Ii(e); if (null === t) return null; let { marker: n } = t, r = null; return null !== t.timeZoneOffset && (this.canComputeOffset ? n = this.timestampToMarker(n.valueOf() - 60 * t.timeZoneOffset * 1e3) : r = t.timeZoneOffset), { marker: n, isTimeUnspecified: t.isTimeUnspecified, forcedTzo: r } } getYear(e) { return this.calendarSystem.getMarkerYear(e) } getMonth(e) { return this.calendarSystem.getMarkerMonth(e) } getDay(e) { return this.calendarSystem.getMarkerDay(e) } add(e, t) { let n = this.calendarSystem.markerToArray(e); return n[0] += t.years, n[1] += t.months, n[2] += t.days, n[6] += t.milliseconds, this.calendarSystem.arrayToMarker(n) } subtract(e, t) { let n = this.calendarSystem.markerToArray(e); return n[0] -= t.years, n[1] -= t.months, n[2] -= t.days, n[6] -= t.milliseconds, this.calendarSystem.arrayToMarker(n) } addYears(e, t) { let n = this.calendarSystem.markerToArray(e); return n[0] += t, this.calendarSystem.arrayToMarker(n) } addMonths(e, t) { let n = this.calendarSystem.markerToArray(e); return n[1] += t, this.calendarSystem.arrayToMarker(n) } diffWholeYears(e, t) { let { calendarSystem: n } = this; return Zt(e) === Zt(t) && n.getMarkerDay(e) === n.getMarkerDay(t) && n.getMarkerMonth(e) === n.getMarkerMonth(t) ? n.getMarkerYear(t) - n.getMarkerYear(e) : null } diffWholeMonths(e, t) { let { calendarSystem: n } = this; return Zt(e) === Zt(t) && n.getMarkerDay(e) === n.getMarkerDay(t) ? n.getMarkerMonth(t) - n.getMarkerMonth(e) + 12 * (n.getMarkerYear(t) - n.getMarkerYear(e)) : null } greatestWholeUnit(e, t) { let n = this.diffWholeYears(e, t); return null !== n ? { unit: "year", value: n } : (n = this.diffWholeMonths(e, t), null !== n ? { unit: "month", value: n } : (n = Wt(e, t), null !== n ? { unit: "week", value: n } : (n = zt(e, t), null !== n ? { unit: "day", value: n } : (n = function (e, t) { return (t.valueOf() - e.valueOf()) / 36e5 }(e, t), at(n) ? { unit: "hour", value: n } : (n = function (e, t) { return (t.valueOf() - e.valueOf()) / 6e4 }(e, t), at(n) ? { unit: "minute", value: n } : (n = function (e, t) { return (t.valueOf() - e.valueOf()) / 1e3 }(e, t), at(n) ? { unit: "second", value: n } : { unit: "millisecond", value: t.valueOf() - e.valueOf() })))))) } countDurationsBetween(e, t, n) { let r; return n.years && (r = this.diffWholeYears(e, t), null !== r) ? r / (pt(n) / 365) : n.months && (r = this.diffWholeMonths(e, t), null !== r) ? r / function (e) { return pt(e) / 30 }(n) : n.days && (r = zt(e, t), null !== r) ? r / pt(n) : (t.valueOf() - e.valueOf()) / mt(n) } startOf(e, t) { return "year" === t ? this.startOfYear(e) : "month" === t ? this.startOfMonth(e) : "week" === t ? this.startOfWeek(e) : "day" === t ? jt(e) : "hour" === t ? function (e) { return Yt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours()]) }(e) : "minute" === t ? function (e) { return Yt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes()]) }(e) : "second" === t ? function (e) { return Yt([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds()]) }(e) : null } startOfYear(e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e)]) } startOfMonth(e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e)]) } startOfWeek(e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e), e.getUTCDate() - (e.getUTCDay() - this.weekDow + 7) % 7]) } computeWeekNumber(e) { return this.weekNumberFunc ? this.weekNumberFunc(this.toDate(e)) : function (e, t, n) { let r = e.getUTCFullYear(), i = Ut(e, r, t, n); if (i < 1) return Ut(e, r - 1, t, n); let o = Ut(e, r + 1, t, n); return o >= 1 ? Math.min(i, o) : i }(e, this.weekDow, this.weekDoy) } format(e, t, n = {}) { return t.format({ marker: e, timeZoneOffset: null != n.forcedTzo ? n.forcedTzo : this.offsetForMarker(e) }, this) } formatRange(e, t, n, r = {}) { return r.isEndExclusive && (t = Ht(t, -1)), n.formatRange({ marker: e, timeZoneOffset: null != r.forcedStartTzo ? r.forcedStartTzo : this.offsetForMarker(e) }, { marker: t, timeZoneOffset: null != r.forcedEndTzo ? r.forcedEndTzo : this.offsetForMarker(t) }, this, r.defaultSeparator) } formatIso(e, t = {}) { let n = null; return t.omitTimeZoneOffset || (n = null != t.forcedTzo ? t.forcedTzo : this.offsetForMarker(e)), Xt(e, n, t.omitTime) } timestampToMarker(e) { return "local" === this.timeZone ? Yt(Vt(new Date(e))) : "UTC" !== this.timeZone && this.namedTimeZoneImpl ? Yt(this.namedTimeZoneImpl.timestampToArray(e)) : new Date(e) } offsetForMarker(e) { return "local" === this.timeZone ? -Gt(qt(e)).getTimezoneOffset() : "UTC" === this.timeZone ? 0 : this.namedTimeZoneImpl ? this.namedTimeZoneImpl.offsetForArray(qt(e)) : null } toDate(e, t) { return "local" === this.timeZone ? Gt(qt(e)) : "UTC" === this.timeZone ? new Date(e.valueOf()) : this.namedTimeZoneImpl ? new Date(e.valueOf() - 1e3 * this.namedTimeZoneImpl.offsetForArray(qt(e)) * 60) : new Date(e.valueOf() - (t || 0)) } } class Ni { constructor() { this.strictOrder = !1, this.allowReslicing = !1, this.maxCoord = -1, this.maxStackCnt = -1, this.levelCoords = [], this.entriesByLevel = [], this.stackCnts = {} } addSegs(e) { let t = []; for (let n of e) this.insertEntry(n, t); return t } insertEntry(e, t) { let n = this.findInsertion(e); return this.isInsertionValid(n, e) ? (this.insertEntryAt(e, n), 1) : this.handleInvalidInsertion(n, e, t) } isInsertionValid(e, t) { return (-1 === this.maxCoord || e.levelCoord + t.thickness <= this.maxCoord) && (-1 === this.maxStackCnt || e.stackCnt < this.maxStackCnt) } handleInvalidInsertion(e, t, n) { return this.allowReslicing && e.touchingEntry ? this.splitEntry(t, e.touchingEntry, n) : (n.push(t), 0) } splitEntry(e, t, n) { let r = 0, i = [], o = e.span, s = t.span; return o.start < s.start && (r += this.insertEntry({ index: e.index, thickness: e.thickness, span: { start: o.start, end: s.start } }, i)), o.end > s.end && (r += this.insertEntry({ index: e.index, thickness: e.thickness, span: { start: s.end, end: o.end } }, i)), r ? (n.push({ index: e.index, thickness: e.thickness, span: Li(s, o) }, ...i), r) : (n.push(e), 0) } insertEntryAt(e, t) { let { entriesByLevel: n, levelCoords: r } = this; -1 === t.lateral ? (Wi(r, t.level, t.levelCoord), Wi(n, t.level, [e])) : Wi(n[t.level], t.lateral, e), this.stackCnts[Pi(e)] = t.stackCnt } findInsertion(e) { let { levelCoords: t, entriesByLevel: n, strictOrder: r, stackCnts: i } = this, o = t.length, s = 0, a = -1, l = -1, d = null, c = 0; for (let u = 0; u < o; u += 1) { let o = t[u]; if (!r && o >= s + e.thickness) break; let h, f = n[u], g = zi(f, e.span.start, Hi), p = g[0] + g[1]; for (; (h = f[p]) && h.span.start < e.span.end;) { let e = o + h.thickness; e > s && (s = e, d = h, a = u, l = p), e === s && (c = Math.max(c, i[Pi(h)] + 1)), p += 1 } } let u = 0; if (d) for (u = a + 1; u < o && t[u] < s;)u += 1; let h = -1; return u < o && t[u] === s && (h = zi(n[u], e.span.end, Hi)[0]), { touchingLevel: a, touchingLateral: l, touchingEntry: d, stackCnt: c, levelCoord: s, level: u, lateral: h } } toRects() { let { entriesByLevel: e, levelCoords: t } = this, n = e.length, r = []; for (let i = 0; i < n; i += 1) { let n = e[i], o = t[i]; for (let e of n) r.push(Object.assign(Object.assign({}, e), { levelCoord: o })) } return r } } function Hi(e) { return e.span.end } function Pi(e) { return e.index + ":" + e.span.start } function Bi(e) { let t = []; for (let i of e) { let e = [], o = { span: i.span, entries: [i] }; for (let i of t) Li(i.span, o.span) ? o = { entries: i.entries.concat(o.entries), span: (n = i.span, r = o.span, { start: Math.min(n.start, r.start), end: Math.max(n.end, r.end) }) } : e.push(i); e.push(o), t = e } var n, r; return t } function Li(e, t) { let n = Math.max(e.start, t.start), r = Math.min(e.end, t.end); return n < r ? { start: n, end: r } : null } function Wi(e, t, n) { e.splice(t, 0, n) } function zi(e, t, n) { let r = 0, i = e.length; if (!i || t < n(e[r])) return [0, 0]; if (t > n(e[i - 1])) return [i, 0]; for (; r < i;) { let o = Math.floor(r + (i - r) / 2), s = n(e[o]); if (t < s) i = o; else { if (!(t > s)) return [o, 1]; r = o + 1 } } return [r, 0] } class ji { constructor(e) { this.component = e.component, this.isHitComboAllowed = e.isHitComboAllowed || null } destroy() { } } function Ui(e) { return { [e.component.uid]: e } } const Fi = {}; class Vi { constructor(e, t) { this.emitter = new Nr } destroy() { } setMirrorIsVisible(e) { } setMirrorNeedsRevert(e) { } setAutoScrollEnabled(e) { } } const Gi = {}, qi = { startTime: ut, duration: ut, create: Boolean, sourceId: String }; function Yi(e) { let { refined: t, extra: n } = xn(e, qi); return { startTime: t.startTime || null, duration: t.duration || null, create: null == t.create || t.create, sourceId: t.sourceId, leftoverProps: n } } class Qi extends Qr { constructor() { super(...arguments), this.state = { forPrint: !1 }, this.handleBeforePrint = () => { this.setState({ forPrint: !0 }) }, this.handleAfterPrint = () => { this.setState({ forPrint: !1 }) } } render() { let { props: e } = this, { options: t } = e, { forPrint: n } = this.state, r = n || "auto" === t.height || "auto" === t.contentHeight, i = r || null == t.height ? "" : t.height, o = ["fc", n ? "fc-media-print" : "fc-media-screen", "fc-direction-" + t.direction, e.theme.getClass("root")]; return lr() || o.push("fc-liquid-hack"), e.children(o, i, r, n) } componentDidMount() { let { emitter: e } = this.props; e.on("_beforeprint", this.handleBeforePrint), e.on("_afterprint", this.handleAfterPrint) } componentWillUnmount() { let { emitter: e } = this.props; e.off("_beforeprint", this.handleBeforePrint), e.off("_afterprint", this.handleAfterPrint) } } function Zi(e, t) { return vn(!e || t > 10 ? { weekday: "short" } : t > 1 ? { weekday: "short", month: "numeric", day: "numeric", omitCommas: !0 } : { weekday: "long" }) } const Xi = "fc-col-header-cell"; function $i(e) { return e.text } class Ji extends Qr { constructor() { super(...arguments), this.id = Ye(), this.queuedDomNodes = [], this.currentDomNodes = [], this.handleEl = e => { this.props.elRef && Zr(this.props.elRef, e) } } render() { const { props: e, context: t } = this, { options: n } = t, { customGenerator: r, defaultGenerator: i, renderProps: o } = e, s = eo(e); let a, l, d = !1, c = []; if (null != r) { const e = "function" == typeof r ? r(o, p) : r; if (!0 === e) d = !0; else { const t = e && "object" == typeof e; t && "html" in e ? s.dangerouslySetInnerHTML = { __html: e.html } : t && "domNodes" in e ? c = Array.prototype.slice.call(e.domNodes) : t || "function" == typeof e ? l = e : a = e } } else d = !Ki(e.generatorName, n); return d && i && (a = i(o)), this.queuedDomNodes = c, this.currentGeneratorMeta = l, p(e.elTag, s, a) } componentDidMount() { this.applyQueueudDomNodes(), this.triggerCustomRendering(!0) } componentDidUpdate() { this.applyQueueudDomNodes(), this.triggerCustomRendering(!0) } componentWillUnmount() { this.triggerCustomRendering(!1) } triggerCustomRendering(e) { var t; const { props: n, context: r } = this, { handleCustomRendering: i, customRenderingMetaMap: o } = r.options; if (i) { const r = null !== (t = this.currentGeneratorMeta) && void 0 !== t ? t : null == o ? void 0 : o[n.generatorName]; r && i(Object.assign(Object.assign({ id: this.id, isActive: e, containerEl: this.base, reportNewContainerEl: this.handleEl, generatorMeta: r }, n), { elClasses: (n.elClasses || []).filter(to) })) } } applyQueueudDomNodes() { const { queuedDomNodes: e, currentDomNodes: t } = this, n = this.base; if (!Mt(e, t)) { t.forEach(_e); for (let t of e) n.appendChild(t); this.currentDomNodes = e } } } function Ki(e, t) { var n; return Boolean(t.handleCustomRendering && e && (null === (n = t.customRenderingMetaMap) || void 0 === n ? void 0 : n[e])) } function eo(e, t) { const n = Object.assign(Object.assign({}, e.elAttrs), { ref: e.elRef }); return (e.elClasses || t) && (n.className = (e.elClasses || []).concat(t || []).concat(n.className || []).filter(Boolean).join(" ")), e.elStyle && (n.style = e.elStyle), n } function to(e) { return Boolean(e) } Ji.addPropsEquality({ elClasses: Mt, elStyle: Dt, elAttrs: function (e, t) { const n = xt(e, t); for (let e of n) if (!Rt.test(e)) return !1; return !0 }, renderProps: Dt }); const no = Fr(0); class ro extends C { constructor() { super(...arguments), this.InnerContent = io.bind(void 0, this), this.handleRootEl = e => { this.rootEl = e, this.props.elRef && Zr(this.props.elRef, e) } } render() { const { props: e } = this, t = function (e, t) { const n = "function" == typeof e ? e(t) : e || []; return "string" == typeof n ? [n] : n }(e.classNameGenerator, e.renderProps); if (e.children) { const n = eo(e, t), r = e.children(this.InnerContent, e.renderProps, n); return e.elTag ? p(e.elTag, n, r) : r } return p(Ji, Object.assign(Object.assign({}, e), { elRef: this.handleRootEl, elTag: e.elTag || "div", elClasses: (e.elClasses || []).concat(t), renderId: this.context })) } componentDidMount() { var e, t; null === (t = (e = this.props).didMount) || void 0 === t || t.call(e, Object.assign(Object.assign({}, this.props.renderProps), { el: this.rootEl || this.base })) } componentWillUnmount() { var e, t; null === (t = (e = this.props).willUnmount) || void 0 === t || t.call(e, Object.assign(Object.assign({}, this.props.renderProps), { el: this.rootEl || this.base })) } } function io(e, t) { const n = e.props; return p(Ji, Object.assign({ renderProps: n.renderProps, generatorName: n.generatorName, customGenerator: n.customGenerator, defaultGenerator: n.defaultGenerator, renderId: e.context }, t)) } ro.contextType = no; class oo extends Qr { render() { let { dateEnv: e, options: t, theme: n, viewApi: r } = this.context, { props: i } = this, { date: o, dateProfile: s } = i, a = br(o, i.todayRange, null, s), l = [Xi].concat(Er(a, n)), d = e.format(o, i.dayHeaderFormat), c = !a.isDisabled && i.colCnt > 1 ? wr(this.context, o) : {}, u = Object.assign(Object.assign(Object.assign({ date: e.toDate(o), view: r }, i.extraRenderProps), { text: d }), a); return p(ro, { elTag: "th", elClasses: l, elAttrs: Object.assign({ role: "columnheader", colSpan: i.colSpan, "data-date": a.isDisabled ? void 0 : $t(o) }, i.extraDataAttrs), renderProps: u, generatorName: "dayHeaderContent", customGenerator: t.dayHeaderContent, defaultGenerator: $i, classNameGenerator: t.dayHeaderClassNames, didMount: t.dayHeaderDidMount, willUnmount: t.dayHeaderWillUnmount }, (e => p("div", { className: "fc-scrollgrid-sync-inner" }, !a.isDisabled && p(e, { elTag: "a", elAttrs: c, elClasses: ["fc-col-header-cell-cushion", i.isSticky && "fc-sticky"] })))) } } const so = vn({ weekday: "long" }); class ao extends Qr { render() { let { props: e } = this, { dateEnv: t, theme: n, viewApi: r, options: i } = this.context, o = Nt(new Date(2592e5), e.dow), s = { dow: e.dow, isDisabled: !1, isFuture: !1, isPast: !1, isToday: !1, isOther: !1 }, a = t.format(o, e.dayHeaderFormat), l = Object.assign(Object.assign(Object.assign(Object.assign({ date: o }, s), { view: r }), e.extraRenderProps), { text: a }); return p(ro, { elTag: "th", elClasses: [Xi, ...Er(s, n), ...e.extraClassNames || []], elAttrs: Object.assign({ role: "columnheader", colSpan: e.colSpan }, e.extraDataAttrs), renderProps: l, generatorName: "dayHeaderContent", customGenerator: i.dayHeaderContent, defaultGenerator: $i, classNameGenerator: i.dayHeaderClassNames, didMount: i.dayHeaderDidMount, willUnmount: i.dayHeaderWillUnmount }, (n => p("div", { className: "fc-scrollgrid-sync-inner" }, p(n, { elTag: "a", elClasses: ["fc-col-header-cell-cushion", e.isSticky && "fc-sticky"], elAttrs: { "aria-label": t.format(o, so) } })))) } } class lo extends C { constructor(e, t) { super(e, t), this.initialNowDate = $r(t.options.now, t.dateEnv), this.initialNowQueriedMs = (new Date).valueOf(), this.state = this.computeTiming().currentState } render() { let { props: e, state: t } = this; return e.children(t.nowDate, t.todayRange) } componentDidMount() { this.setTimeout() } componentDidUpdate(e) { e.unit !== this.props.unit && (this.clearTimeout(), this.setTimeout()) } componentWillUnmount() { this.clearTimeout() } computeTiming() { let { props: e, context: t } = this, n = Ht(this.initialNowDate, (new Date).valueOf() - this.initialNowQueriedMs), r = t.dateEnv.startOf(n, e.unit), i = t.dateEnv.add(r, ut(1, e.unit)), o = i.valueOf() - n.valueOf(); return o = Math.min(864e5, o), { currentState: { nowDate: r, todayRange: co(r) }, nextState: { nowDate: i, todayRange: co(i) }, waitMs: o } } setTimeout() { let { nextState: e, waitMs: t } = this.computeTiming(); this.timeoutId = setTimeout((() => { this.setState(e, (() => { this.setTimeout() })) }), t) } clearTimeout() { this.timeoutId && clearTimeout(this.timeoutId) } } function co(e) { let t = jt(e); return { start: t, end: Nt(t, 1) } } lo.contextType = Gr; class uo extends Qr { constructor() { super(...arguments), this.createDayHeaderFormatter = tn(ho) } render() { let { context: e } = this, { dates: t, dateProfile: n, datesRepDistinctDays: r, renderIntro: i } = this.props, o = this.createDayHeaderFormatter(e.options.dayHeaderFormat, r, t.length); return p(lo, { unit: "day" }, ((e, s) => p("tr", { role: "row" }, i && i("day"), t.map((e => r ? p(oo, { key: e.toISOString(), date: e, dateProfile: n, todayRange: s, colCnt: t.length, dayHeaderFormat: o }) : p(ao, { key: e.getUTCDay(), dow: e.getUTCDay(), dayHeaderFormat: o })))))) } } function ho(e, t, n) { return e || Zi(t, n) } class fo { constructor(e, t) { let n = e.start, { end: r } = e, i = [], o = [], s = -1; for (; n < r;)t.isHiddenDay(n) ? i.push(s + .5) : (s += 1, i.push(s), o.push(n)), n = Nt(n, 1); this.dates = o, this.indices = i, this.cnt = o.length } sliceRange(e) { let t = this.getDateDayIndex(e.start), n = this.getDateDayIndex(Nt(e.end, -1)), r = Math.max(0, t), i = Math.min(this.cnt - 1, n); return r = Math.ceil(r), i = Math.floor(i), r <= i ? { firstIndex: r, lastIndex: i, isStart: t === r, isEnd: n === i } : null } getDateDayIndex(e) { let { indices: t } = this, n = Math.floor(Bt(this.dates[0], e)); return n < 0 ? t[0] - 1 : n >= t.length ? t[t.length - 1] + 1 : t[n] } } class go { constructor(e, t) { let n, r, i, { dates: o } = e; if (t) { for (r = o[0].getUTCDay(), n = 1; n < o.length && o[n].getUTCDay() !== r; n += 1); i = Math.ceil(o.length / n) } else i = 1, n = o.length; this.rowCnt = i, this.colCnt = n, this.daySeries = e, this.cells = this.buildCells(), this.headerDates = this.buildHeaderDates() } buildCells() { let e = []; for (let t = 0; t < this.rowCnt; t += 1) { let n = []; for (let e = 0; e < this.colCnt; e += 1)n.push(this.buildCell(t, e)); e.push(n) } return e } buildCell(e, t) { let n = this.daySeries.dates[e * this.colCnt + t]; return { key: n.toISOString(), date: n } } buildHeaderDates() { let e = []; for (let t = 0; t < this.colCnt; t += 1)e.push(this.cells[0][t].date); return e } sliceRange(e) { let { colCnt: t } = this, n = this.daySeries.sliceRange(e), r = []; if (n) { let { firstIndex: e, lastIndex: i } = n, o = e; for (; o <= i;) { let s = Math.floor(o / t), a = Math.min((s + 1) * t, i + 1); r.push({ row: s, firstCol: o % t, lastCol: (a - 1) % t, isStart: n.isStart && o === e, isEnd: n.isEnd && a - 1 === i }), o = a } } return r } } class po { constructor() { this.sliceBusinessHours = tn(this._sliceBusinessHours), this.sliceDateSelection = tn(this._sliceDateSpan), this.sliceEventStore = tn(this._sliceEventStore), this.sliceEventDrag = tn(this._sliceInteraction), this.sliceEventResize = tn(this._sliceInteraction), this.forceDayIfListItem = !1 } sliceProps(e, t, n, r, ...i) { let { eventUiBases: o } = e, s = this.sliceEventStore(e.eventStore, o, t, n, ...i); return { dateSelectionSegs: this.sliceDateSelection(e.dateSelection, t, n, o, r, ...i), businessHourSegs: this.sliceBusinessHours(e.businessHours, t, n, r, ...i), fgEventSegs: s.fg, bgEventSegs: s.bg, eventDrag: this.sliceEventDrag(e.eventDrag, o, t, n, ...i), eventResize: this.sliceEventResize(e.eventResize, o, t, n, ...i), eventSelection: e.eventSelection } } sliceNowDate(e, t, n, r, ...i) { return this._sliceDateSpan({ range: { start: e, end: Ht(e, 1) }, allDay: !1 }, t, n, {}, r, ...i) } _sliceBusinessHours(e, t, n, r, ...i) { return e ? this._sliceEventStore(_n(e, mo(t, Boolean(n)), r), {}, t, n, ...i).bg : [] } _sliceEventStore(e, t, n, r, ...i) { if (e) { let o = di(e, t, mo(n, Boolean(r)), r); return { bg: this.sliceEventRanges(o.bg, i), fg: this.sliceEventRanges(o.fg, i) } } return { bg: [], fg: [] } } _sliceInteraction(e, t, n, r, ...i) { if (!e) return null; let o = di(e.mutatedEvents, t, mo(n, Boolean(r)), r); return { segs: this.sliceEventRanges(o.fg, i), affectedInstances: e.affectedEvents.instances, isEvent: e.isEvent } } _sliceDateSpan(e, t, n, r, i, ...o) { if (!e) return []; let s = mo(t, Boolean(n)), a = gr(e.range, s); if (a) { let t = function (e, t, n) { let r = Yn({ editable: !1 }, n), i = Zn(r.refined, r.extra, "", e.allDay, !0, n); return { def: i, ui: gi(i, t), instance: kn(i.defId, e.range), range: e.range, isStart: !0, isEnd: !0 } }(e = Object.assign(Object.assign({}, e), { range: a }), r, i), n = this.sliceRange(e.range, ...o); for (let e of n) e.eventRange = t; return n } return [] } sliceEventRanges(e, t) { let n = []; for (let r of e) n.push(...this.sliceEventRange(r, t)); return n } sliceEventRange(e, t) { let n = e.range; this.forceDayIfListItem && "list-item" === e.ui.display && (n = { start: n.start, end: Nt(n.start, 1) }); let r = this.sliceRange(n, ...t); for (let t of r) t.eventRange = e, t.isStart = e.isStart && t.isStart, t.isEnd = e.isEnd && t.isEnd; return r } } function mo(e, t) { let n = e.activeRange; return t ? n : { start: Ht(n.start, e.slotMinTime.milliseconds), end: Ht(n.end, e.slotMaxTime.milliseconds - 864e5) } } function vo(e, t, n) { let r = n.options.eventDataTransform, i = t ? t.eventDataTransform : null; return i && (e = yo(e, i)), r && (e = yo(e, r)), e } function yo(e, t) { let n; if (t) { n = []; for (let r of e) { let e = t(r); e ? n.push(e) : null == e && n.push(r) } } else n = e; return n } function bo(e, t, n) { let { defs: r } = e, i = Ct(e.instances, (e => r[e.defId].allDay ? e : Object.assign(Object.assign({}, e), { range: { start: n.createMarker(t.toDate(e.range.start, e.forcedStartTzo)), end: n.createMarker(t.toDate(e.range.end, e.forcedEndTzo)) }, forcedStartTzo: n.canComputeOffset ? null : e.forcedStartTzo, forcedEndTzo: n.canComputeOffset ? null : e.forcedEndTzo }))); return { defs: r, instances: i } } function Eo(e, t) { return Pn(e, (e => e.sourceId !== t)) } function So(e, t, n) { let { instances: r } = e.mutatedEvents; for (let e in r) if (!vr(t.validRange, r[e].range)) return !1; return wo({ eventDrag: e }, n) } function Co(e, t, n) { return !!vr(t.validRange, e.range) && wo({ dateSelection: e }, n) } function wo(e, t) { let n = t.getCurrentData(), r = Object.assign({ businessHours: n.businessHours, dateSelection: "", eventStore: n.eventStore, eventUiBases: n.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, e); return (t.pluginHooks.isPropsValid || Ao)(r, t) } function Ao(e, t, n = {}, r) { return !(e.eventDrag && !function (e, t, n, r) { let i = t.getCurrentData(), o = e.eventDrag, s = o.mutatedEvents, a = s.defs, l = s.instances, d = fi(a, o.isEvent ? e.eventUiBases : { "": i.selectionConfig }); r && (d = Ct(d, r)); let c = (g = e.eventStore, p = o.affectedEvents.instances, { defs: g.defs, instances: St(g.instances, (e => !p[e.instanceId])) }), u = c.defs, h = c.instances, f = fi(u, e.eventUiBases); var g, p; for (let r in l) { let s = l[r], g = s.range, p = d[s.defId], m = a[s.defId]; if (!Do(p.constraints, g, c, e.businessHours, t)) return !1; let { eventOverlap: v } = t.options, y = "function" == typeof v ? v : null; for (let e in h) { let n = h[e]; if (mr(g, n.range)) { if (!1 === f[n.defId].overlap && o.isEvent) return !1; if (!1 === p.overlap) return !1; if (y && !y(new si(t, u[n.defId], n), new si(t, m, s))) return !1 } } let b = i.eventStore; for (let e of p.allows) { let i, o = Object.assign(Object.assign({}, n), { range: s.range, allDay: m.allDay }), a = b.defs[m.defId], l = b.instances[r]; if (i = a ? new si(t, a, l) : new si(t, m), !e(ei(o, t), i)) return !1 } } return !0 }(e, t, n, r) || e.dateSelection && !function (e, t, n, r) { let i = e.eventStore, o = i.defs, s = i.instances, a = e.dateSelection, l = a.range, { selectionConfig: d } = t.getCurrentData(); if (r && (d = r(d)), !Do(d.constraints, l, i, e.businessHours, t)) return !1; let { selectOverlap: c } = t.options, u = "function" == typeof c ? c : null; for (let e in s) { let n = s[e]; if (mr(l, n.range)) { if (!1 === d.overlap) return !1; if (u && !u(new si(t, o[n.defId], n), null)) return !1 } } for (let e of d.allows) { if (!e(ei(Object.assign(Object.assign({}, n), a), t), null)) return !1 } return !0 }(e, t, n, r)) } function Do(e, t, n, r, i) { for (let o of e) if (!To(Ro(o, t, n, r, i), t)) return !1; return !0 } function Ro(e, t, n, r, i) { return "businessHours" === e ? xo(_n(r, t, i)) : "string" == typeof e ? xo(Pn(n, (t => t.groupId === e))) : "object" == typeof e && e ? xo(_n(e, t, i)) : [] } function xo(e) { let { instances: t } = e, n = []; for (let e in t) n.push(t[e].range); return n } function To(e, t) { for (let n of e) if (vr(n, t)) return !0; return !1 } class ko extends Error { constructor(e, t) { super(e), this.response = t } } function _o(e, t, n) { const r = { method: e = e.toUpperCase() }; return "GET" === e ? t += (-1 === t.indexOf("?") ? "?" : "&") + new URLSearchParams(n) : (r.body = new URLSearchParams(n), r.headers = { "Content-Type": "application/x-www-form-urlencoded" }), fetch(t, r).then((e => { if (e.ok) return e.json().then((t => [t, e]), (() => { throw new ko("Failure parsing JSON", e) })); throw new ko("Request failed", e) })) } class Mo { constructor(e) { this.drainedOption = e, this.isRunning = !1, this.isDirty = !1, this.pauseDepths = {}, this.timeoutId = 0 } request(e) { this.isDirty = !0, this.isPaused() || (this.clearTimeout(), null == e ? this.tryDrain() : this.timeoutId = setTimeout(this.tryDrain.bind(this), e)) } pause(e = "") { let { pauseDepths: t } = this; t[e] = (t[e] || 0) + 1, this.clearTimeout() } resume(e = "", t) { let { pauseDepths: n } = this; e in n && (t ? delete n[e] : (n[e] -= 1, n[e] <= 0 && delete n[e]), this.tryDrain()) } isPaused() { return Object.keys(this.pauseDepths).length } tryDrain() { if (!this.isRunning && !this.isPaused()) { for (this.isRunning = !0; this.isDirty;)this.isDirty = !1, this.drained(); this.isRunning = !1 } } clear() { this.clearTimeout(), this.isDirty = !1, this.pauseDepths = {} } clearTimeout() { this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = 0) } drained() { this.drainedOption && this.drainedOption() } } const Io = /^(visible|hidden)$/; class Oo extends Qr { constructor() { super(...arguments), this.handleEl = e => { this.el = e, Zr(this.props.elRef, e) } } render() { let { props: e } = this, { liquid: t, liquidIsAbsolute: n } = e, r = t && n, i = ["fc-scroller"]; return t && (n ? i.push("fc-scroller-liquid-absolute") : i.push("fc-scroller-liquid")), p("div", { ref: this.handleEl, className: i.join(" "), style: { overflowX: e.overflowX, overflowY: e.overflowY, left: r && -(e.overcomeLeft || 0) || "", right: r && -(e.overcomeRight || 0) || "", bottom: r && -(e.overcomeBottom || 0) || "", marginLeft: !r && -(e.overcomeLeft || 0) || "", marginRight: !r && -(e.overcomeRight || 0) || "", marginBottom: !r && -(e.overcomeBottom || 0) || "", maxHeight: e.maxHeight || "" } }, e.children) } needsXScrolling() { if (Io.test(this.props.overflowX)) return !1; let { el: e } = this, t = this.el.getBoundingClientRect().width - this.getYScrollbarWidth(), { children: n } = e; for (let e = 0; e < n.length; e += 1)if (n[e].getBoundingClientRect().width > t) return !0; return !1 } needsYScrolling() { if (Io.test(this.props.overflowY)) return !1; let { el: e } = this, t = this.el.getBoundingClientRect().height - this.getXScrollbarWidth(), { children: n } = e; for (let e = 0; e < n.length; e += 1)if (n[e].getBoundingClientRect().height > t) return !0; return !1 } getXScrollbarWidth() { return Io.test(this.props.overflowX) ? 0 : this.el.offsetHeight - this.el.clientHeight } getYScrollbarWidth() { return Io.test(this.props.overflowY) ? 0 : this.el.offsetWidth - this.el.clientWidth } } class No { constructor(e) { this.masterCallback = e, this.currentMap = {}, this.depths = {}, this.callbackMap = {}, this.handleValue = (e, t) => { let { depths: n, currentMap: r } = this, i = !1, o = !1; null !== e ? (i = t in r, r[t] = e, n[t] = (n[t] || 0) + 1, o = !0) : (n[t] -= 1, n[t] || (delete r[t], delete this.callbackMap[t], i = !0)), this.masterCallback && (i && this.masterCallback(null, String(t)), o && this.masterCallback(e, String(t))) } } createRef(e) { let t = this.callbackMap[e]; return t || (t = this.callbackMap[e] = t => { this.handleValue(t, String(e)) }), t } collect(e, t, n) { return _t(this.currentMap, e, t, n) } getAll() { return At(this.currentMap) } } function Ho(e) { let t = Oe(e, ".fc-scrollgrid-shrink"), n = 0; for (let e of t) n = Math.max(n, lt(e)); return Math.ceil(n) } function Po(e, t) { return e.liquid && t.liquid } function Bo(e, t) { return null != t.maxHeight || Po(e, t) } function Lo(e, t, n, r) { let { expandRows: i } = n; return "function" == typeof t.content ? t.content(n) : p("table", { role: "presentation", className: [t.tableClassName, e.syncRowHeights ? "fc-scrollgrid-sync-table" : ""].join(" "), style: { minWidth: n.tableMinWidth, width: n.clientWidth, height: i ? n.clientHeight : "" } }, n.tableColGroupNode, p(r ? "thead" : "tbody", { role: "presentation" }, "function" == typeof t.rowContent ? t.rowContent(n) : t.rowContent)) } function Wo(e, t) { return Mt(e, t, Dt) } function zo(e, t) { let n = []; for (let r of e) { let e = r.span || 1; for (let i = 0; i < e; i += 1)n.push(p("col", { style: { width: "shrink" === r.width ? jo(t) : r.width || "", minWidth: r.minWidth || "" } })) } return p("colgroup", {}, ...n) } function jo(e) { return null == e ? 4 : e } function Uo(e) { for (let t of e) if ("shrink" === t.width) return !0; return !1 } function Fo(e, t) { let n = ["fc-scrollgrid", t.theme.getClass("table")]; return e && n.push("fc-scrollgrid-liquid"), n } function Vo(e, t) { let n = ["fc-scrollgrid-section", "fc-scrollgrid-section-" + e.type, e.className]; return t && e.liquid && null == e.maxHeight && n.push("fc-scrollgrid-section-liquid"), e.isSticky && n.push("fc-scrollgrid-section-sticky"), n } function Go(e) { return p("div", { className: "fc-scrollgrid-sticky-shim", style: { width: e.clientWidth, minWidth: e.tableMinWidth } }) } function qo(e) { let { stickyHeaderDates: t } = e; return null != t && "auto" !== t || (t = "auto" === e.height || "auto" === e.viewHeight), t } function Yo(e) { let { stickyFooterScrollbar: t } = e; return null != t && "auto" !== t || (t = "auto" === e.height || "auto" === e.viewHeight), t } class Qo extends Qr { constructor() { super(...arguments), this.processCols = tn((e => e), Wo), this.renderMicroColGroup = tn(zo), this.scrollerRefs = new No, this.scrollerElRefs = new No(this._handleScrollerEl.bind(this)), this.state = { shrinkWidth: null, forceYScrollbars: !1, scrollerClientWidths: {}, scrollerClientHeights: {} }, this.handleSizing = () => { this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims())) } } render() { let { props: e, state: t, context: n } = this, r = e.sections || [], i = this.processCols(e.cols), o = this.renderMicroColGroup(i, t.shrinkWidth), s = Fo(e.liquid, n); e.collapsibleWidth && s.push("fc-scrollgrid-collapsible"); let a, l = r.length, d = 0, c = [], u = [], h = []; for (; d < l && "header" === (a = r[d]).type;)c.push(this.renderSection(a, o, !0)), d += 1; for (; d < l && "body" === (a = r[d]).type;)u.push(this.renderSection(a, o, !1)), d += 1; for (; d < l && "footer" === (a = r[d]).type;)h.push(this.renderSection(a, o, !0)), d += 1; let f = !lr(); const g = { role: "rowgroup" }; return p("table", { role: "grid", className: s.join(" "), style: { height: e.height } }, Boolean(!f && c.length) && p("thead", g, ...c), Boolean(!f && u.length) && p("tbody", g, ...u), Boolean(!f && h.length) && p("tfoot", g, ...h), f && p("tbody", g, ...c, ...u, ...h)) } renderSection(e, t, n) { return "outerContent" in e ? p(v, { key: e.key }, e.outerContent) : p("tr", { key: e.key, role: "presentation", className: Vo(e, this.props.liquid).join(" ") }, this.renderChunkTd(e, t, e.chunk, n)) } renderChunkTd(e, t, n, r) { if ("outerContent" in n) return n.outerContent; let { props: i } = this, { forceYScrollbars: o, scrollerClientWidths: s, scrollerClientHeights: a } = this.state, l = Bo(i, e), d = Po(i, e), c = i.liquid ? o ? "scroll" : l ? "auto" : "hidden" : "visible", u = e.key, h = Lo(e, n, { tableColGroupNode: t, tableMinWidth: "", clientWidth: i.collapsibleWidth || void 0 === s[u] ? null : s[u], clientHeight: void 0 !== a[u] ? a[u] : null, expandRows: e.expandRows, syncRowHeights: !1, rowSyncHeights: [], reportRowHeightChange: () => { } }, r); return p(r ? "th" : "td", { ref: n.elRef, role: "presentation" }, p("div", { className: "fc-scroller-harness" + (d ? " fc-scroller-harness-liquid" : "") }, p(Oo, { ref: this.scrollerRefs.createRef(u), elRef: this.scrollerElRefs.createRef(u), overflowY: c, overflowX: i.liquid ? "hidden" : "visible", maxHeight: e.maxHeight, liquid: d, liquidIsAbsolute: !0 }, h))) } _handleScrollerEl(e, t) { let n = function (e, t) { for (let n of e) if (n.key === t) return n; return null }(this.props.sections, t); n && Zr(n.chunk.scrollerElRef, e) } componentDidMount() { this.handleSizing(), this.context.addResizeHandler(this.handleSizing) } componentDidUpdate() { this.handleSizing() } componentWillUnmount() { this.context.removeResizeHandler(this.handleSizing) } computeShrinkWidth() { return Uo(this.props.cols) ? Ho(this.scrollerElRefs.getAll()) : 0 } computeScrollerDims() { let e = xr(), { scrollerRefs: t, scrollerElRefs: n } = this, r = !1, i = {}, o = {}; for (let e in t.currentMap) { let n = t.currentMap[e]; if (n && n.needsYScrolling()) { r = !0; break } } for (let t of this.props.sections) { let s = t.key, a = n.currentMap[s]; if (a) { let t = a.parentNode; i[s] = Math.floor(t.getBoundingClientRect().width - (r ? e.y : 0)), o[s] = Math.floor(t.getBoundingClientRect().height) } } return { forceYScrollbars: r, scrollerClientWidths: i, scrollerClientHeights: o } } } Qo.addStateEquality({ scrollerClientWidths: Dt, scrollerClientHeights: Dt }); class Zo extends Qr { constructor() { super(...arguments), this.handleEl = e => { this.el = e, e && ui(e, this.props.seg) } } render() { const { props: e, context: t } = this, { options: n } = t, { seg: r } = e, { eventRange: i } = r, { ui: o } = i, s = { event: new si(t, i.def, i.instance), view: t.viewApi, timeText: e.timeText, textColor: o.textColor, backgroundColor: o.backgroundColor, borderColor: o.borderColor, isDraggable: !e.disableDragging && vi(r, t), isStartResizable: !e.disableResizing && yi(r, t), isEndResizable: !e.disableResizing && bi(r), isMirror: Boolean(e.isDragging || e.isResizing || e.isDateSelecting), isStart: Boolean(r.isStart), isEnd: Boolean(r.isEnd), isPast: Boolean(e.isPast), isFuture: Boolean(e.isFuture), isToday: Boolean(e.isToday), isSelected: Boolean(e.isSelected), isDragging: Boolean(e.isDragging), isResizing: Boolean(e.isResizing) }; return p(ro, Object.assign({}, e, { elRef: this.handleEl, elClasses: [...Ci(s), ...r.eventRange.ui.classNames, ...e.elClasses || []], renderProps: s, generatorName: "eventContent", customGenerator: n.eventContent, defaultGenerator: e.defaultGenerator, classNameGenerator: n.eventClassNames, didMount: n.eventDidMount, willUnmount: n.eventWillUnmount })) } componentDidUpdate(e) { this.el && this.props.seg !== e.seg && ui(this.el, this.props.seg) } } class Xo extends Qr { render() { let { props: e, context: t } = this, { options: n } = t, { seg: r } = e, { ui: i } = r.eventRange, o = Ei(r, n.eventTimeFormat || e.defaultTimeFormat, t, e.defaultDisplayEventTime, e.defaultDisplayEventEnd); return p(Zo, Object.assign({}, e, { elTag: "a", elStyle: { borderColor: i.borderColor, backgroundColor: i.backgroundColor }, elAttrs: Ai(r, t), defaultGenerator: $o, timeText: o }), ((e, t) => p(v, null, p(e, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: t.textColor } }), Boolean(t.isStartResizable) && p("div", { className: "fc-event-resizer fc-event-resizer-start" }), Boolean(t.isEndResizable) && p("div", { className: "fc-event-resizer fc-event-resizer-end" })))) } } function $o(e) { return p("div", { className: "fc-event-main-frame" }, e.timeText && p("div", { className: "fc-event-time" }, e.timeText), p("div", { className: "fc-event-title-container" }, p("div", { className: "fc-event-title fc-sticky" }, e.event.title || p(v, null, "Â ")))) } const Jo = e => p(Gr.Consumer, null, (t => { let { options: n } = t, r = { isAxis: e.isAxis, date: t.dateEnv.toDate(e.date), view: t.viewApi }; return p(ro, Object.assign({}, e, { elTag: e.elTag || "div", renderProps: r, generatorName: "nowIndicatorContent", customGenerator: n.nowIndicatorContent, classNameGenerator: n.nowIndicatorClassNames, didMount: n.nowIndicatorDidMount, willUnmount: n.nowIndicatorWillUnmount })) })), Ko = vn({ day: "numeric" }); class es extends Qr { constructor() { super(...arguments), this.refineRenderProps = nn(ns) } render() { let { props: e, context: t } = this, { options: n } = t, r = this.refineRenderProps({ date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, isMonthStart: e.isMonthStart || !1, showDayNumber: e.showDayNumber, extraRenderProps: e.extraRenderProps, viewApi: t.viewApi, dateEnv: t.dateEnv, monthStartFormat: n.monthStartFormat }); return p(ro, Object.assign({}, e, { elClasses: [...Er(r, t.theme), ...e.elClasses || []], elAttrs: Object.assign(Object.assign({}, e.elAttrs), r.isDisabled ? {} : { "data-date": $t(e.date) }), renderProps: r, generatorName: "dayCellContent", customGenerator: n.dayCellContent, defaultGenerator: e.defaultGenerator, classNameGenerator: r.isDisabled ? void 0 : n.dayCellClassNames, didMount: n.dayCellDidMount, willUnmount: n.dayCellWillUnmount })) } } function ts(e) { return Boolean(e.dayCellContent || Ki("dayCellContent", e)) } function ns(e) { let { date: t, dateEnv: n, dateProfile: r, isMonthStart: i } = e, o = br(t, e.todayRange, null, r), s = e.showDayNumber ? n.format(t, i ? e.monthStartFormat : Ko) : ""; return Object.assign(Object.assign(Object.assign({ date: n.toDate(t), view: e.viewApi }, o), { isMonthStart: i, dayNumberText: s }), e.extraRenderProps) } class rs extends Qr { render() { let { props: e } = this, { seg: t } = e; return p(Zo, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: t.eventRange.ui.backgroundColor }, defaultGenerator: is, seg: t, timeText: "", isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: !1, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday, disableDragging: !0, disableResizing: !0 }) } } function is(e) { let { title: t } = e.event; return t && p("div", { className: "fc-event-title" }, e.event.title) } function os(e) { return p("div", { className: "fc-" + e }) } const ss = e => p(Gr.Consumer, null, (t => { let { dateEnv: n, options: r } = t, { date: i } = e, o = r.weekNumberFormat || e.defaultFormat, s = { num: n.computeWeekNumber(i), text: n.format(i, o), date: i }; return p(ro, Object.assign({}, e, { renderProps: s, generatorName: "weekNumberContent", customGenerator: r.weekNumberContent, defaultGenerator: as, classNameGenerator: r.weekNumberClassNames, didMount: r.weekNumberDidMount, willUnmount: r.weekNumberWillUnmount })) })); function as(e) { return e.text } class ls extends Qr { constructor() { super(...arguments), this.state = { titleId: We() }, this.handleRootEl = e => { this.rootEl = e, this.props.elRef && Zr(this.props.elRef, e) }, this.handleDocumentMouseDown = e => { const t = Be(e); this.rootEl.contains(t) || this.handleCloseClick() }, this.handleDocumentKeyDown = e => { "Escape" === e.key && this.handleCloseClick() }, this.handleCloseClick = () => { let { onClose: e } = this.props; e && e() } } render() { let { theme: e, options: t } = this.context, { props: n, state: r } = this, i = ["fc-popover", e.getClass("popover")].concat(n.extraClassNames || []); return he(p("div", Object.assign({}, n.extraAttrs, { id: n.id, className: i.join(" "), "aria-labelledby": r.titleId, ref: this.handleRootEl }), p("div", { className: "fc-popover-header " + e.getClass("popoverHeader") }, p("span", { className: "fc-popover-title", id: r.titleId }, n.title), p("span", { className: "fc-popover-close " + e.getIconClass("close"), title: t.closeHint, onClick: this.handleCloseClick })), p("div", { className: "fc-popover-body " + e.getClass("popoverContent") }, n.children)), n.parentEl) } componentDidMount() { document.addEventListener("mousedown", this.handleDocumentMouseDown), document.addEventListener("keydown", this.handleDocumentKeyDown), this.updateSize() } componentWillUnmount() { document.removeEventListener("mousedown", this.handleDocumentMouseDown), document.removeEventListener("keydown", this.handleDocumentKeyDown) } updateSize() { let { isRtl: e } = this.context, { alignmentEl: t, alignGridTop: n } = this.props, { rootEl: r } = this, i = function (e) { let t = Ir(e), n = e.getBoundingClientRect(); for (let e of t) { let t = rr(n, e.getBoundingClientRect()); if (!t) return null; n = t } return n }(t); if (i) { let o = r.getBoundingClientRect(), s = n ? Me(t, ".fc-scrollgrid").getBoundingClientRect().top : i.top, a = e ? i.right - o.width : i.left; s = Math.max(s, 10), a = Math.min(a, document.documentElement.clientWidth - 10 - o.width), a = Math.max(a, 10); let l = r.offsetParent.getBoundingClientRect(); He(r, { top: s - l.top, left: a - l.left }) } } } class ds extends Xr { constructor() { super(...arguments), this.handleRootEl = e => { this.rootEl = e, e ? this.context.registerInteractiveComponent(this, { el: e, useEventCenter: !1 }) : this.context.unregisterInteractiveComponent(this) } } render() { let { options: e, dateEnv: t } = this.context, { props: n } = this, { startDate: r, todayRange: i, dateProfile: o } = n, s = t.format(r, e.dayPopoverFormat); return p(es, { elRef: this.handleRootEl, date: r, dateProfile: o, todayRange: i }, ((t, r, i) => p(ls, { elRef: i.ref, id: n.id, title: s, extraClassNames: ["fc-more-popover"].concat(i.className || []), extraAttrs: i, parentEl: n.parentEl, alignmentEl: n.alignmentEl, alignGridTop: n.alignGridTop, onClose: n.onClose }, ts(e) && p(t, { elTag: "div", elClasses: ["fc-more-popover-misc"] }), n.children))) } queryHit(e, t, n, r) { let { rootEl: i, props: o } = this; return e >= 0 && e < n && t >= 0 && t < r ? { dateProfile: o.dateProfile, dateSpan: Object.assign({ allDay: !o.forceTimed, range: { start: o.startDate, end: o.endDate } }, o.extraDateSpan), dayEl: i, rect: { left: 0, top: 0, right: n, bottom: r }, layer: 1 } : null } } class cs extends Qr { constructor() { super(...arguments), this.state = { isPopoverOpen: !1, popoverId: We() }, this.handleLinkEl = e => { this.linkEl = e, this.props.elRef && Zr(this.props.elRef, e) }, this.handleClick = e => { let { props: t, context: n } = this, { moreLinkClick: r } = n.options, i = hs(t).start; function o(e) { let { def: t, instance: r, range: i } = e.eventRange; return { event: new si(n, t, r), start: n.dateEnv.toDate(i.start), end: n.dateEnv.toDate(i.end), isStart: e.isStart, isEnd: e.isEnd } } "function" == typeof r && (r = r({ date: i, allDay: Boolean(t.allDayDate), allSegs: t.allSegs.map(o), hiddenSegs: t.hiddenSegs.map(o), jsEvent: e, view: n.viewApi })), r && "popover" !== r ? "string" == typeof r && n.calendarApi.zoomTo(i, r) : this.setState({ isPopoverOpen: !0 }) }, this.handlePopoverClose = () => { this.setState({ isPopoverOpen: !1 }) } } render() { let { props: e, state: t } = this; return p(Gr.Consumer, null, (n => { let { viewApi: r, options: i, calendarApi: o } = n, { moreLinkText: s } = i, { moreCnt: a } = e, l = hs(e), d = "function" == typeof s ? s.call(o, a) : `+${a} ${s}`, c = ot(i.moreLinkHint, [a], d), u = { num: a, shortText: "+" + a, text: d, view: r }; return p(v, null, Boolean(e.moreCnt) && p(ro, { elTag: e.elTag || "a", elRef: this.handleLinkEl, elClasses: [...e.elClasses || [], "fc-more-link"], elStyle: e.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, e.elAttrs), Ve(this.handleClick)), { title: c, "aria-expanded": t.isPopoverOpen, "aria-controls": t.isPopoverOpen ? t.popoverId : "" }), renderProps: u, generatorName: "moreLinkContent", customGenerator: i.moreLinkContent, defaultGenerator: e.defaultGenerator || us, classNameGenerator: i.moreLinkClassNames, didMount: i.moreLinkDidMount, willUnmount: i.moreLinkWillUnmount }, e.children), t.isPopoverOpen && p(ds, { id: t.popoverId, startDate: l.start, endDate: l.end, dateProfile: e.dateProfile, todayRange: e.todayRange, extraDateSpan: e.extraDateSpan, parentEl: this.parentEl, alignmentEl: e.alignmentElRef ? e.alignmentElRef.current : this.linkEl, alignGridTop: e.alignGridTop, forceTimed: e.forceTimed, onClose: this.handlePopoverClose }, e.popoverContent())) })) } componentDidMount() { this.updateParentEl() } componentDidUpdate() { this.updateParentEl() } updateParentEl() { this.linkEl && (this.parentEl = Me(this.linkEl, ".fc-view-harness")) } } function us(e) { return e.text } function hs(e) { if (e.allDayDate) return { start: e.allDayDate, end: Nt(e.allDayDate, 1) }; let { hiddenSegs: t } = e; return { start: fs(t), end: (n = t, n.reduce(ps).eventRange.range.end) }; var n } function fs(e) { return e.reduce(gs).eventRange.range.start } function gs(e, t) { return e.eventRange.range.start < t.eventRange.range.start ? e : t } function ps(e, t) { return e.eventRange.range.end > t.eventRange.range.end ? e : t } class ms extends Qr { render() { let { props: e, context: t } = this, { options: n } = t, r = { view: t.viewApi }; return p(ro, Object.assign({}, e, { elTag: e.elTag || "div", elClasses: [...vs(e.viewSpec), ...e.elClasses || []], renderProps: r, classNameGenerator: n.viewClassNames, generatorName: void 0, didMount: n.viewDidMount, willUnmount: n.viewWillUnmount }), (() => e.children)) } } function vs(e) { return [`fc-${e.type}-view`, "fc-view"] } const ys = { id: String, defaultAllDay: Boolean, url: String, format: String, events: Tn, eventDataTransform: Tn, success: Tn, failure: Tn }; function bs(e, t, n = Es(t)) { let r; if ("string" == typeof e ? r = { url: e } : "function" == typeof e || Array.isArray(e) ? r = { events: e } : "object" == typeof e && e && (r = e), r) { let { refined: i, extra: o } = xn(r, n), s = function (e, t) { let n = t.pluginHooks.eventSourceDefs; for (let t = n.length - 1; t >= 0; t -= 1) { let r = n[t].parseMeta(e); if (r) return { sourceDefId: t, meta: r } } return null }(i, t); if (s) return { _raw: e, isFetching: !1, latestFetchId: "", fetchRange: null, defaultAllDay: i.defaultAllDay, eventDataTransform: i.eventDataTransform, success: i.success, failure: i.failure, publicId: i.id || "", sourceId: Ye(), sourceDefId: s.sourceDefId, meta: s.meta, ui: zn(i, t), extendedProps: o } } return null } function Es(e) { return Object.assign(Object.assign(Object.assign({}, Ln), ys), e.pluginHooks.eventSourceRefiners) } class Ss { getCurrentData() { return this.currentDataManager.getCurrentData() } dispatch(e) { this.currentDataManager.dispatch(e) } get view() { return this.getCurrentData().viewApi } batchRendering(e) { e() } updateSize() { this.trigger("_resize", !0) } setOption(e, t) { this.dispatch({ type: "SET_OPTION", optionName: e, rawOptionValue: t }) } getOption(e) { return this.currentDataManager.currentCalendarOptionsInput[e] } getAvailableLocaleCodes() { return Object.keys(this.getCurrentData().availableRawLocales) } on(e, t) { let { currentDataManager: n } = this; n.currentCalendarOptionsRefiners[e] ? n.emitter.on(e, t) : console.warn(`Unknown listener name '${e}'`) } off(e, t) { this.currentDataManager.emitter.off(e, t) } trigger(e, ...t) { this.currentDataManager.emitter.trigger(e, ...t) } changeView(e, t) { this.batchRendering((() => { if (this.unselect(), t) if (t.start && t.end) this.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: e }), this.dispatch({ type: "SET_OPTION", optionName: "visibleRange", rawOptionValue: t }); else { let { dateEnv: n } = this.getCurrentData(); this.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: e, dateMarker: n.createMarker(t) }) } else this.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: e }) })) } zoomTo(e, t) { let n; t = t || "day", n = this.getCurrentData().viewSpecs[t] || this.getUnitViewSpec(t), this.unselect(), n ? this.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: n.type, dateMarker: e }) : this.dispatch({ type: "CHANGE_DATE", dateMarker: e }) } getUnitViewSpec(e) { let t, n, { viewSpecs: r, toolbarConfig: i } = this.getCurrentData(), o = [].concat(i.header ? i.header.viewsWithButtons : [], i.footer ? i.footer.viewsWithButtons : []); for (let e in r) o.push(e); for (t = 0; t < o.length; t += 1)if (n = r[o[t]], n && n.singleUnit === e) return n; return null } prev() { this.unselect(), this.dispatch({ type: "PREV" }) } next() { this.unselect(), this.dispatch({ type: "NEXT" }) } prevYear() { let e = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: e.dateEnv.addYears(e.currentDate, -1) }) } nextYear() { let e = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: e.dateEnv.addYears(e.currentDate, 1) }) } today() { let e = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: $r(e.calendarOptions.now, e.dateEnv) }) } gotoDate(e) { let t = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: t.dateEnv.createMarker(e) }) } incrementDate(e) { let t = this.getCurrentData(), n = ut(e); n && (this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: t.dateEnv.add(t.currentDate, n) })) } getDate() { let e = this.getCurrentData(); return e.dateEnv.toDate(e.currentDate) } formatDate(e, t) { let { dateEnv: n } = this.getCurrentData(); return n.format(n.createMarker(e), vn(t)) } formatRange(e, t, n) { let { dateEnv: r } = this.getCurrentData(); return r.formatRange(r.createMarker(e), r.createMarker(t), vn(n), n) } formatIso(e, t) { let { dateEnv: n } = this.getCurrentData(); return n.formatIso(n.createMarker(e), { omitTime: t }) } select(e, t) { let n; n = null == t ? null != e.start ? e : { start: e, end: null } : { start: e, end: t }; let r = this.getCurrentData(), i = function (e, t, n) { let r = function (e, t) { let { refined: n, extra: r } = xn(e, Di), i = n.start ? t.createMarkerMeta(n.start) : null, o = n.end ? t.createMarkerMeta(n.end) : null, { allDay: s } = n; return null == s && (s = i && i.isTimeUnspecified && (!o || o.isTimeUnspecified)), Object.assign({ range: { start: i ? i.marker : null, end: o ? o.marker : null }, allDay: s }, r) }(e, t), { range: i } = r; if (!i.start) return null; if (!i.end) { if (null == n) return null; i.end = t.add(i.start, n) } return r }(n, r.dateEnv, ut({ days: 1 })); i && (this.dispatch({ type: "SELECT_DATES", selection: i }), Kr(i, null, r)) } unselect(e) { let t = this.getCurrentData(); t.dateSelection && (this.dispatch({ type: "UNSELECT_DATES" }), function (e, t) { t.emitter.trigger("unselect", { jsEvent: e ? e.origEvent : null, view: t.viewApi || t.calendarApi.view }) }(e, t)) } addEvent(e, t) { if (e instanceof si) { let t = e._def, n = e._instance; return this.getCurrentData().eventStore.defs[t.defId] || (this.dispatch({ type: "ADD_EVENTS", eventStore: On({ def: t, instance: n }) }), this.triggerEventAdd(e)), e } let n, r = this.getCurrentData(); if (t instanceof oi) n = t.internalEventSource; else if ("boolean" == typeof t) t && ([n] = At(r.eventSources)); else if (null != t) { let e = this.getEventSourceById(t); if (!e) return console.warn(`Could not find an event source with ID "${t}"`), null; n = e.internalEventSource } let i = qn(e, n, r, !1); if (i) { let e = new si(r, i.def, i.def.recurringDef ? null : i.instance); return this.dispatch({ type: "ADD_EVENTS", eventStore: On(i) }), this.triggerEventAdd(e), e } return null } triggerEventAdd(e) { let { emitter: t } = this.getCurrentData(); t.trigger("eventAdd", { event: e, relatedEvents: [], revert: () => { this.dispatch({ type: "REMOVE_EVENTS", eventStore: ai(e) }) } }) } getEventById(e) { let t = this.getCurrentData(), { defs: n, instances: r } = t.eventStore; e = String(e); for (let i in n) { let o = n[i]; if (o.publicId === e) { if (o.recurringDef) return new si(t, o, null); for (let e in r) { let n = r[e]; if (n.defId === o.defId) return new si(t, o, n) } } } return null } getEvents() { let e = this.getCurrentData(); return li(e.eventStore, e) } removeAllEvents() { this.dispatch({ type: "REMOVE_ALL_EVENTS" }) } getEventSources() { let e = this.getCurrentData(), t = e.eventSources, n = []; for (let r in t) n.push(new oi(e, t[r])); return n } getEventSourceById(e) { let t = this.getCurrentData(), n = t.eventSources; e = String(e); for (let r in n) if (n[r].publicId === e) return new oi(t, n[r]); return null } addEventSource(e) { let t = this.getCurrentData(); if (e instanceof oi) return t.eventSources[e.internalEventSource.sourceId] || this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [e.internalEventSource] }), e; let n = bs(e, t); return n ? (this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [n] }), new oi(t, n)) : null } removeAllEventSources() { this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" }) } refetchEvents() { this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: !0 }) } scrollToTime(e) { let t = ut(e); t && this.trigger("_scrollRequest", { time: t }) } } var Cs = { __proto__: null, BASE_OPTION_DEFAULTS: bn, BaseComponent: Qr, BgEvent: rs, CalendarImpl: Ss, CalendarRoot: Qi, ContentContainer: ro, CustomRenderingStore: class extends class { constructor() { this.handlers = [] } set(e) { this.currentValue = e; for (let t of this.handlers) t(e) } subscribe(e) { this.handlers.push(e), void 0 !== this.currentValue && e(this.currentValue) } }{ constructor() { super(...arguments), this.map = new Map } handle(e) { const { map: t } = this; let n = !1; e.isActive ? (t.set(e.id, e), n = !0) : t.has(e.id) && (t.delete(e.id), n = !0), n && this.set(t) } }, DateComponent: Xr, DateEnv: Oi, DateProfileGenerator: Jr, DayCellContainer: es, DayHeader: uo, DaySeriesModel: fo, DayTableModel: go, DelayedRunner: Mo, ElementDragging: Vi, ElementScrollController: Lr, Emitter: Nr, EventContainer: Zo, EventImpl: si, Interaction: ji, MoreLinkContainer: cs, NamedTimeZoneImpl: class { constructor(e) { this.timeZoneName = e } }, NowIndicatorContainer: Jo, NowTimer: lo, PositionCache: Hr, RefMap: No, ScrollController: Br, ScrollResponder: Vr, Scroller: Oo, SegHierarchy: Ni, SimpleScrollGrid: Qo, Slicer: po, Splitter: cr, StandardEvent: Xo, TableDateCell: oo, TableDowCell: ao, Theme: zr, ViewContainer: ms, ViewContextType: Gr, WeekNumberContainer: ss, WindowScrollController: Wr, addDays: Nt, addDurations: ft, addMs: Ht, addWeeks: Ot, allowContextMenu: Ke, allowSelection: $e, applyMutationToEventStore: ni, applyStyle: He, asCleanDays: function (e) { return e.years || e.months || e.milliseconds ? 0 : e.days }, asRoughMinutes: function (e) { return mt(e) / 6e4 }, asRoughMs: mt, asRoughSeconds: function (e) { return mt(e) / 1e3 }, binarySearch: zi, buildElAttrs: eo, buildEntryKey: Pi, buildEventApis: li, buildEventRangeKey: wi, buildIsoString: Xt, buildNavLinkAttrs: wr, buildSegTimeText: Ei, collectFromHash: _t, combineEventUis: jn, compareByFieldSpecs: tt, compareNumbers: st, compareObjs: Tt, computeEarliestSegStart: fs, computeEdges: kr, computeFallbackHeaderFormat: Zi, computeInnerRect: _r, computeRect: Mr, computeShrinkWidth: Ho, computeVisibleDayRange: Kn, config: Gi, constrainPoint: ir, createDuration: ut, createEmptyEventStore: function () { return { defs: {}, instances: {} } }, createEventInstance: kn, createEventUi: zn, createFormatter: vn, diffDates: tr, diffDayAndTime: Lt, diffDays: Bt, diffPoints: sr, diffWeeks: Pt, diffWholeDays: zt, diffWholeWeeks: Wt, disableCursor: Qe, elementClosest: Me, elementMatches: Ie, enableCursor: Ze, eventTupleToStore: On, filterHash: St, findDirectChildren: function (e, t) { let n = e instanceof HTMLElement ? [e] : e, r = []; for (let e = 0; e < n.length; e += 1) { let i = n[e].children; for (let e = 0; e < i.length; e += 1) { let n = i[e]; t && !Ie(n, t) || r.push(n) } } return r }, findElements: Oe, flexibleCompare: rt, formatDayString: $t, formatIsoMonthStr: Jt, formatIsoTimeString: Kt, getAllowYScrolling: Bo, getCanVGrowWithinCell: lr, getClippingParents: Ir, getDateMeta: br, getDayClassNames: Er, getDefaultEventEnd: ti, getElSeg: hi, getEntrySpanEnd: Hi, getEventTargetViaRoot: Be, getIsRtlScrollbarOnLeft: Rr, getRectCenter: or, getRelevantEvents: Nn, getScrollGridClassNames: Fo, getScrollbarWidths: xr, getSectionClassNames: Vo, getSectionHasLiquidHeight: Po, getSegAnchorAttrs: Ai, getSegMeta: Si, getSlotClassNames: function (e, t) { let n = ["fc-slot", "fc-slot-" + It[e.dow]]; return e.isDisabled ? n.push("fc-slot-disabled") : (e.isToday && (n.push("fc-slot-today"), n.push(t.getClass("today"))), e.isPast && n.push("fc-slot-past"), e.isFuture && n.push("fc-slot-future")), n }, getStickyFooterScrollbar: Yo, getStickyHeaderDates: qo, getUniqueDomId: We, greatestDurationDenominator: yt, groupIntersectingEntries: Bi, guid: Ye, hasBgRendering: ci, hasCustomDayCellContent: ts, hasShrinkWidth: Uo, identity: Tn, injectStyles: Re, interactionSettingsStore: Fi, interactionSettingsToStore: Ui, intersectRanges: gr, intersectRects: rr, intersectSpans: Li, isArraysEqual: Mt, isColPropsEqual: Wo, isDateSelectionValid: Co, isDateSpansEqual: Ri, isInt: at, isInteractionValid: So, isMultiDayRange: er, isPropsEqual: Dt, isPropsValid: Ao, isValidDate: Qt, mapHash: Ct, memoize: tn, memoizeArraylike: function (e, t, n) { let r = [], i = []; return o => { let s = r.length, a = o.length, l = 0; for (; l < s; l += 1)if (o[l]) { if (!Mt(r[l], o[l])) { n && n(i[l]); let r = e.apply(this, o[l]); t && t(r, i[l]) || (i[l] = r) } } else n && n(i[l]); for (; l < a; l += 1)i[l] = e.apply(this, o[l]); return r = o, i.splice(a), i } }, memoizeHashlike: function (e, t, n) { let r = {}, i = {}; return o => { let s = {}; for (let a in o) if (i[a]) if (Mt(r[a], o[a])) s[a] = i[a]; else { n && n(i[a]); let r = e.apply(this, o[a]); s[a] = t && t(r, i[a]) ? i[a] : r } else s[a] = e.apply(this, o[a]); return r = o, i = s, s } }, memoizeObjArg: nn, mergeEventStores: Hn, multiplyDuration: gt, padStart: it, parseBusinessHours: $n, parseClassNames: Bn, parseDragMeta: Yi, parseEventDef: Zn, parseFieldSpecs: et, parseMarker: Ii, pointInsideRect: nr, preventContextMenu: Je, preventDefault: ze, preventSelection: Xe, rangeContainsMarker: yr, rangeContainsRange: vr, rangesEqual: pr, rangesIntersect: mr, refineEventDef: Yn, refineProps: xn, removeElement: _e, removeExact: function (e, t) { let n = 0, r = 0; for (; r < e.length;)e[r] === t ? (e.splice(r, 1), n += 1) : r += 1; return n }, renderChunkContent: Lo, renderFill: os, renderMicroColGroup: zo, renderScrollShim: Go, requestJson: _o, sanitizeShrinkWidth: jo, setRef: Zr, sliceEventStore: di, sortEventSegs: pi, startOfDay: jt, translateRect: function (e, t, n) { return { left: e.left + t, right: e.right + t, top: e.top + n, bottom: e.bottom + n } }, triggerDateSelect: Kr, unpromisify: Or, whenTransitionDone: Fe, wholeDivideDurations: vt }, ws = { __proto__: null, createPortal: he, createContext: Fr, flushSync: jr, Component: C, Fragment: v, cloneElement: function (e, n, r) { var i, o, s, a = f({}, e.props); for (s in n) "key" == s ? i = n[s] : "ref" == s ? o = n[s] : a[s] = n[s]; return arguments.length > 2 && (a.children = arguments.length > 3 ? t.call(arguments, 2) : r), m(e.type, a, i || e.key, o || e.ref, null) }, createElement: p, createRef: function () { return { current: null } }, h: p, hydrate: function e(t, n) { W(t, n, e) }, get isValidElement() { return i }, get options() { return n }, render: W, toChildArray: _ }; const As = [], Ds = { code: "en", week: { dow: 0, doy: 4 }, direction: "ltr", buttonText: { prev: "prev", next: "next", prevYear: "prev year", nextYear: "next year", year: "year", today: "today", month: "month", week: "week", day: "day", list: "list" }, weekText: "W", weekTextLong: "Week", closeHint: "Close", timeHint: "Time", eventHint: "Event", allDayText: "all-day", moreLinkText: "more", noEventsText: "No events to display" }, Rs = Object.assign(Object.assign({}, Ds), { buttonHints: { prev: "Previous $0", next: "Next $0", today: (e, t) => "day" === t ? "Today" : "This " + e }, viewHint: "$0 view", navLinkHint: "Go to $0", moreLinkHint: e => `Show ${e} more event${1 === e ? "" : "s"}` }); function xs(e) { let t = e.length > 0 ? e[0].code : "en", n = As.concat(e), r = { en: Rs }; for (let e of n) r[e.code] = e; return { map: r, defaultCode: t } } function Ts(e, t) { return "object" != typeof e || Array.isArray(e) ? function (e, t) { let n = [].concat(e || []), r = function (e, t) { for (let n = 0; n < e.length; n += 1) { let r = e[n].toLocaleLowerCase().split("-"); for (let e = r.length; e > 0; e -= 1) { let n = r.slice(0, e).join("-"); if (t[n]) return t[n] } } return null }(n, t) || Rs; return ks(e, n, r) }(e, t) : ks(e.code, [e.code], e) } function ks(e, t, n) { let r = Et([Ds, n], ["buttonText"]); delete r.code; let { week: i } = r; return delete r.week, { codeArg: e, codes: t, week: i, simpleNumberFormat: new Intl.NumberFormat(e), options: r } } function _s(e) { return { id: Ye(), name: e.name, premiumReleaseDate: e.premiumReleaseDate ? new Date(e.premiumReleaseDate) : void 0, deps: e.deps || [], reducers: e.reducers || [], isLoadingFuncs: e.isLoadingFuncs || [], contextInit: [].concat(e.contextInit || []), eventRefiners: e.eventRefiners || {}, eventDefMemberAdders: e.eventDefMemberAdders || [], eventSourceRefiners: e.eventSourceRefiners || {}, isDraggableTransformers: e.isDraggableTransformers || [], eventDragMutationMassagers: e.eventDragMutationMassagers || [], eventDefMutationAppliers: e.eventDefMutationAppliers || [], dateSelectionTransformers: e.dateSelectionTransformers || [], datePointTransforms: e.datePointTransforms || [], dateSpanTransforms: e.dateSpanTransforms || [], views: e.views || {}, viewPropsTransformers: e.viewPropsTransformers || [], isPropsValid: e.isPropsValid || null, externalDefTransforms: e.externalDefTransforms || [], viewContainerAppends: e.viewContainerAppends || [], eventDropTransformers: e.eventDropTransformers || [], componentInteractions: e.componentInteractions || [], calendarInteractions: e.calendarInteractions || [], themeClasses: e.themeClasses || {}, eventSourceDefs: e.eventSourceDefs || [], cmdFormatter: e.cmdFormatter, recurringTypes: e.recurringTypes || [], namedTimeZonedImpl: e.namedTimeZonedImpl, initialView: e.initialView || "", elementDraggingImpl: e.elementDraggingImpl, optionChangeHandlers: e.optionChangeHandlers || {}, scrollGridImpl: e.scrollGridImpl || null, listenerRefiners: e.listenerRefiners || {}, optionRefiners: e.optionRefiners || {}, propSetHandlers: e.propSetHandlers || {} } } function Ms(e, t) { return void 0 === e ? t : void 0 === t ? e : new Date(Math.max(e.valueOf(), t.valueOf())) } class Is extends zr { } function Os(e, t, n, r) { if (t[e]) return t[e]; let i = function (e, t, n, r) { let i = n[e], o = r[e], s = e => i && null !== i[e] ? i[e] : o && null !== o[e] ? o[e] : null, a = s("component"), l = s("superType"), d = null; if (l) { if (l === e) throw new Error("Can't have a custom view type that references itself"); d = Os(l, t, n, r) } return !a && d && (a = d.component), a ? { type: e, component: a, defaults: Object.assign(Object.assign({}, d ? d.defaults : {}), i ? i.rawOptions : {}), overrides: Object.assign(Object.assign({}, d ? d.overrides : {}), o ? o.rawOptions : {}) } : null }(e, t, n, r); return i && (t[e] = i), i } function Ns(e) { return Ct(e, Hs) } function Hs(e) { let t = "function" == typeof e ? { component: e } : e, { component: n } = t; return t.content ? n = Ps(t) : !n || n.prototype instanceof Qr || (n = Ps(Object.assign(Object.assign({}, t), { content: n }))), { superType: t.type, component: n, rawOptions: t } } function Ps(e) { return t => p(Gr.Consumer, null, (n => p(ro, { elTag: "div", elClasses: vs(n.viewSpec), renderProps: Object.assign(Object.assign({}, t), { nextDayThreshold: n.options.nextDayThreshold }), generatorName: void 0, customGenerator: e.content, classNameGenerator: e.classNames, didMount: e.didMount, willUnmount: e.willUnmount }))) } function Bs(e, t, n, r) { let i = Ns(e), o = Ns(t.views); return Ct(function (e, t) { let n, r = {}; for (n in e) Os(n, r, e, t); for (n in t) Os(n, r, e, t); return r }(i, o), (e => function (e, t, n, r, i) { let o = e.overrides.duration || e.defaults.duration || r.duration || n.duration, s = null, a = "", l = "", d = {}; if (o && (s = function (e) { let t = JSON.stringify(e), n = Ls[t]; return void 0 === n && (n = ut(e), Ls[t] = n), n }(o), s)) { let e = yt(s); a = e.unit, 1 === e.value && (l = a, d = t[a] ? t[a].rawOptions : {}) } let c = t => { let n = t.buttonText || {}, r = e.defaults.buttonTextKey; return null != r && null != n[r] ? n[r] : null != n[e.type] ? n[e.type] : null != n[l] ? n[l] : null }, u = t => { let n = t.buttonHints || {}, r = e.defaults.buttonTextKey; return null != r && null != n[r] ? n[r] : null != n[e.type] ? n[e.type] : null != n[l] ? n[l] : null }; return { type: e.type, component: e.component, duration: s, durationUnit: a, singleUnit: l, optionDefaults: e.defaults, optionOverrides: Object.assign(Object.assign({}, d), e.overrides), buttonTextOverride: c(r) || c(n) || e.overrides.buttonText, buttonTextDefault: c(i) || e.defaults.buttonText || c(bn) || e.type, buttonTitleOverride: u(r) || u(n) || e.overrides.buttonHint, buttonTitleDefault: u(i) || e.defaults.buttonHint || u(bn) } }(e, o, t, n, r))) } Is.prototype.classes = { root: "fc-theme-standard", tableCellShaded: "fc-cell-shaded", buttonGroup: "fc-button-group", button: "fc-button fc-button-primary", buttonActive: "fc-button-active" }, Is.prototype.baseIconClass = "fc-icon", Is.prototype.iconClasses = { close: "fc-icon-x", prev: "fc-icon-chevron-left", next: "fc-icon-chevron-right", prevYear: "fc-icon-chevrons-left", nextYear: "fc-icon-chevrons-right" }, Is.prototype.rtlIconClasses = { prev: "fc-icon-chevron-right", next: "fc-icon-chevron-left", prevYear: "fc-icon-chevrons-right", nextYear: "fc-icon-chevrons-left" }, Is.prototype.iconOverrideOption = "buttonIcons", Is.prototype.iconOverrideCustomButtonOption = "icon", Is.prototype.iconOverridePrefix = "fc-icon-"; let Ls = {}; function Ws(e) { for (let t in e) if (e[t].isFetching) return !0; return !1 } function zs(e, t, n, r) { let i = {}; for (let e of t) i[e.sourceId] = e; return n && (i = js(i, n, r)), Object.assign(Object.assign({}, e), i) } function js(e, t, n) { return Us(e, St(e, (e => function (e, t, n) { return Gs(e, n) ? !n.options.lazyFetching || !e.fetchRange || e.isFetching || t.start < e.fetchRange.start || t.end > e.fetchRange.end : !e.latestFetchId }(e, t, n))), t, !1, n) } function Us(e, t, n, r, i) { let o = {}; for (let s in e) { let a = e[s]; t[s] ? o[s] = Fs(a, n, r, i) : o[s] = a } return o } function Fs(e, t, n, r) { let { options: i, calendarApi: o } = r, s = r.pluginHooks.eventSourceDefs[e.sourceDefId], a = Ye(); return s.fetch({ eventSource: e, range: t, isRefetch: n, context: r }, (n => { let { rawEvents: s } = n; i.eventSourceSuccess && (s = i.eventSourceSuccess.call(o, s, n.response) || s), e.success && (s = e.success.call(o, s, n.response) || s), r.dispatch({ type: "RECEIVE_EVENTS", sourceId: e.sourceId, fetchId: a, fetchRange: t, rawEvents: s }) }), (n => { let s = !1; i.eventSourceFailure && (i.eventSourceFailure.call(o, n), s = !0), e.failure && (e.failure(n), s = !0), s || console.warn(n.message, n), r.dispatch({ type: "RECEIVE_EVENT_ERROR", sourceId: e.sourceId, fetchId: a, fetchRange: t, error: n }) })), Object.assign(Object.assign({}, e), { isFetching: !0, latestFetchId: a }) } function Vs(e, t) { return St(e, (e => Gs(e, t))) } function Gs(e, t) { return !t.pluginHooks.eventSourceDefs[e.sourceDefId].ignoreRange } function qs(e, t) { switch (t.type) { case "UNSELECT_DATES": return null; case "SELECT_DATES": return t.selection; default: return e } } function Ys(e, t) { switch (t.type) { case "UNSELECT_EVENT": return ""; case "SELECT_EVENT": return t.eventInstanceId; default: return e } } function Qs(e, t) { let n; switch (t.type) { case "UNSET_EVENT_DRAG": return null; case "SET_EVENT_DRAG": return n = t.state, { affectedEvents: n.affectedEvents, mutatedEvents: n.mutatedEvents, isEvent: n.isEvent }; default: return e } } function Zs(e, t) { let n; switch (t.type) { case "UNSET_EVENT_RESIZE": return null; case "SET_EVENT_RESIZE": return n = t.state, { affectedEvents: n.affectedEvents, mutatedEvents: n.mutatedEvents, isEvent: n.isEvent }; default: return e } } function Xs(e, t, n, r, i) { return { header: e.headerToolbar ? $s(e.headerToolbar, e, t, n, r, i) : null, footer: e.footerToolbar ? $s(e.footerToolbar, e, t, n, r, i) : null } } function $s(e, t, n, r, i, o) { let s = {}, a = [], l = !1; for (let d in e) { let c = Js(e[d], t, n, r, i, o); s[d] = c.widgets, a.push(...c.viewsWithButtons), l = l || c.hasTitle } return { sectionWidgets: s, viewsWithButtons: a, hasTitle: l } } function Js(e, t, n, r, i, o) { let s = "rtl" === t.direction, a = t.customButtons || {}, l = n.buttonText || {}, d = t.buttonText || {}, c = n.buttonHints || {}, u = t.buttonHints || {}, h = e ? e.split(" ") : [], f = [], g = !1; return { widgets: h.map((e => e.split(",").map((e => { if ("title" === e) return g = !0, { buttonName: e }; let n, h, p, m, v, y; if (n = a[e]) p = e => { n.click && n.click.call(e.target, e, e.target) }, (m = r.getCustomButtonIconClass(n)) || (m = r.getIconClass(e, s)) || (v = n.text), y = n.hint || n.text; else if (h = i[e]) { f.push(e), p = () => { o.changeView(e) }, (v = h.buttonTextOverride) || (m = r.getIconClass(e, s)) || (v = h.buttonTextDefault); let n = h.buttonTextOverride || h.buttonTextDefault; y = ot(h.buttonTitleOverride || h.buttonTitleDefault || t.viewHint, [n, e], n) } else if (o[e]) if (p = () => { o[e]() }, (v = l[e]) || (m = r.getIconClass(e, s)) || (v = d[e]), "prevYear" === e || "nextYear" === e) { let t = "prevYear" === e ? "prev" : "next"; y = ot(c[t] || u[t], [d.year || "year", "year"], d[e]) } else y = t => ot(c[e] || u[e], [d[t] || t, t], d[e]); return { buttonName: e, buttonClick: p, buttonIcon: m, buttonText: v, buttonHint: y } })))), viewsWithButtons: f, hasTitle: g } } class Ks { constructor(e, t, n) { this.type = e, this.getCurrentData = t, this.dateEnv = n } get calendar() { return this.getCurrentData().calendarApi } get title() { return this.getCurrentData().viewTitle } get activeStart() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start) } get activeEnd() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end) } get currentStart() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start) } get currentEnd() { return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end) } getOption(e) { return this.getCurrentData().options[e] } } function ea(e, t) { let n = At(t.getCurrentData().eventSources); if (1 === n.length && 1 === e.length && Array.isArray(n[0]._raw) && Array.isArray(e[0])) return void t.dispatch({ type: "RESET_RAW_EVENTS", sourceId: n[0].sourceId, rawEvents: e[0] }); let r = []; for (let t of e) { let e = !1; for (let r = 0; r < n.length; r += 1)if (n[r]._raw === t) { n.splice(r, 1), e = !0; break } e || r.push(t) } for (let e of n) t.dispatch({ type: "REMOVE_EVENT_SOURCE", sourceId: e.sourceId }); for (let e of r) t.calendarApi.addEventSource(e) } const ta = [_s({ name: "array-event-source", eventSourceDefs: [{ ignoreRange: !0, parseMeta: e => Array.isArray(e.events) ? e.events : null, fetch(e, t) { t({ rawEvents: e.eventSource.meta }) } }] }), _s({ name: "func-event-source", eventSourceDefs: [{ parseMeta: e => "function" == typeof e.events ? e.events : null, fetch(e, t, n) { const { dateEnv: r } = e.context; Or(e.eventSource.meta.bind(null, xi(e.range, r)), (e => t({ rawEvents: e })), n) } }] }), _s({ name: "json-event-source", eventSourceRefiners: { method: String, extraParams: Tn, startParam: String, endParam: String, timeZoneParam: String }, eventSourceDefs: [{ parseMeta: e => !e.url || "json" !== e.format && e.format ? null : { url: e.url, format: "json", method: (e.method || "GET").toUpperCase(), extraParams: e.extraParams, startParam: e.startParam, endParam: e.endParam, timeZoneParam: e.timeZoneParam }, fetch(e, t, n) { const { meta: r } = e.eventSource, i = function (e, t, n) { let r, i, o, s, { dateEnv: a, options: l } = n, d = {}; return r = e.startParam, null == r && (r = l.startParam), i = e.endParam, null == i && (i = l.endParam), o = e.timeZoneParam, null == o && (o = l.timeZoneParam), s = "function" == typeof e.extraParams ? e.extraParams() : e.extraParams || {}, Object.assign(d, s), d[r] = a.formatIso(t.start), d[i] = a.formatIso(t.end), "local" !== a.timeZone && (d[o] = a.timeZone), d }(r, e.range, e.context); _o(r.method, r.url, i).then((([e, n]) => { t({ rawEvents: e, response: n }) }), n) } }] }), _s({ name: "simple-recurring-event", recurringTypes: [{ parse(e, t) { if (e.daysOfWeek || e.startTime || e.endTime || e.startRecur || e.endRecur) { let i, o = { daysOfWeek: e.daysOfWeek || null, startTime: e.startTime || null, endTime: e.endTime || null, startRecur: e.startRecur ? t.createMarker(e.startRecur) : null, endRecur: e.endRecur ? t.createMarker(e.endRecur) : null }; return e.duration && (i = e.duration), !i && e.startTime && e.endTime && (n = e.endTime, r = e.startTime, i = { years: n.years - r.years, months: n.months - r.months, days: n.days - r.days, milliseconds: n.milliseconds - r.milliseconds }), { allDayGuess: Boolean(!e.startTime && !e.endTime), duration: i, typeData: o } } var n, r; return null }, expand(e, t, n) { let r = gr(t, { start: e.startRecur, end: e.endRecur }); return r ? function (e, t, n, r) { let i = e ? wt(e) : null, o = jt(n.start), s = n.end, a = []; for (; o < s;) { let e; i && !i[o.getUTCDay()] || (e = t ? r.add(o, t) : o, a.push(e)), o = Nt(o, 1) } return a }(e.daysOfWeek, e.startTime, r, n) : [] } }], eventRefiners: { daysOfWeek: Tn, startTime: ut, endTime: ut, duration: ut, startRecur: Tn, endRecur: Tn } }), _s({ name: "change-handler", optionChangeHandlers: { events(e, t) { ea([e], t) }, eventSources: ea } }), _s({ name: "misc", isLoadingFuncs: [e => Ws(e.eventSources)], propSetHandlers: { dateProfile: function (e, t) { t.emitter.trigger("datesSet", Object.assign(Object.assign({}, xi(e.activeRange, t.dateEnv)), { view: t.viewApi })) }, eventStore: function (e, t) { let { emitter: n } = t; n.hasHandlers("eventsSet") && n.trigger("eventsSet", li(e, t)) } } })]; class na { constructor(e, t) { this.runTaskOption = e, this.drainedOption = t, this.queue = [], this.delayedRunner = new Mo(this.drain.bind(this)) } request(e, t) { this.queue.push(e), this.delayedRunner.request(t) } pause(e) { this.delayedRunner.pause(e) } resume(e, t) { this.delayedRunner.resume(e, t) } drain() { let { queue: e } = this; for (; e.length;) { let t, n = []; for (; t = e.shift();)this.runTask(t), n.push(t); this.drained(n) } } runTask(e) { this.runTaskOption && this.runTaskOption(e) } drained(e) { this.drainedOption && this.drainedOption(e) } } function ra(e, t, n) { let r; return r = /^(year|month)$/.test(e.currentRangeUnit) ? e.currentRange : e.activeRange, n.formatRange(r.start, r.end, vn(t.titleFormat || function (e) { let { currentRangeUnit: t } = e; if ("year" === t) return { year: "numeric" }; if ("month" === t) return { year: "numeric", month: "long" }; let n = zt(e.currentRange.start, e.currentRange.end); return null !== n && n > 1 ? { year: "numeric", month: "short", day: "numeric" } : { year: "numeric", month: "long", day: "numeric" } }(e)), { isEndExclusive: e.isRangeAllDay, defaultSeparator: t.titleRangeSeparator }) } class ia { constructor(e) { this.computeCurrentViewData = tn(this._computeCurrentViewData), this.organizeRawLocales = tn(xs), this.buildLocale = tn(Ts), this.buildPluginHooks = function () { let e, t = [], n = []; return (r, i) => (e && Mt(r, t) && Mt(i, n) || (e = function (e, t) { let n = {}, r = { premiumReleaseDate: void 0, reducers: [], isLoadingFuncs: [], contextInit: [], eventRefiners: {}, eventDefMemberAdders: [], eventSourceRefiners: {}, isDraggableTransformers: [], eventDragMutationMassagers: [], eventDefMutationAppliers: [], dateSelectionTransformers: [], datePointTransforms: [], dateSpanTransforms: [], views: {}, viewPropsTransformers: [], isPropsValid: null, externalDefTransforms: [], viewContainerAppends: [], eventDropTransformers: [], componentInteractions: [], calendarInteractions: [], themeClasses: {}, eventSourceDefs: [], cmdFormatter: null, recurringTypes: [], namedTimeZonedImpl: null, initialView: "", elementDraggingImpl: null, optionChangeHandlers: {}, scrollGridImpl: null, listenerRefiners: {}, optionRefiners: {}, propSetHandlers: {} }; function i(e) { for (let s of e) { const e = s.name, a = n[e]; void 0 === a ? (n[e] = s.id, i(s.deps), o = s, r = { premiumReleaseDate: Ms((t = r).premiumReleaseDate, o.premiumReleaseDate), reducers: t.reducers.concat(o.reducers), isLoadingFuncs: t.isLoadingFuncs.concat(o.isLoadingFuncs), contextInit: t.contextInit.concat(o.contextInit), eventRefiners: Object.assign(Object.assign({}, t.eventRefiners), o.eventRefiners), eventDefMemberAdders: t.eventDefMemberAdders.concat(o.eventDefMemberAdders), eventSourceRefiners: Object.assign(Object.assign({}, t.eventSourceRefiners), o.eventSourceRefiners), isDraggableTransformers: t.isDraggableTransformers.concat(o.isDraggableTransformers), eventDragMutationMassagers: t.eventDragMutationMassagers.concat(o.eventDragMutationMassagers), eventDefMutationAppliers: t.eventDefMutationAppliers.concat(o.eventDefMutationAppliers), dateSelectionTransformers: t.dateSelectionTransformers.concat(o.dateSelectionTransformers), datePointTransforms: t.datePointTransforms.concat(o.datePointTransforms), dateSpanTransforms: t.dateSpanTransforms.concat(o.dateSpanTransforms), views: Object.assign(Object.assign({}, t.views), o.views), viewPropsTransformers: t.viewPropsTransformers.concat(o.viewPropsTransformers), isPropsValid: o.isPropsValid || t.isPropsValid, externalDefTransforms: t.externalDefTransforms.concat(o.externalDefTransforms), viewContainerAppends: t.viewContainerAppends.concat(o.viewContainerAppends), eventDropTransformers: t.eventDropTransformers.concat(o.eventDropTransformers), calendarInteractions: t.calendarInteractions.concat(o.calendarInteractions), componentInteractions: t.componentInteractions.concat(o.componentInteractions), themeClasses: Object.assign(Object.assign({}, t.themeClasses), o.themeClasses), eventSourceDefs: t.eventSourceDefs.concat(o.eventSourceDefs), cmdFormatter: o.cmdFormatter || t.cmdFormatter, recurringTypes: t.recurringTypes.concat(o.recurringTypes), namedTimeZonedImpl: o.namedTimeZonedImpl || t.namedTimeZonedImpl, initialView: t.initialView || o.initialView, elementDraggingImpl: t.elementDraggingImpl || o.elementDraggingImpl, optionChangeHandlers: Object.assign(Object.assign({}, t.optionChangeHandlers), o.optionChangeHandlers), scrollGridImpl: o.scrollGridImpl || t.scrollGridImpl, listenerRefiners: Object.assign(Object.assign({}, t.listenerRefiners), o.listenerRefiners), optionRefiners: Object.assign(Object.assign({}, t.optionRefiners), o.optionRefiners), propSetHandlers: Object.assign(Object.assign({}, t.propSetHandlers), o.propSetHandlers) }) : a !== s.id && console.warn(`Duplicate plugin '${e}'`) } var t, o } return e && i(e), i(t), r }(r, i)), t = r, n = i, e) }(), this.buildDateEnv = tn(oa), this.buildTheme = tn(sa), this.parseToolbars = tn(Xs), this.buildViewSpecs = tn(Bs), this.buildDateProfileGenerator = nn(aa), this.buildViewApi = tn(la), this.buildViewUiProps = nn(ua), this.buildEventUiBySource = tn(da, Dt), this.buildEventUiBases = tn(ca), this.parseContextBusinessHours = nn(fa), this.buildTitle = tn(ra), this.emitter = new Nr, this.actionRunner = new na(this._handleAction.bind(this), this.updateData.bind(this)), this.currentCalendarOptionsInput = {}, this.currentCalendarOptionsRefined = {}, this.currentViewOptionsInput = {}, this.currentViewOptionsRefined = {}, this.currentCalendarOptionsRefiners = {}, this.optionsForRefining = [], this.optionsForHandling = [], this.getCurrentData = () => this.data, this.dispatch = e => { this.actionRunner.request(e) }, this.props = e, this.actionRunner.pause(); let t = {}, n = this.computeOptionsData(e.optionOverrides, t, e.calendarApi), r = n.calendarOptions.initialView || n.pluginHooks.initialView, i = this.computeCurrentViewData(r, n, e.optionOverrides, t); e.calendarApi.currentDataManager = this, this.emitter.setThisContext(e.calendarApi), this.emitter.setOptions(i.options); let o = function (e, t) { let n = e.initialDate; return null != n ? t.createMarker(n) : $r(e.now, t) }(n.calendarOptions, n.dateEnv), s = i.dateProfileGenerator.build(o); yr(s.activeRange, o) || (o = s.currentRange.start); let a = { dateEnv: n.dateEnv, options: n.calendarOptions, pluginHooks: n.pluginHooks, calendarApi: e.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }; for (let e of n.pluginHooks.contextInit) e(a); let l = function (e, t, n) { let r = t ? t.activeRange : null; return zs({}, function (e, t) { let n = Es(t), r = [].concat(e.eventSources || []), i = []; e.initialEvents && r.unshift(e.initialEvents), e.events && r.unshift(e.events); for (let e of r) { let r = bs(e, t, n); r && i.push(r) } return i }(e, n), r, n) }(n.calendarOptions, s, a), d = { dynamicOptionOverrides: t, currentViewType: r, currentDate: o, dateProfile: s, businessHours: this.parseContextBusinessHours(a), eventSources: l, eventUiBases: {}, eventStore: { defs: {}, instances: {} }, renderableEventStore: { defs: {}, instances: {} }, dateSelection: null, eventSelection: "", eventDrag: null, eventResize: null, selectionConfig: this.buildViewUiProps(a).selectionConfig }, c = Object.assign(Object.assign({}, a), d); for (let e of n.pluginHooks.reducers) Object.assign(d, e(null, null, c)); ha(d, a) && this.emitter.trigger("loading", !0), this.state = d, this.updateData(), this.actionRunner.resume() } resetOptions(e, t) { let { props: n } = this; void 0 === t ? n.optionOverrides = e : (n.optionOverrides = Object.assign(Object.assign({}, n.optionOverrides || {}), e), this.optionsForRefining.push(...t)), (void 0 === t || t.length) && this.actionRunner.request({ type: "NOTHING" }) } _handleAction(e) { let { props: t, state: n, emitter: r } = this, i = function (e, t) { return "SET_OPTION" === t.type ? Object.assign(Object.assign({}, e), { [t.optionName]: t.rawOptionValue }) : e }(n.dynamicOptionOverrides, e), o = this.computeOptionsData(t.optionOverrides, i, t.calendarApi), s = function (e, t) { if ("CHANGE_VIEW_TYPE" === t.type) e = t.viewType; return e }(n.currentViewType, e), a = this.computeCurrentViewData(s, o, t.optionOverrides, i); t.calendarApi.currentDataManager = this, r.setThisContext(t.calendarApi), r.setOptions(a.options); let l = { dateEnv: o.dateEnv, options: o.calendarOptions, pluginHooks: o.pluginHooks, calendarApi: t.calendarApi, dispatch: this.dispatch, emitter: r, getCurrentData: this.getCurrentData }, { currentDate: d, dateProfile: c } = n; this.data && this.data.dateProfileGenerator !== a.dateProfileGenerator && (c = a.dateProfileGenerator.build(d)), d = function (e, t) { return "CHANGE_DATE" === t.type ? t.dateMarker : e }(d, e), c = function (e, t, n, r) { let i; switch (t.type) { case "CHANGE_VIEW_TYPE": return r.build(t.dateMarker || n); case "CHANGE_DATE": return r.build(t.dateMarker); case "PREV": if (i = r.buildPrev(e, n), i.isValid) return i; break; case "NEXT": if (i = r.buildNext(e, n), i.isValid) return i }return e }(c, e, d, a.dateProfileGenerator), "PREV" !== e.type && "NEXT" !== e.type && yr(c.currentRange, d) || (d = c.currentRange.start); let u = function (e, t, n, r) { let i = n ? n.activeRange : null; switch (t.type) { case "ADD_EVENT_SOURCES": return zs(e, t.sources, i, r); case "REMOVE_EVENT_SOURCE": return o = e, s = t.sourceId, St(o, (e => e.sourceId !== s)); case "PREV": case "NEXT": case "CHANGE_DATE": case "CHANGE_VIEW_TYPE": return n ? js(e, i, r) : e; case "FETCH_EVENT_SOURCES": return Us(e, t.sourceIds ? wt(t.sourceIds) : Vs(e, r), i, t.isRefetch || !1, r); case "RECEIVE_EVENTS": case "RECEIVE_EVENT_ERROR": return function (e, t, n, r) { let i = e[t]; return i && n === i.latestFetchId ? Object.assign(Object.assign({}, e), { [t]: Object.assign(Object.assign({}, i), { isFetching: !1, fetchRange: r }) }) : e }(e, t.sourceId, t.fetchId, t.fetchRange); case "REMOVE_ALL_EVENT_SOURCES": return {}; default: return e }var o, s }(n.eventSources, e, c, l), h = function (e, t, n, r, i) { switch (t.type) { case "RECEIVE_EVENTS": return function (e, t, n, r, i, o) { if (t && n === t.latestFetchId) { let n = In(vo(i, t, o), t, o); return r && (n = _n(n, r, o)), Hn(Eo(e, t.sourceId), n) } return e }(e, n[t.sourceId], t.fetchId, t.fetchRange, t.rawEvents, i); case "RESET_RAW_EVENTS": return function (e, t, n, r, i) { const { defIdMap: o, instanceIdMap: s } = function (e) { const { defs: t, instances: n } = e, r = {}, i = {}; for (let e in t) { const n = t[e], { publicId: i } = n; i && (r[i] = e) } for (let e in n) { const r = t[n[e].defId], { publicId: o } = r; o && (i[o] = e) } return { defIdMap: r, instanceIdMap: i } }(e); return _n(In(vo(n, t, i), t, i, !1, o, s), r, i) }(e, n[t.sourceId], t.rawEvents, r.activeRange, i); case "ADD_EVENTS": return function (e, t, n, r) { return n && (t = _n(t, n, r)), Hn(e, t) }(e, t.eventStore, r ? r.activeRange : null, i); case "RESET_EVENTS": return t.eventStore; case "MERGE_EVENTS": return Hn(e, t.eventStore); case "PREV": case "NEXT": case "CHANGE_DATE": case "CHANGE_VIEW_TYPE": return r ? _n(e, r.activeRange, i) : e; case "REMOVE_EVENTS": return function (e, t) { let { defs: n, instances: r } = e, i = {}, o = {}; for (let e in n) t.defs[e] || (i[e] = n[e]); for (let e in r) !t.instances[e] && i[r[e].defId] && (o[e] = r[e]); return { defs: i, instances: o } }(e, t.eventStore); case "REMOVE_EVENT_SOURCE": return Eo(e, t.sourceId); case "REMOVE_ALL_EVENT_SOURCES": return Pn(e, (e => !e.sourceId)); case "REMOVE_ALL_EVENTS": return { defs: {}, instances: {} }; default: return e } }(n.eventStore, e, u, c, l), f = Ws(u) && !a.options.progressiveEventRendering && n.renderableEventStore || h, { eventUiSingleBase: g, selectionConfig: p } = this.buildViewUiProps(l), m = this.buildEventUiBySource(u), v = { dynamicOptionOverrides: i, currentViewType: s, currentDate: d, dateProfile: c, eventSources: u, eventStore: h, renderableEventStore: f, selectionConfig: p, eventUiBases: this.buildEventUiBases(f.defs, g, m), businessHours: this.parseContextBusinessHours(l), dateSelection: qs(n.dateSelection, e), eventSelection: Ys(n.eventSelection, e), eventDrag: Qs(n.eventDrag, e), eventResize: Zs(n.eventResize, e) }, y = Object.assign(Object.assign({}, l), v); for (let t of o.pluginHooks.reducers) Object.assign(v, t(n, e, y)); let b = ha(n, l), E = ha(v, l); !b && E ? r.trigger("loading", !0) : b && !E && r.trigger("loading", !1), this.state = v, t.onAction && t.onAction(e) } updateData() { let { props: e, state: t } = this, n = this.data, r = this.computeOptionsData(e.optionOverrides, t.dynamicOptionOverrides, e.calendarApi), i = this.computeCurrentViewData(t.currentViewType, r, e.optionOverrides, t.dynamicOptionOverrides), o = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(t.dateProfile, i.options, r.dateEnv), calendarApi: e.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, r), i), t), s = r.pluginHooks.optionChangeHandlers, a = n && n.calendarOptions, l = r.calendarOptions; if (a && a !== l) { a.timeZone !== l.timeZone && (t.eventSources = o.eventSources = function (e, t, n) { let r = t ? t.activeRange : null; return Us(e, Vs(e, n), r, !0, n) }(o.eventSources, t.dateProfile, o), t.eventStore = o.eventStore = bo(o.eventStore, n.dateEnv, o.dateEnv), t.renderableEventStore = o.renderableEventStore = bo(o.renderableEventStore, n.dateEnv, o.dateEnv)); for (let e in s) -1 === this.optionsForHandling.indexOf(e) && a[e] === l[e] || s[e](l[e], o) } this.optionsForHandling = [], e.onData && e.onData(o) } computeOptionsData(e, t, n) { if (!this.optionsForRefining.length && e === this.stableOptionOverrides && t === this.stableDynamicOptionOverrides) return this.stableCalendarOptionsData; let { refinedOptions: r, pluginHooks: i, localeDefaults: o, availableLocaleData: s, extra: a } = this.processRawCalendarOptions(e, t); ga(a); let l = this.buildDateEnv(r.timeZone, r.locale, r.weekNumberCalculation, r.firstDay, r.weekText, i, s, r.defaultRangeSeparator), d = this.buildViewSpecs(i.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, o), c = this.buildTheme(r, i), u = this.parseToolbars(r, this.stableOptionOverrides, c, d, n); return this.stableCalendarOptionsData = { calendarOptions: r, pluginHooks: i, dateEnv: l, viewSpecs: d, theme: c, toolbarConfig: u, localeDefaults: o, availableRawLocales: s.map } } processRawCalendarOptions(e, t) { let { locales: n, locale: r } = Rn([bn, e, t]), i = this.organizeRawLocales(n), o = i.map, s = this.buildLocale(r || i.defaultCode, o).options, a = this.buildPluginHooks(e.plugins || [], ta), l = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, yn), En), Sn), a.listenerRefiners), a.optionRefiners), d = {}, c = Rn([bn, s, e, t]), u = {}, h = this.currentCalendarOptionsInput, f = this.currentCalendarOptionsRefined, g = !1; for (let e in c) -1 === this.optionsForRefining.indexOf(e) && (c[e] === h[e] || Cn[e] && e in h && Cn[e](h[e], c[e])) ? u[e] = f[e] : l[e] ? (u[e] = l[e](c[e]), g = !0) : d[e] = h[e]; return g && (this.currentCalendarOptionsInput = c, this.currentCalendarOptionsRefined = u, this.stableOptionOverrides = e, this.stableDynamicOptionOverrides = t), this.optionsForHandling.push(...this.optionsForRefining), this.optionsForRefining = [], { rawOptions: this.currentCalendarOptionsInput, refinedOptions: this.currentCalendarOptionsRefined, pluginHooks: a, availableLocaleData: i, localeDefaults: s, extra: d } } _computeCurrentViewData(e, t, n, r) { let i = t.viewSpecs[e]; if (!i) throw new Error(`viewType "${e}" is not available. Please make sure you've loaded all neccessary plugins`); let { refinedOptions: o, extra: s } = this.processRawViewOptions(i, t.pluginHooks, t.localeDefaults, n, r); return ga(s), { viewSpec: i, options: o, dateProfileGenerator: this.buildDateProfileGenerator({ dateProfileGeneratorClass: i.optionDefaults.dateProfileGeneratorClass, duration: i.duration, durationUnit: i.durationUnit, usesMinMaxTime: i.optionDefaults.usesMinMaxTime, dateEnv: t.dateEnv, calendarApi: this.props.calendarApi, slotMinTime: o.slotMinTime, slotMaxTime: o.slotMaxTime, showNonCurrentDates: o.showNonCurrentDates, dayCount: o.dayCount, dateAlignment: o.dateAlignment, dateIncrement: o.dateIncrement, hiddenDays: o.hiddenDays, weekends: o.weekends, nowInput: o.now, validRangeInput: o.validRange, visibleRangeInput: o.visibleRange, fixedWeekCount: o.fixedWeekCount }), viewApi: this.buildViewApi(e, this.getCurrentData, t.dateEnv) } } processRawViewOptions(e, t, n, r, i) { let o = Rn([bn, e.optionDefaults, n, r, e.optionOverrides, i]), s = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, yn), En), Sn), Dn), t.listenerRefiners), t.optionRefiners), a = {}, l = this.currentViewOptionsInput, d = this.currentViewOptionsRefined, c = !1, u = {}; for (let e in o) o[e] === l[e] || Cn[e] && Cn[e](o[e], l[e]) ? a[e] = d[e] : (o[e] === this.currentCalendarOptionsInput[e] || Cn[e] && Cn[e](o[e], this.currentCalendarOptionsInput[e]) ? e in this.currentCalendarOptionsRefined && (a[e] = this.currentCalendarOptionsRefined[e]) : s[e] ? a[e] = s[e](o[e]) : u[e] = o[e], c = !0); return c && (this.currentViewOptionsInput = o, this.currentViewOptionsRefined = a), { rawOptions: this.currentViewOptionsInput, refinedOptions: this.currentViewOptionsRefined, extra: u } } } function oa(e, t, n, r, i, o, s, a) { let l = Ts(t || s.defaultCode, s.map); return new Oi({ calendarSystem: "gregory", timeZone: e, namedTimeZoneImpl: o.namedTimeZonedImpl, locale: l, weekNumberCalculation: n, firstDay: r, weekText: i, cmdFormatter: o.cmdFormatter, defaultSeparator: a }) } function sa(e, t) { return new (t.themeClasses[e.themeSystem] || Is)(e) } function aa(e) { return new (e.dateProfileGeneratorClass || Jr)(e) } function la(e, t, n) { return new Ks(e, t, n) } function da(e) { return Ct(e, (e => e.ui)) } function ca(e, t, n) { let r = { "": t }; for (let t in e) { let i = e[t]; i.sourceId && n[i.sourceId] && (r[t] = n[i.sourceId]) } return r } function ua(e) { let { options: t } = e; return { eventUiSingleBase: zn({ display: t.eventDisplay, editable: t.editable, startEditable: t.eventStartEditable, durationEditable: t.eventDurationEditable, constraint: t.eventConstraint, overlap: "boolean" == typeof t.eventOverlap ? t.eventOverlap : void 0, allow: t.eventAllow, backgroundColor: t.eventBackgroundColor, borderColor: t.eventBorderColor, textColor: t.eventTextColor, color: t.eventColor }, e), selectionConfig: zn({ constraint: t.selectConstraint, overlap: "boolean" == typeof t.selectOverlap ? t.selectOverlap : void 0, allow: t.selectAllow }, e) } } function ha(e, t) { for (let n of t.pluginHooks.isLoadingFuncs) if (n(e)) return !0; return !1 } function fa(e) { return $n(e.options.businessHours, e) } function ga(e, t) { for (let n in e) console.warn(`Unknown option '${n}'` + (t ? ` for view '${t}'` : "")) } class pa extends Qr { render() { return p("div", { className: "fc-toolbar-chunk" }, ...this.props.widgetGroups.map((e => this.renderWidgetGroup(e)))) } renderWidgetGroup(e) { let { props: t } = this, { theme: n } = this.context, r = [], i = !0; for (let o of e) { let { buttonName: e, buttonClick: s, buttonText: a, buttonIcon: l, buttonHint: d } = o; if ("title" === e) i = !1, r.push(p("h2", { className: "fc-toolbar-title", id: t.titleId }, t.title)); else { let i = e === t.activeButton, o = !t.isTodayEnabled && "today" === e || !t.isPrevEnabled && "prev" === e || !t.isNextEnabled && "next" === e, c = [`fc-${e}-button`, n.getClass("button")]; i && c.push(n.getClass("buttonActive")), r.push(p("button", { type: "button", title: "function" == typeof d ? d(t.navUnit) : d, disabled: o, "aria-pressed": i, className: c.join(" "), onClick: s }, a || (l ? p("span", { className: l }) : ""))) } } return r.length > 1 ? p("div", { className: i && n.getClass("buttonGroup") || "" }, ...r) : r[0] } } class ma extends Qr { render() { let e, t, { model: n, extraClassName: r } = this.props, i = !1, o = n.sectionWidgets, s = o.center; return o.left ? (i = !0, e = o.left) : e = o.start, o.right ? (i = !0, t = o.right) : t = o.end, p("div", { className: [r || "", "fc-toolbar", i ? "fc-toolbar-ltr" : ""].join(" ") }, this.renderSection("start", e || []), this.renderSection("center", s || []), this.renderSection("end", t || [])) } renderSection(e, t) { let { props: n } = this; return p(pa, { key: e, widgetGroups: t, title: n.title, navUnit: n.navUnit, activeButton: n.activeButton, isTodayEnabled: n.isTodayEnabled, isPrevEnabled: n.isPrevEnabled, isNextEnabled: n.isNextEnabled, titleId: n.titleId }) } } class va extends Qr { constructor() { super(...arguments), this.state = { availableWidth: null }, this.handleEl = e => { this.el = e, Zr(this.props.elRef, e), this.updateAvailableWidth() }, this.handleResize = () => { this.updateAvailableWidth() } } render() { let { props: e, state: t } = this, { aspectRatio: n } = e, r = ["fc-view-harness", n || e.liquid || e.height ? "fc-view-harness-active" : "fc-view-harness-passive"], i = "", o = ""; return n ? null !== t.availableWidth ? i = t.availableWidth / n : o = 1 / n * 100 + "%" : i = e.height || "", p("div", { "aria-labelledby": e.labeledById, ref: this.handleEl, className: r.join(" "), style: { height: i, paddingBottom: o } }, e.children) } componentDidMount() { this.context.addResizeHandler(this.handleResize) } componentWillUnmount() { this.context.removeResizeHandler(this.handleResize) } updateAvailableWidth() { this.el && this.props.aspectRatio && this.setState({ availableWidth: this.el.offsetWidth }) } } class ya extends ji { constructor(e) { super(e), this.handleSegClick = (e, t) => { let { component: n } = this, { context: r } = n, i = hi(t); if (i && n.isValidSegDownEl(e.target)) { let o = Me(e.target, ".fc-event-forced-url"), s = o ? o.querySelector("a[href]").href : ""; r.emitter.trigger("eventClick", { el: t, event: new si(n.context, i.eventRange.def, i.eventRange.instance), jsEvent: e, view: r.viewApi }), s && !e.defaultPrevented && (window.location.href = s) } }, this.destroy = je(e.el, "click", ".fc-event", this.handleSegClick) } } class ba extends ji { constructor(e) { super(e), this.handleEventElRemove = e => { e === this.currentSegEl && this.handleSegLeave(null, this.currentSegEl) }, this.handleSegEnter = (e, t) => { hi(t) && (this.currentSegEl = t, this.triggerEvent("eventMouseEnter", e, t)) }, this.handleSegLeave = (e, t) => { this.currentSegEl && (this.currentSegEl = null, this.triggerEvent("eventMouseLeave", e, t)) }, this.removeHoverListeners = function (e, t, n, r) { let i; return je(e, "mouseover", ".fc-event", ((e, t) => { if (t !== i) { i = t, n(e, t); let o = e => { i = null, r(e, t), t.removeEventListener("mouseleave", o) }; t.addEventListener("mouseleave", o) } })) }(e.el, 0, this.handleSegEnter, this.handleSegLeave) } destroy() { this.removeHoverListeners() } triggerEvent(e, t, n) { let { component: r } = this, { context: i } = r, o = hi(n); t && !r.isValidSegDownEl(t.target) || i.emitter.trigger(e, { el: n, event: new si(i, o.eventRange.def, o.eventRange.instance), jsEvent: t, view: i.viewApi }) } } class Ea extends Yr { constructor() { super(...arguments), this.buildViewContext = tn(qr), this.buildViewPropTransformers = tn(Ca), this.buildToolbarProps = tn(Sa), this.headerRef = { current: null }, this.footerRef = { current: null }, this.interactionsStore = {}, this.state = { viewLabelId: We() }, this.registerInteractiveComponent = (e, t) => { let n = function (e, t) { return { component: e, el: t.el, useEventCenter: null == t.useEventCenter || t.useEventCenter, isHitComboAllowed: t.isHitComboAllowed || null } }(e, t), r = [ya, ba].concat(this.props.pluginHooks.componentInteractions).map((e => new e(n))); this.interactionsStore[e.uid] = r, Fi[e.uid] = n }, this.unregisterInteractiveComponent = e => { let t = this.interactionsStore[e.uid]; if (t) { for (let e of t) e.destroy(); delete this.interactionsStore[e.uid] } delete Fi[e.uid] }, this.resizeRunner = new Mo((() => { this.props.emitter.trigger("_resize", !0), this.props.emitter.trigger("windowResize", { view: this.props.viewApi }) })), this.handleWindowResize = e => { let { options: t } = this.props; t.handleWindowResize && e.target === window && this.resizeRunner.request(t.windowResizeDelay) } } render() { let e, { props: t } = this, { toolbarConfig: n, options: r } = t, i = this.buildToolbarProps(t.viewSpec, t.dateProfile, t.dateProfileGenerator, t.currentDate, $r(t.options.now, t.dateEnv), t.viewTitle), o = !1, s = ""; t.isHeightAuto || t.forPrint ? s = "" : null != r.height ? o = !0 : null != r.contentHeight ? s = r.contentHeight : e = Math.max(r.aspectRatio, .5); let a = this.buildViewContext(t.viewSpec, t.viewApi, t.options, t.dateProfileGenerator, t.dateEnv, t.theme, t.pluginHooks, t.dispatch, t.getCurrentData, t.emitter, t.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent), l = n.header && n.header.hasTitle ? this.state.viewLabelId : ""; return p(Gr.Provider, { value: a }, n.header && p(ma, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: n.header, titleId: l }, i)), p(va, { liquid: o, height: s, aspectRatio: e, labeledById: l }, this.renderView(t), this.buildAppendContent()), n.footer && p(ma, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: n.footer, titleId: "" }, i))) } componentDidMount() { let { props: e } = this; this.calendarInteractions = e.pluginHooks.calendarInteractions.map((t => new t(e))), window.addEventListener("resize", this.handleWindowResize); let { propSetHandlers: t } = e.pluginHooks; for (let n in t) t[n](e[n], e) } componentDidUpdate(e) { let { props: t } = this, { propSetHandlers: n } = t.pluginHooks; for (let r in n) t[r] !== e[r] && n[r](t[r], t) } componentWillUnmount() { window.removeEventListener("resize", this.handleWindowResize), this.resizeRunner.clear(); for (let e of this.calendarInteractions) e.destroy(); this.props.emitter.trigger("_unmount") } buildAppendContent() { let { props: e } = this; return p(v, {}, ...e.pluginHooks.viewContainerAppends.map((t => t(e)))) } renderView(e) { let { pluginHooks: t } = e, { viewSpec: n } = e, r = { dateProfile: e.dateProfile, businessHours: e.businessHours, eventStore: e.renderableEventStore, eventUiBases: e.eventUiBases, dateSelection: e.dateSelection, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, isHeightAuto: e.isHeightAuto, forPrint: e.forPrint }, i = this.buildViewPropTransformers(t.viewPropsTransformers); for (let t of i) Object.assign(r, t.transform(r, e)); return p(n.component, Object.assign({}, r)) } } function Sa(e, t, n, r, i, o) { let s = n.build(i, void 0, !1), a = n.buildPrev(t, r, !1), l = n.buildNext(t, r, !1); return { title: o, activeButton: e.type, navUnit: e.singleUnit, isTodayEnabled: s.isValid && !yr(t.currentRange, i), isPrevEnabled: a.isValid, isNextEnabled: l.isValid } } function Ca(e) { return e.map((e => new e)) } function wa(e) { let t = Ts(e.locale || "en", xs([]).map); return new Oi(Object.assign(Object.assign({ timeZone: bn.timeZone, calendarSystem: "gregory" }, e), { locale: t })) } Gi.touchMouseIgnoreWait = 500; let Aa = 0, Da = 0, Ra = !1; class xa { constructor(e) { this.subjectEl = null, this.selector = "", this.handleSelector = "", this.shouldIgnoreMove = !1, this.shouldWatchScroll = !0, this.isDragging = !1, this.isTouchDragging = !1, this.wasTouchScroll = !1, this.handleMouseDown = e => { if (!this.shouldIgnoreMouse() && function (e) { return 0 === e.button && !e.ctrlKey }(e) && this.tryStart(e)) { let t = this.createEventFromMouse(e, !0); this.emitter.trigger("pointerdown", t), this.initScrollWatch(t), this.shouldIgnoreMove || document.addEventListener("mousemove", this.handleMouseMove), document.addEventListener("mouseup", this.handleMouseUp) } }, this.handleMouseMove = e => { let t = this.createEventFromMouse(e); this.recordCoords(t), this.emitter.trigger("pointermove", t) }, this.handleMouseUp = e => { document.removeEventListener("mousemove", this.handleMouseMove), document.removeEventListener("mouseup", this.handleMouseUp), this.emitter.trigger("pointerup", this.createEventFromMouse(e)), this.cleanup() }, this.handleTouchStart = e => { if (this.tryStart(e)) { this.isTouchDragging = !0; let t = this.createEventFromTouch(e, !0); this.emitter.trigger("pointerdown", t), this.initScrollWatch(t); let n = e.target; this.shouldIgnoreMove || n.addEventListener("touchmove", this.handleTouchMove), n.addEventListener("touchend", this.handleTouchEnd), n.addEventListener("touchcancel", this.handleTouchEnd), window.addEventListener("scroll", this.handleTouchScroll, !0) } }, this.handleTouchMove = e => { let t = this.createEventFromTouch(e); this.recordCoords(t), this.emitter.trigger("pointermove", t) }, this.handleTouchEnd = e => { if (this.isDragging) { let t = e.target; t.removeEventListener("touchmove", this.handleTouchMove), t.removeEventListener("touchend", this.handleTouchEnd), t.removeEventListener("touchcancel", this.handleTouchEnd), window.removeEventListener("scroll", this.handleTouchScroll, !0), this.emitter.trigger("pointerup", this.createEventFromTouch(e)), this.cleanup(), this.isTouchDragging = !1, Aa += 1, setTimeout((() => { Aa -= 1 }), Gi.touchMouseIgnoreWait) } }, this.handleTouchScroll = () => { this.wasTouchScroll = !0 }, this.handleScroll = e => { if (!this.shouldIgnoreMove) { let t = window.pageXOffset - this.prevScrollX + this.prevPageX, n = window.pageYOffset - this.prevScrollY + this.prevPageY; this.emitter.trigger("pointermove", { origEvent: e, isTouch: this.isTouchDragging, subjectEl: this.subjectEl, pageX: t, pageY: n, deltaX: t - this.origPageX, deltaY: n - this.origPageY }) } }, this.containerEl = e, this.emitter = new Nr, e.addEventListener("mousedown", this.handleMouseDown), e.addEventListener("touchstart", this.handleTouchStart, { passive: !0 }), Da += 1, 1 === Da && window.addEventListener("touchmove", Ta, { passive: !1 }) } destroy() { this.containerEl.removeEventListener("mousedown", this.handleMouseDown), this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: !0 }), Da -= 1, Da || window.removeEventListener("touchmove", Ta, { passive: !1 }) } tryStart(e) { let t = this.querySubjectEl(e), n = e.target; return !(!t || this.handleSelector && !Me(n, this.handleSelector) || (this.subjectEl = t, this.isDragging = !0, this.wasTouchScroll = !1, 0)) } cleanup() { Ra = !1, this.isDragging = !1, this.subjectEl = null, this.destroyScrollWatch() } querySubjectEl(e) { return this.selector ? Me(e.target, this.selector) : this.containerEl } shouldIgnoreMouse() { return Aa || this.isTouchDragging } cancelTouchScroll() { this.isDragging && (Ra = !0) } initScrollWatch(e) { this.shouldWatchScroll && (this.recordCoords(e), window.addEventListener("scroll", this.handleScroll, !0)) } recordCoords(e) { this.shouldWatchScroll && (this.prevPageX = e.pageX, this.prevPageY = e.pageY, this.prevScrollX = window.pageXOffset, this.prevScrollY = window.pageYOffset) } destroyScrollWatch() { this.shouldWatchScroll && window.removeEventListener("scroll", this.handleScroll, !0) } createEventFromMouse(e, t) { let n = 0, r = 0; return t ? (this.origPageX = e.pageX, this.origPageY = e.pageY) : (n = e.pageX - this.origPageX, r = e.pageY - this.origPageY), { origEvent: e, isTouch: !1, subjectEl: this.subjectEl, pageX: e.pageX, pageY: e.pageY, deltaX: n, deltaY: r } } createEventFromTouch(e, t) { let n, r, i = e.touches, o = 0, s = 0; return i && i.length ? (n = i[0].pageX, r = i[0].pageY) : (n = e.pageX, r = e.pageY), t ? (this.origPageX = n, this.origPageY = r) : (o = n - this.origPageX, s = r - this.origPageY), { origEvent: e, isTouch: !0, subjectEl: this.subjectEl, pageX: n, pageY: r, deltaX: o, deltaY: s } } } function Ta(e) { Ra && e.preventDefault() } class ka { constructor() { this.isVisible = !1, this.sourceEl = null, this.mirrorEl = null, this.sourceElRect = null, this.parentNode = document.body, this.zIndex = 9999, this.revertDuration = 0 } start(e, t, n) { this.sourceEl = e, this.sourceElRect = this.sourceEl.getBoundingClientRect(), this.origScreenX = t - window.pageXOffset, this.origScreenY = n - window.pageYOffset, this.deltaX = 0, this.deltaY = 0, this.updateElPosition() } handleMove(e, t) { this.deltaX = e - window.pageXOffset - this.origScreenX, this.deltaY = t - window.pageYOffset - this.origScreenY, this.updateElPosition() } setIsVisible(e) { e ? this.isVisible || (this.mirrorEl && (this.mirrorEl.style.display = ""), this.isVisible = e, this.updateElPosition()) : this.isVisible && (this.mirrorEl && (this.mirrorEl.style.display = "none"), this.isVisible = e) } stop(e, t) { let n = () => { this.cleanup(), t() }; e && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) ? this.doRevertAnimation(n, this.revertDuration) : setTimeout(n, 0) } doRevertAnimation(e, t) { let n = this.mirrorEl, r = this.sourceEl.getBoundingClientRect(); n.style.transition = "top " + t + "ms,left " + t + "ms", He(n, { left: r.left, top: r.top }), Fe(n, (() => { n.style.transition = "", e() })) } cleanup() { this.mirrorEl && (_e(this.mirrorEl), this.mirrorEl = null), this.sourceEl = null } updateElPosition() { this.sourceEl && this.isVisible && He(this.getMirrorEl(), { left: this.sourceElRect.left + this.deltaX, top: this.sourceElRect.top + this.deltaY }) } getMirrorEl() { let e = this.sourceElRect, t = this.mirrorEl; return t || (t = this.mirrorEl = this.sourceEl.cloneNode(!0), t.style.userSelect = "none", t.classList.add("fc-event-dragging"), He(t, { position: "fixed", zIndex: this.zIndex, visibility: "", boxSizing: "border-box", width: e.right - e.left, height: e.bottom - e.top, right: "auto", bottom: "auto", margin: 0 }), this.parentNode.appendChild(t)), t } } class _a extends Br { constructor(e, t) { super(), this.handleScroll = () => { this.scrollTop = this.scrollController.getScrollTop(), this.scrollLeft = this.scrollController.getScrollLeft(), this.handleScrollChange() }, this.scrollController = e, this.doesListening = t, this.scrollTop = this.origScrollTop = e.getScrollTop(), this.scrollLeft = this.origScrollLeft = e.getScrollLeft(), this.scrollWidth = e.getScrollWidth(), this.scrollHeight = e.getScrollHeight(), this.clientWidth = e.getClientWidth(), this.clientHeight = e.getClientHeight(), this.clientRect = this.computeClientRect(), this.doesListening && this.getEventTarget().addEventListener("scroll", this.handleScroll) } destroy() { this.doesListening && this.getEventTarget().removeEventListener("scroll", this.handleScroll) } getScrollTop() { return this.scrollTop } getScrollLeft() { return this.scrollLeft } setScrollTop(e) { this.scrollController.setScrollTop(e), this.doesListening || (this.scrollTop = Math.max(Math.min(e, this.getMaxScrollTop()), 0), this.handleScrollChange()) } setScrollLeft(e) { this.scrollController.setScrollLeft(e), this.doesListening || (this.scrollLeft = Math.max(Math.min(e, this.getMaxScrollLeft()), 0), this.handleScrollChange()) } getClientWidth() { return this.clientWidth } getClientHeight() { return this.clientHeight } getScrollWidth() { return this.scrollWidth } getScrollHeight() { return this.scrollHeight } handleScrollChange() { } } class Ma extends _a { constructor(e, t) { super(new Lr(e), t) } getEventTarget() { return this.scrollController.el } computeClientRect() { return _r(this.scrollController.el) } } class Ia extends _a { constructor(e) { super(new Wr, e) } getEventTarget() { return window } computeClientRect() { return { left: this.scrollLeft, right: this.scrollLeft + this.clientWidth, top: this.scrollTop, bottom: this.scrollTop + this.clientHeight } } handleScrollChange() { this.clientRect = this.computeClientRect() } } const Oa = "function" == typeof performance ? performance.now : Date.now; class Na { constructor() { this.isEnabled = !0, this.scrollQuery = [window, ".fc-scroller"], this.edgeThreshold = 50, this.maxVelocity = 300, this.pointerScreenX = null, this.pointerScreenY = null, this.isAnimating = !1, this.scrollCaches = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.animate = () => { if (this.isAnimating) { let e = this.computeBestEdge(this.pointerScreenX + window.pageXOffset, this.pointerScreenY + window.pageYOffset); if (e) { let t = Oa(); this.handleSide(e, (t - this.msSinceRequest) / 1e3), this.requestAnimation(t) } else this.isAnimating = !1 } } } start(e, t, n) { this.isEnabled && (this.scrollCaches = this.buildCaches(n), this.pointerScreenX = null, this.pointerScreenY = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.handleMove(e, t)) } handleMove(e, t) { if (this.isEnabled) { let n = e - window.pageXOffset, r = t - window.pageYOffset, i = null === this.pointerScreenY ? 0 : r - this.pointerScreenY, o = null === this.pointerScreenX ? 0 : n - this.pointerScreenX; i < 0 ? this.everMovedUp = !0 : i > 0 && (this.everMovedDown = !0), o < 0 ? this.everMovedLeft = !0 : o > 0 && (this.everMovedRight = !0), this.pointerScreenX = n, this.pointerScreenY = r, this.isAnimating || (this.isAnimating = !0, this.requestAnimation(Oa())) } } stop() { if (this.isEnabled) { this.isAnimating = !1; for (let e of this.scrollCaches) e.destroy(); this.scrollCaches = null } } requestAnimation(e) { this.msSinceRequest = e, requestAnimationFrame(this.animate) } handleSide(e, t) { let { scrollCache: n } = e, { edgeThreshold: r } = this, i = r - e.distance, o = i * i / (r * r) * this.maxVelocity * t, s = 1; switch (e.name) { case "left": s = -1; case "right": n.setScrollLeft(n.getScrollLeft() + o * s); break; case "top": s = -1; case "bottom": n.setScrollTop(n.getScrollTop() + o * s) } } computeBestEdge(e, t) { let { edgeThreshold: n } = this, r = null, i = this.scrollCaches || []; for (let o of i) { let i = o.clientRect, s = e - i.left, a = i.right - e, l = t - i.top, d = i.bottom - t; s >= 0 && a >= 0 && l >= 0 && d >= 0 && (l <= n && this.everMovedUp && o.canScrollUp() && (!r || r.distance > l) && (r = { scrollCache: o, name: "top", distance: l }), d <= n && this.everMovedDown && o.canScrollDown() && (!r || r.distance > d) && (r = { scrollCache: o, name: "bottom", distance: d }), s <= n && this.everMovedLeft && o.canScrollLeft() && (!r || r.distance > s) && (r = { scrollCache: o, name: "left", distance: s }), a <= n && this.everMovedRight && o.canScrollRight() && (!r || r.distance > a) && (r = { scrollCache: o, name: "right", distance: a })) } return r } buildCaches(e) { return this.queryScrollEls(e).map((e => e === window ? new Ia(!1) : new Ma(e, !1))) } queryScrollEls(e) { let t = []; for (let n of this.scrollQuery) "object" == typeof n ? t.push(n) : t.push(...Array.prototype.slice.call(e.getRootNode().querySelectorAll(n))); return t } } class Ha extends Vi { constructor(e, t) { super(e), this.containerEl = e, this.delay = null, this.minDistance = 0, this.touchScrollAllowed = !0, this.mirrorNeedsRevert = !1, this.isInteracting = !1, this.isDragging = !1, this.isDelayEnded = !1, this.isDistanceSurpassed = !1, this.delayTimeoutId = null, this.onPointerDown = e => { this.isDragging || (this.isInteracting = !0, this.isDelayEnded = !1, this.isDistanceSurpassed = !1, Xe(document.body), Je(document.body), e.isTouch || e.origEvent.preventDefault(), this.emitter.trigger("pointerdown", e), this.isInteracting && !this.pointer.shouldIgnoreMove && (this.mirror.setIsVisible(!1), this.mirror.start(e.subjectEl, e.pageX, e.pageY), this.startDelay(e), this.minDistance || this.handleDistanceSurpassed(e))) }, this.onPointerMove = e => { if (this.isInteracting) { if (this.emitter.trigger("pointermove", e), !this.isDistanceSurpassed) { let t, n = this.minDistance, { deltaX: r, deltaY: i } = e; t = r * r + i * i, t >= n * n && this.handleDistanceSurpassed(e) } this.isDragging && ("scroll" !== e.origEvent.type && (this.mirror.handleMove(e.pageX, e.pageY), this.autoScroller.handleMove(e.pageX, e.pageY)), this.emitter.trigger("dragmove", e)) } }, this.onPointerUp = e => { this.isInteracting && (this.isInteracting = !1, $e(document.body), Ke(document.body), this.emitter.trigger("pointerup", e), this.isDragging && (this.autoScroller.stop(), this.tryStopDrag(e)), this.delayTimeoutId && (clearTimeout(this.delayTimeoutId), this.delayTimeoutId = null)) }; let n = this.pointer = new xa(e); n.emitter.on("pointerdown", this.onPointerDown), n.emitter.on("pointermove", this.onPointerMove), n.emitter.on("pointerup", this.onPointerUp), t && (n.selector = t), this.mirror = new ka, this.autoScroller = new Na } destroy() { this.pointer.destroy(), this.onPointerUp({}) } startDelay(e) { "number" == typeof this.delay ? this.delayTimeoutId = setTimeout((() => { this.delayTimeoutId = null, this.handleDelayEnd(e) }), this.delay) : this.handleDelayEnd(e) } handleDelayEnd(e) { this.isDelayEnded = !0, this.tryStartDrag(e) } handleDistanceSurpassed(e) { this.isDistanceSurpassed = !0, this.tryStartDrag(e) } tryStartDrag(e) { this.isDelayEnded && this.isDistanceSurpassed && (this.pointer.wasTouchScroll && !this.touchScrollAllowed || (this.isDragging = !0, this.mirrorNeedsRevert = !1, this.autoScroller.start(e.pageX, e.pageY, this.containerEl), this.emitter.trigger("dragstart", e), !1 === this.touchScrollAllowed && this.pointer.cancelTouchScroll())) } tryStopDrag(e) { this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, e)) } stopDrag(e) { this.isDragging = !1, this.emitter.trigger("dragend", e) } setIgnoreMove(e) { this.pointer.shouldIgnoreMove = e } setMirrorIsVisible(e) { this.mirror.setIsVisible(e) } setMirrorNeedsRevert(e) { this.mirrorNeedsRevert = e } setAutoScrollEnabled(e) { this.autoScroller.isEnabled = e } } class Pa { constructor(e) { this.origRect = Mr(e), this.scrollCaches = Ir(e).map((e => new Ma(e, !0))) } destroy() { for (let e of this.scrollCaches) e.destroy() } computeLeft() { let e = this.origRect.left; for (let t of this.scrollCaches) e += t.origScrollLeft - t.getScrollLeft(); return e } computeTop() { let e = this.origRect.top; for (let t of this.scrollCaches) e += t.origScrollTop - t.getScrollTop(); return e } isWithinClipping(e, t) { let n = { left: e, top: t }; for (let e of this.scrollCaches) if (!Ba(e.getEventTarget()) && !nr(n, e.clientRect)) return !1; return !0 } } function Ba(e) { let t = e.tagName; return "HTML" === t || "BODY" === t } class La { constructor(e, t) { this.useSubjectCenter = !1, this.requireInitial = !0, this.initialHit = null, this.movingHit = null, this.finalHit = null, this.handlePointerDown = e => { let { dragging: t } = this; this.initialHit = null, this.movingHit = null, this.finalHit = null, this.prepareHits(), this.processFirstCoord(e), this.initialHit || !this.requireInitial ? (t.setIgnoreMove(!1), this.emitter.trigger("pointerdown", e)) : t.setIgnoreMove(!0) }, this.handleDragStart = e => { this.emitter.trigger("dragstart", e), this.handleMove(e, !0) }, this.handleDragMove = e => { this.emitter.trigger("dragmove", e), this.handleMove(e) }, this.handlePointerUp = e => { this.releaseHits(), this.emitter.trigger("pointerup", e) }, this.handleDragEnd = e => { this.movingHit && this.emitter.trigger("hitupdate", null, !0, e), this.finalHit = this.movingHit, this.movingHit = null, this.emitter.trigger("dragend", e) }, this.droppableStore = t, e.emitter.on("pointerdown", this.handlePointerDown), e.emitter.on("dragstart", this.handleDragStart), e.emitter.on("dragmove", this.handleDragMove), e.emitter.on("pointerup", this.handlePointerUp), e.emitter.on("dragend", this.handleDragEnd), this.dragging = e, this.emitter = new Nr } processFirstCoord(e) { let t, n = { left: e.pageX, top: e.pageY }, r = n, i = e.subjectEl; i instanceof HTMLElement && (t = Mr(i), r = ir(r, t)); let o = this.initialHit = this.queryHitForOffset(r.left, r.top); if (o) { if (this.useSubjectCenter && t) { let e = rr(t, o.rect); e && (r = or(e)) } this.coordAdjust = sr(r, n) } else this.coordAdjust = { left: 0, top: 0 } } handleMove(e, t) { let n = this.queryHitForOffset(e.pageX + this.coordAdjust.left, e.pageY + this.coordAdjust.top); !t && Wa(this.movingHit, n) || (this.movingHit = n, this.emitter.trigger("hitupdate", n, !1, e)) } prepareHits() { this.offsetTrackers = Ct(this.droppableStore, (e => (e.component.prepareHits(), new Pa(e.el)))) } releaseHits() { let { offsetTrackers: e } = this; for (let t in e) e[t].destroy(); this.offsetTrackers = {} } queryHitForOffset(e, t) { let { droppableStore: n, offsetTrackers: r } = this, i = null; for (let o in n) { let s = n[o].component, a = r[o]; if (a && a.isWithinClipping(e, t)) { let n = a.computeLeft(), r = a.computeTop(), l = e - n, d = t - r, { origRect: c } = a, u = c.right - c.left, h = c.bottom - c.top; if (l >= 0 && l < u && d >= 0 && d < h) { let e = s.queryHit(l, d, u, h); e && vr(e.dateProfile.activeRange, e.dateSpan.range) && (!i || e.layer > i.layer) && (e.componentId = o, e.context = s.context, e.rect.left += n, e.rect.right += n, e.rect.top += r, e.rect.bottom += r, i = e) } } } return i } } function Wa(e, t) { return !e && !t || Boolean(e) === Boolean(t) && Ri(e.dateSpan, t.dateSpan) } function za(e, t) { let n = {}; for (let r of t.pluginHooks.datePointTransforms) Object.assign(n, r(e, t)); var r, i; return Object.assign(n, (r = e, { date: (i = t.dateEnv).toDate(r.range.start), dateStr: i.formatIso(r.range.start, { omitTime: r.allDay }), allDay: r.allDay })), n } class ja extends ji { constructor(e) { super(e), this.subjectEl = null, this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingContext = null, this.validMutation = null, this.mutatedRelevantEvents = null, this.handlePointerDown = e => { let t = e.origEvent.target, { component: n, dragging: r } = this, { mirror: i } = r, { options: o } = n.context, s = n.context; this.subjectEl = e.subjectEl; let a = this.subjectSeg = hi(e.subjectEl), l = (this.eventRange = a.eventRange).instance.instanceId; this.relevantEvents = Nn(s.getCurrentData().eventStore, l), r.minDistance = e.isTouch ? 0 : o.eventDragMinDistance, r.delay = e.isTouch && l !== n.props.eventSelection ? function (e) { let { options: t } = e.context, n = t.eventLongPressDelay; return null == n && (n = t.longPressDelay), n }(n) : null, o.fixedMirrorParent ? i.parentNode = o.fixedMirrorParent : i.parentNode = Me(t, ".fc"), i.revertDuration = o.dragRevertDuration; let d = n.isValidSegDownEl(t) && !Me(t, ".fc-event-resizer"); r.setIgnoreMove(!d), this.isDragging = d && e.subjectEl.classList.contains("fc-event-draggable") }, this.handleDragStart = e => { let t = this.component.context, n = this.eventRange, r = n.instance.instanceId; e.isTouch ? r !== this.component.props.eventSelection && t.dispatch({ type: "SELECT_EVENT", eventInstanceId: r }) : t.dispatch({ type: "UNSELECT_EVENT" }), this.isDragging && (t.calendarApi.unselect(e), t.emitter.trigger("eventDragStart", { el: this.subjectEl, event: new si(t, n.def, n.instance), jsEvent: e.origEvent, view: t.viewApi })) }, this.handleHitUpdate = (e, t) => { if (!this.isDragging) return; let n = this.relevantEvents, r = this.hitDragging.initialHit, i = this.component.context, o = null, s = null, a = null, l = !1, d = { affectedEvents: n, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 }; if (e) { o = e.context; let t = o.options; i === o || t.editable && t.droppable ? (s = function (e, t, n) { let r = e.dateSpan, i = t.dateSpan, o = r.range.start, s = i.range.start, a = {}; r.allDay !== i.allDay && (a.allDay = i.allDay, a.hasEnd = t.context.options.allDayMaintainDuration, i.allDay && (o = jt(o))); let l = tr(o, s, e.context.dateEnv, e.componentId === t.componentId ? e.largeUnit : null); l.milliseconds && (a.allDay = !1); let d = { datesDelta: l, standardProps: a }; for (let r of n) r(d, e, t); return d }(r, e, o.getCurrentData().pluginHooks.eventDragMutationMassagers), s && (a = ni(n, o.getCurrentData().eventUiBases, s, o), d.mutatedEvents = a, So(d, e.dateProfile, o) || (l = !0, s = null, a = null, d.mutatedEvents = { defs: {}, instances: {} }))) : o = null } this.displayDrag(o, d), l ? Qe() : Ze(), t || (i === o && Wa(r, e) && (s = null), this.dragging.setMirrorNeedsRevert(!s), this.dragging.setMirrorIsVisible(!e || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror")), this.receivingContext = o, this.validMutation = s, this.mutatedRelevantEvents = a) }, this.handlePointerUp = () => { this.isDragging || this.cleanup() }, this.handleDragEnd = e => { if (this.isDragging) { let t = this.component.context, n = t.viewApi, { receivingContext: r, validMutation: i } = this, o = this.eventRange.def, s = this.eventRange.instance, a = new si(t, o, s), l = this.relevantEvents, d = this.mutatedRelevantEvents, { finalHit: c } = this.hitDragging; if (this.clearDrag(), t.emitter.trigger("eventDragStop", { el: this.subjectEl, event: a, jsEvent: e.origEvent, view: n }), i) { if (r === t) { let r = new si(t, d.defs[o.defId], s ? d.instances[s.instanceId] : null); t.dispatch({ type: "MERGE_EVENTS", eventStore: d }); let c = { oldEvent: a, event: r, relatedEvents: li(d, t, s), revert() { t.dispatch({ type: "MERGE_EVENTS", eventStore: l }) } }, u = {}; for (let e of t.getCurrentData().pluginHooks.eventDropTransformers) Object.assign(u, e(i, t)); t.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, c), u), { el: e.subjectEl, delta: i.datesDelta, jsEvent: e.origEvent, view: n })), t.emitter.trigger("eventChange", c) } else if (r) { let i = { event: a, relatedEvents: li(l, t, s), revert() { t.dispatch({ type: "MERGE_EVENTS", eventStore: l }) } }; t.emitter.trigger("eventLeave", Object.assign(Object.assign({}, i), { draggedEl: e.subjectEl, view: n })), t.dispatch({ type: "REMOVE_EVENTS", eventStore: l }), t.emitter.trigger("eventRemove", i); let u = d.defs[o.defId], h = d.instances[s.instanceId], f = new si(r, u, h); r.dispatch({ type: "MERGE_EVENTS", eventStore: d }); let g = { event: f, relatedEvents: li(d, r, h), revert() { r.dispatch({ type: "REMOVE_EVENTS", eventStore: d }) } }; r.emitter.trigger("eventAdd", g), e.isTouch && r.dispatch({ type: "SELECT_EVENT", eventInstanceId: s.instanceId }), r.emitter.trigger("drop", Object.assign(Object.assign({}, za(c.dateSpan, r)), { draggedEl: e.subjectEl, jsEvent: e.origEvent, view: c.context.viewApi })), r.emitter.trigger("eventReceive", Object.assign(Object.assign({}, g), { draggedEl: e.subjectEl, view: c.context.viewApi })) } } else t.emitter.trigger("_noEventDrop") } this.cleanup() }; let { component: t } = this, { options: n } = t.context, r = this.dragging = new Ha(e.el); r.pointer.selector = ja.SELECTOR, r.touchScrollAllowed = !1, r.autoScroller.isEnabled = n.dragScroll; let i = this.hitDragging = new La(this.dragging, Fi); i.useSubjectCenter = e.useEventCenter, i.emitter.on("pointerdown", this.handlePointerDown), i.emitter.on("dragstart", this.handleDragStart), i.emitter.on("hitupdate", this.handleHitUpdate), i.emitter.on("pointerup", this.handlePointerUp), i.emitter.on("dragend", this.handleDragEnd) } destroy() { this.dragging.destroy() } displayDrag(e, t) { let n = this.component.context, r = this.receivingContext; r && r !== e && (r === n ? r.dispatch({ type: "SET_EVENT_DRAG", state: { affectedEvents: t.affectedEvents, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 } }) : r.dispatch({ type: "UNSET_EVENT_DRAG" })), e && e.dispatch({ type: "SET_EVENT_DRAG", state: t }) } clearDrag() { let e = this.component.context, { receivingContext: t } = this; t && t.dispatch({ type: "UNSET_EVENT_DRAG" }), e !== t && e.dispatch({ type: "UNSET_EVENT_DRAG" }) } cleanup() { this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingContext = null, this.validMutation = null, this.mutatedRelevantEvents = null } } ja.SELECTOR = ".fc-event-draggable, .fc-event-resizable"; const Ua = { fixedMirrorParent: Tn }, Fa = { dateClick: Tn, eventDragStart: Tn, eventDragStop: Tn, eventDrop: Tn, eventResizeStart: Tn, eventResizeStop: Tn, eventResize: Tn, drop: Tn, eventReceive: Tn, eventLeave: Tn }; class Va { constructor(e, t) { this.receivingContext = null, this.droppableEvent = null, this.suppliedDragMeta = null, this.dragMeta = null, this.handleDragStart = e => { this.dragMeta = this.buildDragMeta(e.subjectEl) }, this.handleHitUpdate = (e, t, n) => { let { dragging: r } = this.hitDragging, i = null, o = null, s = !1, a = { affectedEvents: { defs: {}, instances: {} }, mutatedEvents: { defs: {}, instances: {} }, isEvent: this.dragMeta.create }; e && (i = e.context, this.canDropElOnCalendar(n.subjectEl, i) && (o = function (e, t, n) { let r = Object.assign({}, t.leftoverProps); for (let i of n.pluginHooks.externalDefTransforms) Object.assign(r, i(e, t)); let { refined: i, extra: o } = Yn(r, n), s = Zn(i, o, t.sourceId, e.allDay, n.options.forceEventDuration || Boolean(t.duration), n), a = e.range.start; e.allDay && t.startTime && (a = n.dateEnv.add(a, t.startTime)); let l = t.duration ? n.dateEnv.add(a, t.duration) : ti(e.allDay, a, n); return { def: s, instance: kn(s.defId, { start: a, end: l }) } }(e.dateSpan, this.dragMeta, i), a.mutatedEvents = On(o), s = !So(a, e.dateProfile, i), s && (a.mutatedEvents = { defs: {}, instances: {} }, o = null))), this.displayDrag(i, a), r.setMirrorIsVisible(t || !o || !document.querySelector(".fc-event-mirror")), s ? Qe() : Ze(), t || (r.setMirrorNeedsRevert(!o), this.receivingContext = i, this.droppableEvent = o) }, this.handleDragEnd = e => { let { receivingContext: t, droppableEvent: n } = this; if (this.clearDrag(), t && n) { let r = this.hitDragging.finalHit, i = r.context.viewApi, o = this.dragMeta; if (t.emitter.trigger("drop", Object.assign(Object.assign({}, za(r.dateSpan, t)), { draggedEl: e.subjectEl, jsEvent: e.origEvent, view: i })), o.create) { let r = On(n); t.dispatch({ type: "MERGE_EVENTS", eventStore: r }), e.isTouch && t.dispatch({ type: "SELECT_EVENT", eventInstanceId: n.instance.instanceId }), t.emitter.trigger("eventReceive", { event: new si(t, n.def, n.instance), relatedEvents: [], revert() { t.dispatch({ type: "REMOVE_EVENTS", eventStore: r }) }, draggedEl: e.subjectEl, view: i }) } } this.receivingContext = null, this.droppableEvent = null }; let n = this.hitDragging = new La(e, Fi); n.requireInitial = !1, n.emitter.on("dragstart", this.handleDragStart), n.emitter.on("hitupdate", this.handleHitUpdate), n.emitter.on("dragend", this.handleDragEnd), this.suppliedDragMeta = t } buildDragMeta(e) { return "object" == typeof this.suppliedDragMeta ? Yi(this.suppliedDragMeta) : "function" == typeof this.suppliedDragMeta ? Yi(this.suppliedDragMeta(e)) : function (e) { let t = function (e, t) { let n = Gi.dataAttrPrefix, r = (n ? n + "-" : "") + "event"; return e.getAttribute("data-" + r) || "" }(e); return Yi(t ? JSON.parse(t) : { create: !1 }) }(e) } displayDrag(e, t) { let n = this.receivingContext; n && n !== e && n.dispatch({ type: "UNSET_EVENT_DRAG" }), e && e.dispatch({ type: "SET_EVENT_DRAG", state: t }) } clearDrag() { this.receivingContext && this.receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" }) } canDropElOnCalendar(e, t) { let n = t.options.dropAccept; return "function" == typeof n ? n.call(t.calendarApi, e) : "string" != typeof n || !n || Boolean(Ie(e, n)) } } Gi.dataAttrPrefix = ""; class Ga extends Vi { constructor(e) { super(e), this.shouldIgnoreMove = !1, this.mirrorSelector = "", this.currentMirrorEl = null, this.handlePointerDown = e => { this.emitter.trigger("pointerdown", e), this.shouldIgnoreMove || this.emitter.trigger("dragstart", e) }, this.handlePointerMove = e => { this.shouldIgnoreMove || this.emitter.trigger("dragmove", e) }, this.handlePointerUp = e => { this.emitter.trigger("pointerup", e), this.shouldIgnoreMove || this.emitter.trigger("dragend", e) }; let t = this.pointer = new xa(e); t.emitter.on("pointerdown", this.handlePointerDown), t.emitter.on("pointermove", this.handlePointerMove), t.emitter.on("pointerup", this.handlePointerUp) } destroy() { this.pointer.destroy() } setIgnoreMove(e) { this.shouldIgnoreMove = e } setMirrorIsVisible(e) { if (e) this.currentMirrorEl && (this.currentMirrorEl.style.visibility = "", this.currentMirrorEl = null); else { let e = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null; e && (this.currentMirrorEl = e, e.style.visibility = "hidden") } } } var qa = _s({ name: "@fullcalendar/interaction", componentInteractions: [class extends ji { constructor(e) { super(e), this.handlePointerDown = e => { let { dragging: t } = this, n = e.origEvent.target; t.setIgnoreMove(!this.component.isValidDateDownEl(n)) }, this.handleDragEnd = e => { let { component: t } = this, { pointer: n } = this.dragging; if (!n.wasTouchScroll) { let { initialHit: n, finalHit: r } = this.hitDragging; if (n && r && Wa(n, r)) { let { context: r } = t, i = Object.assign(Object.assign({}, za(n.dateSpan, r)), { dayEl: n.dayEl, jsEvent: e.origEvent, view: r.viewApi || r.calendarApi.view }); r.emitter.trigger("dateClick", i) } } }, this.dragging = new Ha(e.el), this.dragging.autoScroller.isEnabled = !1; let t = this.hitDragging = new La(this.dragging, Ui(e)); t.emitter.on("pointerdown", this.handlePointerDown), t.emitter.on("dragend", this.handleDragEnd) } destroy() { this.dragging.destroy() } }, class extends ji { constructor(e) { super(e), this.dragSelection = null, this.handlePointerDown = e => { let { component: t, dragging: n } = this, { options: r } = t.context, i = r.selectable && t.isValidDateDownEl(e.origEvent.target); n.setIgnoreMove(!i), n.delay = e.isTouch ? function (e) { let { options: t } = e.context, n = t.selectLongPressDelay; return null == n && (n = t.longPressDelay), n }(t) : null }, this.handleDragStart = e => { this.component.context.calendarApi.unselect(e) }, this.handleHitUpdate = (e, t) => { let { context: n } = this.component, r = null, i = !1; if (e) { let t = this.hitDragging.initialHit; e.componentId === t.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(t, e) || (r = function (e, t, n) { let r = e.dateSpan, i = t.dateSpan, o = [r.range.start, r.range.end, i.range.start, i.range.end]; o.sort(st); let s = {}; for (let r of n) { let n = r(e, t); if (!1 === n) return null; n && Object.assign(s, n) } return s.range = { start: o[0], end: o[3] }, s.allDay = r.allDay, s }(t, e, n.pluginHooks.dateSelectionTransformers)), r && Co(r, e.dateProfile, n) || (i = !0, r = null) } r ? n.dispatch({ type: "SELECT_DATES", selection: r }) : t || n.dispatch({ type: "UNSELECT_DATES" }), i ? Qe() : Ze(), t || (this.dragSelection = r) }, this.handlePointerUp = e => { this.dragSelection && (Kr(this.dragSelection, e, this.component.context), this.dragSelection = null) }; let { component: t } = e, { options: n } = t.context, r = this.dragging = new Ha(e.el); r.touchScrollAllowed = !1, r.minDistance = n.selectMinDistance || 0, r.autoScroller.isEnabled = n.dragScroll; let i = this.hitDragging = new La(this.dragging, Ui(e)); i.emitter.on("pointerdown", this.handlePointerDown), i.emitter.on("dragstart", this.handleDragStart), i.emitter.on("hitupdate", this.handleHitUpdate), i.emitter.on("pointerup", this.handlePointerUp) } destroy() { this.dragging.destroy() } }, ja, class extends ji { constructor(e) { super(e), this.draggingSegEl = null, this.draggingSeg = null, this.eventRange = null, this.relevantEvents = null, this.validMutation = null, this.mutatedRelevantEvents = null, this.handlePointerDown = e => { let { component: t } = this, n = hi(this.querySegEl(e)), r = this.eventRange = n.eventRange; this.dragging.minDistance = t.context.options.eventDragMinDistance, this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(e.origEvent.target) || e.isTouch && this.component.props.eventSelection !== r.instance.instanceId) }, this.handleDragStart = e => { let { context: t } = this.component, n = this.eventRange; this.relevantEvents = Nn(t.getCurrentData().eventStore, this.eventRange.instance.instanceId); let r = this.querySegEl(e); this.draggingSegEl = r, this.draggingSeg = hi(r), t.calendarApi.unselect(), t.emitter.trigger("eventResizeStart", { el: r, event: new si(t, n.def, n.instance), jsEvent: e.origEvent, view: t.viewApi }) }, this.handleHitUpdate = (e, t, n) => { let { context: r } = this.component, i = this.relevantEvents, o = this.hitDragging.initialHit, s = this.eventRange.instance, a = null, l = null, d = !1, c = { affectedEvents: i, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 }; e && (e.componentId === o.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(o, e) || (a = function (e, t, n, r) { let i = e.context.dateEnv, o = tr(e.dateSpan.range.start, t.dateSpan.range.start, i, e.largeUnit); if (n) { if (i.add(r.start, o) < r.end) return { startDelta: o } } else if (i.add(r.end, o) > r.start) return { endDelta: o }; return null }(o, e, n.subjectEl.classList.contains("fc-event-resizer-start"), s.range))), a && (l = ni(i, r.getCurrentData().eventUiBases, a, r), c.mutatedEvents = l, So(c, e.dateProfile, r) || (d = !0, a = null, l = null, c.mutatedEvents = null)), l ? r.dispatch({ type: "SET_EVENT_RESIZE", state: c }) : r.dispatch({ type: "UNSET_EVENT_RESIZE" }), d ? Qe() : Ze(), t || (a && Wa(o, e) && (a = null), this.validMutation = a, this.mutatedRelevantEvents = l) }, this.handleDragEnd = e => { let { context: t } = this.component, n = this.eventRange.def, r = this.eventRange.instance, i = new si(t, n, r), o = this.relevantEvents, s = this.mutatedRelevantEvents; if (t.emitter.trigger("eventResizeStop", { el: this.draggingSegEl, event: i, jsEvent: e.origEvent, view: t.viewApi }), this.validMutation) { let a = new si(t, s.defs[n.defId], r ? s.instances[r.instanceId] : null); t.dispatch({ type: "MERGE_EVENTS", eventStore: s }); let l = { oldEvent: i, event: a, relatedEvents: li(s, t, r), revert() { t.dispatch({ type: "MERGE_EVENTS", eventStore: o }) } }; t.emitter.trigger("eventResize", Object.assign(Object.assign({}, l), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || ut(0), endDelta: this.validMutation.endDelta || ut(0), jsEvent: e.origEvent, view: t.viewApi })), t.emitter.trigger("eventChange", l) } else t.emitter.trigger("_noEventResize"); this.draggingSeg = null, this.relevantEvents = null, this.validMutation = null }; let { component: t } = e, n = this.dragging = new Ha(e.el); n.pointer.selector = ".fc-event-resizer", n.touchScrollAllowed = !1, n.autoScroller.isEnabled = t.context.options.dragScroll; let r = this.hitDragging = new La(this.dragging, Ui(e)); r.emitter.on("pointerdown", this.handlePointerDown), r.emitter.on("dragstart", this.handleDragStart), r.emitter.on("hitupdate", this.handleHitUpdate), r.emitter.on("dragend", this.handleDragEnd) } destroy() { this.dragging.destroy() } querySegEl(e) { return Me(e.subjectEl, ".fc-event") } }], calendarInteractions: [class { constructor(e) { this.context = e, this.isRecentPointerDateSelect = !1, this.matchesCancel = !1, this.matchesEvent = !1, this.onSelect = e => { e.jsEvent && (this.isRecentPointerDateSelect = !0) }, this.onDocumentPointerDown = e => { let t = this.context.options.unselectCancel, n = Be(e.origEvent); this.matchesCancel = !!Me(n, t), this.matchesEvent = !!Me(n, ja.SELECTOR) }, this.onDocumentPointerUp = e => { let { context: t } = this, { documentPointer: n } = this, r = t.getCurrentData(); if (!n.wasTouchScroll) { if (r.dateSelection && !this.isRecentPointerDateSelect) { let n = t.options.unselectAuto; !n || n && this.matchesCancel || t.calendarApi.unselect(e) } r.eventSelection && !this.matchesEvent && t.dispatch({ type: "UNSELECT_EVENT" }) } this.isRecentPointerDateSelect = !1 }; let t = this.documentPointer = new xa(document); t.shouldIgnoreMove = !0, t.shouldWatchScroll = !1, t.emitter.on("pointerdown", this.onDocumentPointerDown), t.emitter.on("pointerup", this.onDocumentPointerUp), e.emitter.on("select", this.onSelect) } destroy() { this.context.emitter.off("select", this.onSelect), this.documentPointer.destroy() } }], elementDraggingImpl: Ha, optionRefiners: Ua, listenerRefiners: Fa }); function Ya(e, t) { let n = []; for (let e = 0; e < t; e += 1)n[e] = []; for (let t of e) n[t.row].push(t); return n } function Qa(e, t) { let n = []; for (let e = 0; e < t; e += 1)n[e] = []; for (let t of e) n[t.firstCol].push(t); return n } function Za(e, t) { let n = []; if (e) { for (let r = 0; r < t; r += 1)n[r] = { affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: [] }; for (let t of e.segs) n[t.row].segs.push(t) } else for (let e = 0; e < t; e += 1)n[e] = null; return n } Re(':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}'); const Xa = vn({ hour: "numeric", minute: "2-digit", omitZeroMinute: !0, meridiem: "narrow" }); function $a(e) { let { display: t } = e.eventRange.ui; return "list-item" === t || "auto" === t && !e.eventRange.def.allDay && e.firstCol === e.lastCol && e.isStart && e.isEnd } class Ja extends Qr { render() { let { props: e } = this; return p(Xo, Object.assign({}, e, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: Xa, defaultDisplayEventEnd: e.defaultDisplayEventEnd, disableResizing: !e.seg.eventRange.def.allDay })) } } class Ka extends Qr { render() { let { props: e, context: t } = this, { options: n } = t, { seg: r } = e, i = Ei(r, n.eventTimeFormat || Xa, t, !0, e.defaultDisplayEventEnd); return p(Zo, Object.assign({}, e, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: Ai(e.seg, t), defaultGenerator: el, timeText: i, isResizing: !1, isDateSelecting: !1 })) } } function el(e) { return p(v, null, p("div", { className: "fc-daygrid-event-dot", style: { borderColor: e.borderColor || e.backgroundColor } }), e.timeText && p("div", { className: "fc-event-time" }, e.timeText), p("div", { className: "fc-event-title" }, e.event.title || p(v, null, "Â "))) } class tl extends Qr { constructor() { super(...arguments), this.compileSegs = tn(nl) } render() { let { props: e } = this, { allSegs: t, invisibleSegs: n } = this.compileSegs(e.singlePlacements); return p(cs, { elClasses: ["fc-daygrid-more-link"], dateProfile: e.dateProfile, todayRange: e.todayRange, allDayDate: e.allDayDate, moreCnt: e.moreCnt, allSegs: t, hiddenSegs: n, alignmentElRef: e.alignmentElRef, alignGridTop: e.alignGridTop, extraDateSpan: e.extraDateSpan, popoverContent: () => { let n = (e.eventDrag ? e.eventDrag.affectedInstances : null) || (e.eventResize ? e.eventResize.affectedInstances : null) || {}; return p(v, null, t.map((t => { let r = t.eventRange.instance.instanceId; return p("div", { className: "fc-daygrid-event-harness", key: r, style: { visibility: n[r] ? "hidden" : "" } }, $a(t) ? p(Ka, Object.assign({ seg: t, isDragging: !1, isSelected: r === e.eventSelection, defaultDisplayEventEnd: !1 }, Si(t, e.todayRange))) : p(Ja, Object.assign({ seg: t, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: r === e.eventSelection, defaultDisplayEventEnd: !1 }, Si(t, e.todayRange)))) }))) } }) } } function nl(e) { let t = [], n = []; for (let r of e) t.push(r.seg), r.isVisible || n.push(r.seg); return { allSegs: t, invisibleSegs: n } } const rl = vn({ week: "narrow" }); class il extends Xr { constructor() { super(...arguments), this.rootElRef = { current: null }, this.state = { dayNumberId: We() }, this.handleRootEl = e => { Zr(this.rootElRef, e), Zr(this.props.elRef, e) } } render() { let { context: e, props: t, state: n, rootElRef: r } = this, { options: i, dateEnv: o } = e, { date: s, dateProfile: a } = t; const l = t.showDayNumber && function (e, t, n) { const { start: r, end: i } = t, o = Ht(i, -1), s = n.getYear(r), a = n.getMonth(r), l = n.getYear(o), d = n.getMonth(o); return !(s === l && a === d) && Boolean(e.valueOf() === r.valueOf() || 1 === n.getDay(e) && e.valueOf() < i.valueOf()) }(s, a.currentRange, o); return p(es, { elTag: "td", elRef: this.handleRootEl, elClasses: ["fc-daygrid-day", ...t.extraClassNames || []], elAttrs: Object.assign(Object.assign(Object.assign({}, t.extraDataAttrs), t.showDayNumber ? { "aria-labelledby": n.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: ol, date: s, dateProfile: a, todayRange: t.todayRange, showDayNumber: t.showDayNumber, isMonthStart: l, extraRenderProps: t.extraRenderProps }, ((o, a) => p("div", { ref: t.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: t.minHeight } }, t.showWeekNumber && p(ss, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: wr(e, s, "week"), date: s, defaultFormat: rl }), !a.isDisabled && (t.showDayNumber || ts(i) || t.forceDayTop) ? p("div", { className: "fc-daygrid-day-top" }, p(o, { elTag: "a", elClasses: ["fc-daygrid-day-number", l && "fc-daygrid-month-start"], elAttrs: Object.assign(Object.assign({}, wr(e, s)), { id: n.dayNumberId }) })) : t.showDayNumber ? p("div", { className: "fc-daygrid-day-top", style: { visibility: "hidden" } }, p("a", { className: "fc-daygrid-day-number" }, "Â ")) : void 0, p("div", { className: "fc-daygrid-day-events", ref: t.fgContentElRef }, t.fgContent, p("div", { className: "fc-daygrid-day-bottom", style: { marginTop: t.moreMarginTop } }, p(tl, { allDayDate: s, singlePlacements: t.singlePlacements, moreCnt: t.moreCnt, alignmentElRef: r, alignGridTop: !t.showDayNumber, extraDateSpan: t.extraDateSpan, dateProfile: t.dateProfile, eventSelection: t.eventSelection, eventDrag: t.eventDrag, eventResize: t.eventResize, todayRange: t.todayRange }))), p("div", { className: "fc-daygrid-day-bg" }, t.bgContent)))) } } function ol(e) { return e.dayNumberText || p(v, null, "Â ") } function sl(e, t, n, r) { if (e.firstCol === t && e.lastCol === n - 1) return e; let i = e.eventRange, o = i.range, s = gr(o, { start: r[t].date, end: Nt(r[n - 1].date, 1) }); return Object.assign(Object.assign({}, e), { firstCol: t, lastCol: n - 1, eventRange: { def: i.def, ui: Object.assign(Object.assign({}, i.ui), { durationEditable: !1 }), instance: i.instance, range: s }, isStart: e.isStart && s.start.valueOf() === o.start.valueOf(), isEnd: e.isEnd && s.end.valueOf() === o.end.valueOf() }) } class al extends Ni { constructor() { super(...arguments), this.hiddenConsumes = !1, this.forceHidden = {} } addSegs(e) { const t = super.addSegs(e), { entriesByLevel: n } = this, r = e => !this.forceHidden[Pi(e)]; for (let e = 0; e < n.length; e += 1)n[e] = n[e].filter(r); return t } handleInvalidInsertion(e, t, n) { const { entriesByLevel: r, forceHidden: i } = this, { touchingEntry: o, touchingLevel: s, touchingLateral: a } = e; if (this.hiddenConsumes && o) { const e = Pi(o); if (!i[e]) if (this.allowReslicing) { const e = Object.assign(Object.assign({}, o), { span: Li(o.span, t.span) }); i[Pi(e)] = !0, r[s][a] = e, this.splitEntry(o, t, n) } else i[e] = !0, n.push(o) } return super.handleInvalidInsertion(e, t, n) } } class ll extends Xr { constructor() { super(...arguments), this.cellElRefs = new No, this.frameElRefs = new No, this.fgElRefs = new No, this.segHarnessRefs = new No, this.rootElRef = { current: null }, this.state = { framePositions: null, maxContentHeight: null, eventInstanceHeights: {} }, this.handleResize = e => { e && this.updateSizing(!0) } } render() { let { props: e, state: t, context: n } = this, { options: r } = n, i = e.cells.length, o = Qa(e.businessHourSegs, i), s = Qa(e.bgEventSegs, i), a = Qa(this.getHighlightSegs(), i), l = Qa(this.getMirrorSegs(), i), { singleColPlacements: d, multiColPlacements: c, moreCnts: u, moreMarginTops: h } = function (e, t, n, r, i, o, s) { let a = new al; a.allowReslicing = !0, a.strictOrder = r, !0 === t || !0 === n ? (a.maxCoord = o, a.hiddenConsumes = !0) : "number" == typeof t ? a.maxStackCnt = t : "number" == typeof n && (a.maxStackCnt = n, a.hiddenConsumes = !0); let l = [], d = []; for (let t = 0; t < e.length; t += 1) { let n = e[t], { instanceId: r } = n.eventRange.instance, o = i[r]; null != o ? l.push({ index: t, thickness: o, span: { start: n.firstCol, end: n.lastCol + 1 } }) : d.push(n) } let c = a.addSegs(l), u = a.toRects(), { singleColPlacements: h, multiColPlacements: f, leftoverMargins: g } = function (e, t, n) { let r = function (e, t) { let n = []; for (let e = 0; e < t; e += 1)n.push([]); for (let t of e) for (let e = t.span.start; e < t.span.end; e += 1)n[e].push(t); return n }(e, n.length), i = [], o = [], s = []; for (let e = 0; e < n.length; e += 1) { let a = r[e], l = [], d = 0, c = 0; for (let r of a) { let i = t[r.index]; l.push({ seg: sl(i, e, e + 1, n), isVisible: !0, isAbsolute: !1, absoluteTop: r.levelCoord, marginTop: r.levelCoord - d }), d = r.levelCoord + r.thickness } let u = []; d = 0, c = 0; for (let r of a) { let i = t[r.index], o = r.span.end - r.span.start > 1, s = r.span.start === e; c += r.levelCoord - d, d = r.levelCoord + r.thickness, o ? (c += r.thickness, s && u.push({ seg: sl(i, r.span.start, r.span.end, n), isVisible: !0, isAbsolute: !0, absoluteTop: r.levelCoord, marginTop: 0 })) : s && (u.push({ seg: sl(i, r.span.start, r.span.end, n), isVisible: !0, isAbsolute: !1, absoluteTop: r.levelCoord, marginTop: c }), c = 0) } i.push(l), o.push(u), s.push(c) } return { singleColPlacements: i, multiColPlacements: o, leftoverMargins: s } }(u, e, s), p = [], m = []; for (let e of d) { f[e.firstCol].push({ seg: e, isVisible: !1, isAbsolute: !0, absoluteTop: 0, marginTop: 0 }); for (let t = e.firstCol; t <= e.lastCol; t += 1)h[t].push({ seg: sl(e, t, t + 1, s), isVisible: !1, isAbsolute: !1, absoluteTop: 0, marginTop: 0 }) } for (let e = 0; e < s.length; e += 1)p.push(0); for (let t of c) { let n = e[t.index], r = t.span; f[r.start].push({ seg: sl(n, r.start, r.end, s), isVisible: !1, isAbsolute: !0, absoluteTop: 0, marginTop: 0 }); for (let e = r.start; e < r.end; e += 1)p[e] += 1, h[e].push({ seg: sl(n, e, e + 1, s), isVisible: !1, isAbsolute: !1, absoluteTop: 0, marginTop: 0 }) } for (let e = 0; e < s.length; e += 1)m.push(g[e]); return { singleColPlacements: h, multiColPlacements: f, moreCnts: p, moreMarginTops: m } }(pi(e.fgEventSegs, r.eventOrder), e.dayMaxEvents, e.dayMaxEventRows, r.eventOrderStrict, t.eventInstanceHeights, t.maxContentHeight, e.cells), f = e.eventDrag && e.eventDrag.affectedInstances || e.eventResize && e.eventResize.affectedInstances || {}; return p("tr", { ref: this.rootElRef, role: "row" }, e.renderIntro && e.renderIntro(), e.cells.map(((t, n) => { let r = this.renderFgSegs(n, e.forPrint ? d[n] : c[n], e.todayRange, f), i = this.renderFgSegs(n, function (e, t) { if (!e.length) return []; let n = function (e) { let t = {}; for (let n of e) for (let e of n) t[e.seg.eventRange.instance.instanceId] = e.absoluteTop; return t }(t); return e.map((e => ({ seg: e, isVisible: !0, isAbsolute: !0, absoluteTop: n[e.eventRange.instance.instanceId], marginTop: 0 }))) }(l[n], c), e.todayRange, {}, Boolean(e.eventDrag), Boolean(e.eventResize), !1); return p(il, { key: t.key, elRef: this.cellElRefs.createRef(t.key), innerElRef: this.frameElRefs.createRef(t.key), dateProfile: e.dateProfile, date: t.date, showDayNumber: e.showDayNumbers, showWeekNumber: e.showWeekNumbers && 0 === n, forceDayTop: e.showWeekNumbers, todayRange: e.todayRange, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, extraRenderProps: t.extraRenderProps, extraDataAttrs: t.extraDataAttrs, extraClassNames: t.extraClassNames, extraDateSpan: t.extraDateSpan, moreCnt: u[n], moreMarginTop: h[n], singlePlacements: d[n], fgContentElRef: this.fgElRefs.createRef(t.key), fgContent: p(v, null, p(v, null, r), p(v, null, i)), bgContent: p(v, null, this.renderFillSegs(a[n], "highlight"), this.renderFillSegs(o[n], "non-business"), this.renderFillSegs(s[n], "bg-event")), minHeight: e.cellMinHeight }) }))) } componentDidMount() { this.updateSizing(!0), this.context.addResizeHandler(this.handleResize) } componentDidUpdate(e, t) { let n = this.props; this.updateSizing(!Dt(e, n)) } componentWillUnmount() { this.context.removeResizeHandler(this.handleResize) } getHighlightSegs() { let { props: e } = this; return e.eventDrag && e.eventDrag.segs.length ? e.eventDrag.segs : e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : e.dateSelectionSegs } getMirrorSegs() { let { props: e } = this; return e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : [] } renderFgSegs(e, t, n, r, i, o, s) { let { context: a } = this, { eventSelection: l } = this.props, { framePositions: d } = this.state, c = 1 === this.props.cells.length, u = i || o || s, h = []; if (d) for (let f of t) { let { seg: t } = f, { instanceId: g } = t.eventRange.instance, m = g + ":" + e, v = f.isVisible && !r[g], y = f.isAbsolute, b = "", E = ""; y && (a.isRtl ? (E = 0, b = d.lefts[t.lastCol] - d.lefts[t.firstCol]) : (b = 0, E = d.rights[t.firstCol] - d.rights[t.lastCol])), h.push(p("div", { className: "fc-daygrid-event-harness" + (y ? " fc-daygrid-event-harness-abs" : ""), key: m, ref: u ? null : this.segHarnessRefs.createRef(m), style: { visibility: v ? "" : "hidden", marginTop: y ? "" : f.marginTop, top: y ? f.absoluteTop : "", left: b, right: E } }, $a(t) ? p(Ka, Object.assign({ seg: t, isDragging: i, isSelected: g === l, defaultDisplayEventEnd: c }, Si(t, n))) : p(Ja, Object.assign({ seg: t, isDragging: i, isResizing: o, isDateSelecting: s, isSelected: g === l, defaultDisplayEventEnd: c }, Si(t, n))))) } return h } renderFillSegs(e, t) { let { isRtl: n } = this.context, { todayRange: r } = this.props, { framePositions: i } = this.state, o = []; if (i) for (let s of e) { let e = n ? { right: 0, left: i.lefts[s.lastCol] - i.lefts[s.firstCol] } : { left: 0, right: i.rights[s.firstCol] - i.rights[s.lastCol] }; o.push(p("div", { key: wi(s.eventRange), className: "fc-daygrid-bg-harness", style: e }, "bg-event" === t ? p(rs, Object.assign({ seg: s }, Si(s, r))) : os(t))) } return p(v, {}, ...o) } updateSizing(e) { let { props: t, state: n, frameElRefs: r } = this; if (!t.forPrint && null !== t.clientWidth) { if (e) { let e = t.cells.map((e => r.currentMap[e.key])); if (e.length) { let t = this.rootElRef.current, r = new Hr(t, e, !0, !1); n.framePositions && n.framePositions.similarTo(r) || this.setState({ framePositions: new Hr(t, e, !0, !1) }) } } const i = this.state.eventInstanceHeights, o = this.queryEventInstanceHeights(), s = !0 === t.dayMaxEvents || !0 === t.dayMaxEventRows; this.safeSetState({ eventInstanceHeights: Object.assign(Object.assign({}, i), o), maxContentHeight: s ? this.computeMaxContentHeight() : null }) } } queryEventInstanceHeights() { let e = this.segHarnessRefs.currentMap, t = {}; for (let n in e) { let r = Math.round(e[n].getBoundingClientRect().height), i = n.split(":")[0]; t[i] = Math.max(t[i] || 0, r) } return t } computeMaxContentHeight() { let e = this.props.cells[0].key, t = this.cellElRefs.currentMap[e], n = this.fgElRefs.currentMap[e]; return t.getBoundingClientRect().bottom - n.getBoundingClientRect().top } getCellEls() { let e = this.cellElRefs.currentMap; return this.props.cells.map((t => e[t.key])) } } ll.addStateEquality({ eventInstanceHeights: Dt }); class dl extends Xr { constructor() { super(...arguments), this.splitBusinessHourSegs = tn(Ya), this.splitBgEventSegs = tn(Ya), this.splitFgEventSegs = tn(Ya), this.splitDateSelectionSegs = tn(Ya), this.splitEventDrag = tn(Za), this.splitEventResize = tn(Za), this.rowRefs = new No } render() { let { props: e, context: t } = this, n = e.cells.length, r = this.splitBusinessHourSegs(e.businessHourSegs, n), i = this.splitBgEventSegs(e.bgEventSegs, n), o = this.splitFgEventSegs(e.fgEventSegs, n), s = this.splitDateSelectionSegs(e.dateSelectionSegs, n), a = this.splitEventDrag(e.eventDrag, n), l = this.splitEventResize(e.eventResize, n), d = n >= 7 && e.clientWidth ? e.clientWidth / t.options.aspectRatio / 6 : null; return p(lo, { unit: "day" }, ((t, c) => p(v, null, e.cells.map(((t, u) => p(ll, { ref: this.rowRefs.createRef(u), key: t.length ? t[0].date.toISOString() : u, showDayNumbers: n > 1, showWeekNumbers: e.showWeekNumbers, todayRange: c, dateProfile: e.dateProfile, cells: t, renderIntro: e.renderRowIntro, businessHourSegs: r[u], eventSelection: e.eventSelection, bgEventSegs: i[u].filter(cl), fgEventSegs: o[u], dateSelectionSegs: s[u], eventDrag: a[u], eventResize: l[u], dayMaxEvents: e.dayMaxEvents, dayMaxEventRows: e.dayMaxEventRows, clientWidth: e.clientWidth, clientHeight: e.clientHeight, cellMinHeight: d, forPrint: e.forPrint })))))) } componentDidMount() { const e = this.rowRefs.currentMap[0].getCellEls()[0]; this.rootEl = e ? e.closest(".fc-daygrid-body") : null, this.rootEl && this.context.registerInteractiveComponent(this, { el: this.rootEl, isHitComboAllowed: this.props.isHitComboAllowed }) } componentWillUnmount() { this.rootEl && (this.context.unregisterInteractiveComponent(this), this.rootEl = null) } prepareHits() { this.rowPositions = new Hr(this.rootEl, this.rowRefs.collect().map((e => e.getCellEls()[0])), !1, !0), this.colPositions = new Hr(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), !0, !1) } queryHit(e, t) { let { colPositions: n, rowPositions: r } = this, i = n.leftToIndex(e), o = r.topToIndex(t); if (null != o && null != i) { let e = this.props.cells[o][i]; return { dateProfile: this.props.dateProfile, dateSpan: Object.assign({ range: this.getCellRange(o, i), allDay: !0 }, e.extraDateSpan), dayEl: this.getCellEl(o, i), rect: { left: n.lefts[i], right: n.rights[i], top: r.tops[o], bottom: r.bottoms[o] }, layer: 0 } } return null } getCellEl(e, t) { return this.rowRefs.currentMap[e].getCellEls()[t] } getCellRange(e, t) { let n = this.props.cells[e][t].date; return { start: n, end: Nt(n, 1) } } } function cl(e) { return e.eventRange.def.allDay } class ul extends Xr { constructor() { super(...arguments), this.elRef = { current: null }, this.needsScrollReset = !1 } render() { let { props: e } = this, { dayMaxEventRows: t, dayMaxEvents: n, expandRows: r } = e, i = !0 === n || !0 === t; i && !r && (i = !1, t = null, n = null); let o = ["fc-daygrid-body", i ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced", r ? "" : "fc-daygrid-body-natural"]; return p("div", { ref: this.elRef, className: o.join(" "), style: { width: e.clientWidth, minWidth: e.tableMinWidth } }, p("table", { role: "presentation", className: "fc-scrollgrid-sync-table", style: { width: e.clientWidth, minWidth: e.tableMinWidth, height: r ? e.clientHeight : "" } }, e.colGroupNode, p("tbody", { role: "presentation" }, p(dl, { dateProfile: e.dateProfile, cells: e.cells, renderRowIntro: e.renderRowIntro, showWeekNumbers: e.showWeekNumbers, clientWidth: e.clientWidth, clientHeight: e.clientHeight, businessHourSegs: e.businessHourSegs, bgEventSegs: e.bgEventSegs, fgEventSegs: e.fgEventSegs, dateSelectionSegs: e.dateSelectionSegs, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, dayMaxEvents: n, dayMaxEventRows: t, forPrint: e.forPrint, isHitComboAllowed: e.isHitComboAllowed })))) } componentDidMount() { this.requestScrollReset() } componentDidUpdate(e) { e.dateProfile !== this.props.dateProfile ? this.requestScrollReset() : this.flushScrollReset() } requestScrollReset() { this.needsScrollReset = !0, this.flushScrollReset() } flushScrollReset() { if (this.needsScrollReset && this.props.clientWidth) { const e = function (e, t) { let n; return t.currentRangeUnit.match(/year|month/) && (n = e.querySelector(`[data-date="${Jt(t.currentDate)}-01"]`)), n || (n = e.querySelector(`[data-date="${$t(t.currentDate)}"]`)), n }(this.elRef.current, this.props.dateProfile); if (e) { const t = e.closest(".fc-daygrid-body"), n = t.closest(".fc-scroller"), r = e.getBoundingClientRect().top - t.getBoundingClientRect().top; n.scrollTop = r ? r + 1 : 0 } this.needsScrollReset = !1 } } } class hl extends po { constructor() { super(...arguments), this.forceDayIfListItem = !0 } sliceRange(e, t) { return t.sliceRange(e) } } class fl extends Xr { constructor() { super(...arguments), this.slicer = new hl, this.tableRef = { current: null } } render() { let { props: e, context: t } = this; return p(ul, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(e, e.dateProfile, e.nextDayThreshold, t, e.dayTableModel), { dateProfile: e.dateProfile, cells: e.dayTableModel.cells, colGroupNode: e.colGroupNode, tableMinWidth: e.tableMinWidth, renderRowIntro: e.renderRowIntro, dayMaxEvents: e.dayMaxEvents, dayMaxEventRows: e.dayMaxEventRows, showWeekNumbers: e.showWeekNumbers, expandRows: e.expandRows, headerAlignElRef: e.headerAlignElRef, clientWidth: e.clientWidth, clientHeight: e.clientHeight, forPrint: e.forPrint })) } } class gl extends Jr { buildRenderRange(e, t, n) { let r = super.buildRenderRange(e, t, n), { props: i } = this; return pl({ currentRange: r, snapToWeek: /^(year|month)$/.test(t), fixedWeekCount: i.fixedWeekCount, dateEnv: i.dateEnv }) } } function pl(e) { let t, { dateEnv: n, currentRange: r } = e, { start: i, end: o } = r; if (e.snapToWeek && (i = n.startOfWeek(i), t = n.startOfWeek(o), t.valueOf() !== o.valueOf() && (o = Ot(t, 1))), e.fixedWeekCount) { let e = n.startOfWeek(n.startOfMonth(Nt(r.end, -1))); o = Ot(o, 6 - Math.ceil(Pt(e, o))) } return { start: i, end: o } } class ml extends Xr { constructor() { super(...arguments), this.headerElRef = { current: null } } renderSimpleLayout(e, t) { let { props: n, context: r } = this, i = [], o = qo(r.options); return e && i.push({ type: "header", key: "header", isSticky: o, chunk: { elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e } }), i.push({ type: "body", key: "body", liquid: !0, chunk: { content: t } }), p(ms, { elClasses: ["fc-daygrid"], viewSpec: r.viewSpec }, p(Qo, { liquid: !n.isHeightAuto && !n.forPrint, collapsibleWidth: n.forPrint, cols: [], sections: i })) } renderHScrollLayout(e, t, n, r) { let i = this.context.pluginHooks.scrollGridImpl; if (!i) throw new Error("No ScrollGrid implementation"); let { props: o, context: s } = this, a = !o.forPrint && qo(s.options), l = !o.forPrint && Yo(s.options), d = []; return e && d.push({ type: "header", key: "header", isSticky: a, chunks: [{ key: "main", elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e }] }), d.push({ type: "body", key: "body", liquid: !0, chunks: [{ key: "main", content: t }] }), l && d.push({ type: "footer", key: "footer", isSticky: !0, chunks: [{ key: "main", content: Go }] }), p(ms, { elClasses: ["fc-daygrid"], viewSpec: s.viewSpec }, p(i, { liquid: !o.isHeightAuto && !o.forPrint, forPrint: o.forPrint, collapsibleWidth: o.forPrint, colGroups: [{ cols: [{ span: n, minWidth: r }] }], sections: d })) } } function vl(e, t) { let n = new fo(e.renderRange, t); return new go(n, /year|month|week/.test(e.currentRangeUnit)) } var yl = _s({ name: "@fullcalendar/daygrid", initialView: "dayGridMonth", views: { dayGrid: { component: class extends ml { constructor() { super(...arguments), this.buildDayTableModel = tn(vl), this.headerRef = { current: null }, this.tableRef = { current: null } } render() { let { options: e, dateProfileGenerator: t } = this.context, { props: n } = this, r = this.buildDayTableModel(n.dateProfile, t), i = e.dayHeaders && p(uo, { ref: this.headerRef, dateProfile: n.dateProfile, dates: r.headerDates, datesRepDistinctDays: 1 === r.rowCnt }), o = t => p(fl, { ref: this.tableRef, dateProfile: n.dateProfile, dayTableModel: r, businessHours: n.businessHours, dateSelection: n.dateSelection, eventStore: n.eventStore, eventUiBases: n.eventUiBases, eventSelection: n.eventSelection, eventDrag: n.eventDrag, eventResize: n.eventResize, nextDayThreshold: e.nextDayThreshold, colGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, dayMaxEvents: e.dayMaxEvents, dayMaxEventRows: e.dayMaxEventRows, showWeekNumbers: e.weekNumbers, expandRows: !n.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: t.clientWidth, clientHeight: t.clientHeight, forPrint: n.forPrint }); return e.dayMinWidth ? this.renderHScrollLayout(i, o, r.colCnt, e.dayMinWidth) : this.renderSimpleLayout(i, o) } }, dateProfileGeneratorClass: gl }, dayGridDay: { type: "dayGrid", duration: { days: 1 } }, dayGridWeek: { type: "dayGrid", duration: { weeks: 1 } }, dayGridMonth: { type: "dayGrid", duration: { months: 1 }, fixedWeekCount: !0 }, dayGridYear: { type: "dayGrid", duration: { years: 1 } } } }); Re('.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:"\\00a0"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:"\\00a0-\\00a0"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}'); class bl extends cr { getKeyInfo() { return { allDay: {}, timed: {} } } getKeysForDateSpan(e) { return e.allDay ? ["allDay"] : ["timed"] } getKeysForEventDef(e) { return e.allDay ? ci(e) ? ["timed", "allDay"] : ["allDay"] : ["timed"] } } const El = vn({ hour: "numeric", minute: "2-digit", omitZeroMinute: !0, meridiem: "short" }); function Sl(e) { let t = ["fc-timegrid-slot", "fc-timegrid-slot-label", e.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"]; return p(Gr.Consumer, null, (n => { if (!e.isLabeled) return p("td", { className: t.join(" "), "data-time": e.isoTimeStr }); let { dateEnv: r, options: i, viewApi: o } = n, s = null == i.slotLabelFormat ? El : Array.isArray(i.slotLabelFormat) ? vn(i.slotLabelFormat[0]) : vn(i.slotLabelFormat), a = { level: 0, time: e.time, date: r.toDate(e.date), view: o, text: r.format(e.date, s) }; return p(ro, { elTag: "td", elClasses: t, elAttrs: { "data-time": e.isoTimeStr }, renderProps: a, generatorName: "slotLabelContent", customGenerator: i.slotLabelContent, defaultGenerator: Cl, classNameGenerator: i.slotLabelClassNames, didMount: i.slotLabelDidMount, willUnmount: i.slotLabelWillUnmount }, (e => p("div", { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" }, p(e, { elTag: "div", elClasses: ["fc-timegrid-slot-label-cushion", "fc-scrollgrid-shrink-cushion"] })))) })) } function Cl(e) { return e.text } class wl extends Qr { render() { return this.props.slatMetas.map((e => p("tr", { key: e.key }, p(Sl, Object.assign({}, e))))) } } const Al = vn({ week: "short" }); class Dl extends Xr { constructor() { super(...arguments), this.allDaySplitter = new bl, this.headerElRef = { current: null }, this.rootElRef = { current: null }, this.scrollerElRef = { current: null }, this.state = { slatCoords: null }, this.handleScrollTopRequest = e => { let t = this.scrollerElRef.current; t && (t.scrollTop = e) }, this.renderHeadAxis = (e, t = "") => { let { options: n } = this.context, { dateProfile: r } = this.props, i = r.renderRange, o = 1 === Bt(i.start, i.end) ? wr(this.context, i.start, "week") : {}; return n.weekNumbers && "day" === e ? p(ss, { elTag: "th", elClasses: ["fc-timegrid-axis", "fc-scrollgrid-shrink"], elAttrs: { "aria-hidden": !0 }, date: i.start, defaultFormat: Al }, (e => p("div", { className: ["fc-timegrid-axis-frame", "fc-scrollgrid-shrink-frame", "fc-timegrid-axis-frame-liquid"].join(" "), style: { height: t } }, p(e, { elTag: "a", elClasses: ["fc-timegrid-axis-cushion", "fc-scrollgrid-shrink-cushion", "fc-scrollgrid-sync-inner"], elAttrs: o })))) : p("th", { "aria-hidden": !0, className: "fc-timegrid-axis" }, p("div", { className: "fc-timegrid-axis-frame", style: { height: t } })) }, this.renderTableRowAxis = e => { let { options: t, viewApi: n } = this.context, r = { text: t.allDayText, view: n }; return p(ro, { elTag: "td", elClasses: ["fc-timegrid-axis", "fc-scrollgrid-shrink"], elAttrs: { "aria-hidden": !0 }, renderProps: r, generatorName: "allDayContent", customGenerator: t.allDayContent, defaultGenerator: Rl, classNameGenerator: t.allDayClassNames, didMount: t.allDayDidMount, willUnmount: t.allDayWillUnmount }, (t => p("div", { className: ["fc-timegrid-axis-frame", "fc-scrollgrid-shrink-frame", null == e ? " fc-timegrid-axis-frame-liquid" : ""].join(" "), style: { height: e } }, p(t, { elTag: "span", elClasses: ["fc-timegrid-axis-cushion", "fc-scrollgrid-shrink-cushion", "fc-scrollgrid-sync-inner"] })))) }, this.handleSlatCoords = e => { this.setState({ slatCoords: e }) } } renderSimpleLayout(e, t, n) { let { context: r, props: i } = this, o = [], s = qo(r.options); return e && o.push({ type: "header", key: "header", isSticky: s, chunk: { elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e } }), t && (o.push({ type: "body", key: "all-day", chunk: { content: t } }), o.push({ type: "body", key: "all-day-divider", outerContent: p("tr", { role: "presentation", className: "fc-scrollgrid-section" }, p("td", { className: "fc-timegrid-divider " + r.theme.getClass("tableCellShaded") })) })), o.push({ type: "body", key: "body", liquid: !0, expandRows: Boolean(r.options.expandRows), chunk: { scrollerElRef: this.scrollerElRef, content: n } }), p(ms, { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: r.viewSpec }, p(Qo, { liquid: !i.isHeightAuto && !i.forPrint, collapsibleWidth: i.forPrint, cols: [{ width: "shrink" }], sections: o })) } renderHScrollLayout(e, t, n, r, i, o, s) { let a = this.context.pluginHooks.scrollGridImpl; if (!a) throw new Error("No ScrollGrid implementation"); let { context: l, props: d } = this, c = !d.forPrint && qo(l.options), u = !d.forPrint && Yo(l.options), h = []; e && h.push({ type: "header", key: "header", isSticky: c, syncRowHeights: !0, chunks: [{ key: "axis", rowContent: e => p("tr", { role: "presentation" }, this.renderHeadAxis("day", e.rowSyncHeights[0])) }, { key: "cols", elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e }] }), t && (h.push({ type: "body", key: "all-day", syncRowHeights: !0, chunks: [{ key: "axis", rowContent: e => p("tr", { role: "presentation" }, this.renderTableRowAxis(e.rowSyncHeights[0])) }, { key: "cols", content: t }] }), h.push({ key: "all-day-divider", type: "body", outerContent: p("tr", { role: "presentation", className: "fc-scrollgrid-section" }, p("td", { colSpan: 2, className: "fc-timegrid-divider " + l.theme.getClass("tableCellShaded") })) })); let f = l.options.nowIndicator; return h.push({ type: "body", key: "body", liquid: !0, expandRows: Boolean(l.options.expandRows), chunks: [{ key: "axis", content: e => p("div", { className: "fc-timegrid-axis-chunk" }, p("table", { "aria-hidden": !0, style: { height: e.expandRows ? e.clientHeight : "" } }, e.tableColGroupNode, p("tbody", null, p(wl, { slatMetas: o }))), p("div", { className: "fc-timegrid-now-indicator-container" }, p(lo, { unit: f ? "minute" : "day" }, (e => { let t = f && s && s.safeComputeTop(e); return "number" == typeof t ? p(Jo, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: t }, isAxis: !0, date: e }) : null })))) }, { key: "cols", scrollerElRef: this.scrollerElRef, content: n }] }), u && h.push({ key: "footer", type: "footer", isSticky: !0, chunks: [{ key: "axis", content: Go }, { key: "cols", content: Go }] }), p(ms, { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: l.viewSpec }, p(a, { liquid: !d.isHeightAuto && !d.forPrint, forPrint: d.forPrint, collapsibleWidth: !1, colGroups: [{ width: "shrink", cols: [{ width: "shrink" }] }, { cols: [{ span: r, minWidth: i }] }], sections: h })) } getAllDayMaxEventProps() { let { dayMaxEvents: e, dayMaxEventRows: t } = this.context.options; return !0 !== e && !0 !== t || (e = void 0, t = 5), { dayMaxEvents: e, dayMaxEventRows: t } } } function Rl(e) { return e.text } class xl { constructor(e, t, n) { this.positions = e, this.dateProfile = t, this.slotDuration = n } safeComputeTop(e) { let { dateProfile: t } = this; if (yr(t.currentRange, e)) { let n = jt(e), r = e.valueOf() - n.valueOf(); if (r >= mt(t.slotMinTime) && r < mt(t.slotMaxTime)) return this.computeTimeTop(ut(r)) } return null } computeDateTop(e, t) { return t || (t = jt(e)), this.computeTimeTop(ut(e.valueOf() - t.valueOf())) } computeTimeTop(e) { let t, n, { positions: r, dateProfile: i } = this, o = r.els.length, s = (e.milliseconds - mt(i.slotMinTime)) / mt(this.slotDuration); return s = Math.max(0, s), s = Math.min(o, s), t = Math.floor(s), t = Math.min(t, o - 1), n = s - t, r.tops[t] + r.getHeight(t) * n } } class Tl extends Qr { render() { let { props: e, context: t } = this, { options: n } = t, { slatElRefs: r } = e; return p("tbody", null, e.slatMetas.map(((i, o) => { let s = { time: i.time, date: t.dateEnv.toDate(i.date), view: t.viewApi }; return p("tr", { key: i.key, ref: r.createRef(i.key) }, e.axis && p(Sl, Object.assign({}, i)), p(ro, { elTag: "td", elClasses: ["fc-timegrid-slot", "fc-timegrid-slot-lane", !i.isLabeled && "fc-timegrid-slot-minor"], elAttrs: { "data-time": i.isoTimeStr }, renderProps: s, generatorName: "slotLaneContent", customGenerator: n.slotLaneContent, classNameGenerator: n.slotLaneClassNames, didMount: n.slotLaneDidMount, willUnmount: n.slotLaneWillUnmount })) }))) } } class kl extends Qr { constructor() { super(...arguments), this.rootElRef = { current: null }, this.slatElRefs = new No } render() { let { props: e, context: t } = this; return p("div", { ref: this.rootElRef, className: "fc-timegrid-slots" }, p("table", { "aria-hidden": !0, className: t.theme.getClass("table"), style: { minWidth: e.tableMinWidth, width: e.clientWidth, height: e.minHeight } }, e.tableColGroupNode, p(Tl, { slatElRefs: this.slatElRefs, axis: e.axis, slatMetas: e.slatMetas }))) } componentDidMount() { this.updateSizing() } componentDidUpdate() { this.updateSizing() } componentWillUnmount() { this.props.onCoords && this.props.onCoords(null) } updateSizing() { let { context: e, props: t } = this; var n; t.onCoords && null !== t.clientWidth && this.rootElRef.current.offsetHeight && t.onCoords(new xl(new Hr(this.rootElRef.current, (n = this.slatElRefs.currentMap, t.slatMetas.map((e => n[e.key]))), !1, !0), this.props.dateProfile, e.options.slotDuration)) } } function _l(e, t) { let n, r = []; for (n = 0; n < t; n += 1)r.push([]); if (e) for (n = 0; n < e.length; n += 1)r[e[n].col].push(e[n]); return r } function Ml(e, t) { let n = []; if (e) { for (let r = 0; r < t; r += 1)n[r] = { affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: [] }; for (let t of e.segs) n[t.col].segs.push(t) } else for (let e = 0; e < t; e += 1)n[e] = null; return n } class Il extends Qr { render() { let { props: e } = this; return p(cs, { elClasses: ["fc-timegrid-more-link"], elStyle: { top: e.top, bottom: e.bottom }, allDayDate: null, moreCnt: e.hiddenSegs.length, allSegs: e.hiddenSegs, hiddenSegs: e.hiddenSegs, extraDateSpan: e.extraDateSpan, dateProfile: e.dateProfile, todayRange: e.todayRange, popoverContent: () => Ul(e.hiddenSegs, e), defaultGenerator: Ol, forceTimed: !0 }, (e => p(e, { elTag: "div", elClasses: ["fc-timegrid-more-link-inner", "fc-sticky"] }))) } } function Ol(e) { return e.shortText } function Nl(e, t) { if (!e) return [[], 0]; let { level: n, lateralStart: r, lateralEnd: i } = e, o = r, s = []; for (; o < i;)s.push(t(n, o)), o += 1; return s.sort(Hl), [s.map(Pl), s[0][1]] } function Hl(e, t) { return t[1] - e[1] } function Pl(e) { return e[0] } function Bl(e, t) { const n = {}; return (...r) => { let i = e(...r); return i in n ? n[i] : n[i] = t(...r) } } function Ll(e, t, n = null, r = 0) { let i = []; if (n) for (let o = 0; o < e.length; o += 1) { let s = e[o], a = n.computeDateTop(s.start, t), l = Math.max(a + (r || 0), n.computeDateTop(s.end, t)); i.push({ start: Math.round(a), end: Math.round(l) }) } return i } const Wl = vn({ hour: "numeric", minute: "2-digit", meridiem: !1 }); class zl extends Qr { render() { return p(Xo, Object.assign({}, this.props, { elClasses: ["fc-timegrid-event", "fc-v-event", this.props.isShort && "fc-timegrid-event-short"], defaultTimeFormat: Wl })) } } class jl extends Qr { constructor() { super(...arguments), this.sortEventSegs = tn(pi) } render() { let { props: e, context: t } = this, { options: n } = t, r = n.selectMirror, i = e.eventDrag && e.eventDrag.segs || e.eventResize && e.eventResize.segs || r && e.dateSelectionSegs || [], o = e.eventDrag && e.eventDrag.affectedInstances || e.eventResize && e.eventResize.affectedInstances || {}, s = this.sortEventSegs(e.fgEventSegs, n.eventOrder); return p(es, { elTag: "td", elRef: e.elRef, elClasses: ["fc-timegrid-col", ...e.extraClassNames || []], elAttrs: Object.assign({ role: "gridcell" }, e.extraDataAttrs), date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, extraRenderProps: e.extraRenderProps }, (t => p("div", { className: "fc-timegrid-col-frame" }, p("div", { className: "fc-timegrid-col-bg" }, this.renderFillSegs(e.businessHourSegs, "non-business"), this.renderFillSegs(e.bgEventSegs, "bg-event"), this.renderFillSegs(e.dateSelectionSegs, "highlight")), p("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(s, o, !1, !1, !1)), p("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(i, {}, Boolean(e.eventDrag), Boolean(e.eventResize), Boolean(r), "mirror")), p("div", { className: "fc-timegrid-now-indicator-container" }, this.renderNowIndicator(e.nowIndicatorSegs)), ts(n) && p(t, { elTag: "div", elClasses: ["fc-timegrid-col-misc"] })))) } renderFgSegs(e, t, n, r, i, o) { let { props: s } = this; return s.forPrint ? Ul(e, s) : this.renderPositionedFgSegs(e, t, n, r, i, o) } renderPositionedFgSegs(e, t, n, r, i, o) { let { eventMaxStack: s, eventShortHeight: a, eventOrderStrict: l, eventMinHeight: d } = this.context.options, { date: c, slatCoords: u, eventSelection: h, todayRange: f, nowDate: g } = this.props, m = n || r || i, y = Ll(e, c, u, d), { segPlacements: b, hiddenGroups: E } = function (e, t, n, r) { let i = [], o = []; for (let n = 0; n < e.length; n += 1) { let r = t[n]; r ? i.push({ index: n, thickness: 1, span: r }) : o.push(e[n]) } let { segRects: s, hiddenGroups: a } = function (e, t, n) { let r = new Ni; null != t && (r.strictOrder = t), null != n && (r.maxStackCnt = n); let i = Bi(r.addSegs(e)), o = function (e) { const { entriesByLevel: t } = e, n = Bl(((e, t) => e + ":" + t), ((r, i) => { let o = Nl(function (e, t, n) { let { levelCoords: r, entriesByLevel: i } = e, o = i[t][n], s = r[t] + o.thickness, a = r.length, l = t; for (; l < a && r[l] < s; l += 1); for (; l < a; l += 1) { let e, t = i[l], n = zi(t, o.span.start, Hi), r = n[0] + n[1], s = r; for (; (e = t[s]) && e.span.start < o.span.end;)s += 1; if (r < s) return { level: l, lateralStart: r, lateralEnd: s } } return null }(e, r, i), n), s = t[r][i]; return [Object.assign(Object.assign({}, s), { nextLevelNodes: o[0] }), s.thickness + o[1]] })); return Nl(t.length ? { level: 0, lateralStart: 0, lateralEnd: t[0].length } : null, n)[0] }(r); return o = function (e, t) { const n = Bl(((e, t, n) => Pi(e)), ((e, t, r) => { let i, { nextLevelNodes: o, thickness: s } = e, a = s + r, l = s / a, d = []; if (o.length) for (let e of o) if (void 0 === i) { let r = n(e, t, a); i = r[0], d.push(r[1]) } else { let t = n(e, i, 0); d.push(t[1]) } else i = 1; let c = (i - t) * l; return [i - c, Object.assign(Object.assign({}, e), { thickness: c, nextLevelNodes: d })] })); return e.map((e => n(e, 0, 0)[1])) }(o), { segRects: function (e) { let t = []; const n = Bl(((e, t, n) => Pi(e)), ((e, n, i) => { let o = Object.assign(Object.assign({}, e), { levelCoord: n, stackDepth: i, stackForward: 0 }); return t.push(o), o.stackForward = r(e.nextLevelNodes, n + e.thickness, i + 1) + 1 })); function r(e, t, r) { let i = 0; for (let o of e) i = Math.max(n(o, t, r), i); return i } return r(e, 0, 0), t }(o), hiddenGroups: i } }(i, n, r), l = []; for (let t of s) l.push({ seg: e[t.index], rect: t }); for (let e of o) l.push({ seg: e, rect: null }); return { segPlacements: l, hiddenGroups: a } }(e, y, l, s); return p(v, null, this.renderHiddenGroups(E, e), b.map((e => { let { seg: s, rect: l } = e, d = s.eventRange.instance.instanceId, c = m || Boolean(!t[d] && l), u = Fl(l && l.span), v = !m && l ? this.computeSegHStyle(l) : { left: 0, right: 0 }, y = Boolean(l) && l.stackForward > 0, b = Boolean(l) && l.span.end - l.span.start < a; return p("div", { className: "fc-timegrid-event-harness" + (y ? " fc-timegrid-event-harness-inset" : ""), key: o || d, style: Object.assign(Object.assign({ visibility: c ? "" : "hidden" }, u), v) }, p(zl, Object.assign({ seg: s, isDragging: n, isResizing: r, isDateSelecting: i, isSelected: d === h, isShort: b }, Si(s, f, g)))) }))) } renderHiddenGroups(e, t) { let { extraDateSpan: n, dateProfile: r, todayRange: i, nowDate: o, eventSelection: s, eventDrag: a, eventResize: l } = this.props; return p(v, null, e.map((e => { let d = Fl(e.span), c = (u = e.entries, h = t, u.map((e => h[e.index]))); var u, h; return p(Il, { key: Xt(fs(c)), hiddenSegs: c, top: d.top, bottom: d.bottom, extraDateSpan: n, dateProfile: r, todayRange: i, nowDate: o, eventSelection: s, eventDrag: a, eventResize: l }) }))) } renderFillSegs(e, t) { let { props: n, context: r } = this, i = Ll(e, n.date, n.slatCoords, r.options.eventMinHeight).map(((r, i) => { let o = e[i]; return p("div", { key: wi(o.eventRange), className: "fc-timegrid-bg-harness", style: Fl(r) }, "bg-event" === t ? p(rs, Object.assign({ seg: o }, Si(o, n.todayRange, n.nowDate))) : os(t)) })); return p(v, null, i) } renderNowIndicator(e) { let { slatCoords: t, date: n } = this.props; return t ? e.map(((e, r) => p(Jo, { key: r, elClasses: ["fc-timegrid-now-indicator-line"], elStyle: { top: t.computeDateTop(e.start, n) }, isAxis: !1, date: n }))) : null } computeSegHStyle(e) { let t, n, { isRtl: r, options: i } = this.context, o = i.slotEventOverlap, s = e.levelCoord, a = e.levelCoord + e.thickness; o && (a = Math.min(1, s + 2 * (a - s))), r ? (t = 1 - a, n = s) : (t = s, n = 1 - a); let l = { zIndex: e.stackDepth + 1, left: 100 * t + "%", right: 100 * n + "%" }; return o && !e.stackForward && (l[r ? "marginLeft" : "marginRight"] = 20), l } } function Ul(e, { todayRange: t, nowDate: n, eventSelection: r, eventDrag: i, eventResize: o }) { let s = (i ? i.affectedInstances : null) || (o ? o.affectedInstances : null) || {}; return p(v, null, e.map((e => { let i = e.eventRange.instance.instanceId; return p("div", { key: i, style: { visibility: s[i] ? "hidden" : "" } }, p(zl, Object.assign({ seg: e, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: i === r, isShort: !1 }, Si(e, t, n)))) }))) } function Fl(e) { return e ? { top: e.start, bottom: -e.end } : { top: "", bottom: "" } } class Vl extends Qr { constructor() { super(...arguments), this.splitFgEventSegs = tn(_l), this.splitBgEventSegs = tn(_l), this.splitBusinessHourSegs = tn(_l), this.splitNowIndicatorSegs = tn(_l), this.splitDateSelectionSegs = tn(_l), this.splitEventDrag = tn(Ml), this.splitEventResize = tn(Ml), this.rootElRef = { current: null }, this.cellElRefs = new No } render() { let { props: e, context: t } = this, n = t.options.nowIndicator && e.slatCoords && e.slatCoords.safeComputeTop(e.nowDate), r = e.cells.length, i = this.splitFgEventSegs(e.fgEventSegs, r), o = this.splitBgEventSegs(e.bgEventSegs, r), s = this.splitBusinessHourSegs(e.businessHourSegs, r), a = this.splitNowIndicatorSegs(e.nowIndicatorSegs, r), l = this.splitDateSelectionSegs(e.dateSelectionSegs, r), d = this.splitEventDrag(e.eventDrag, r), c = this.splitEventResize(e.eventResize, r); return p("div", { className: "fc-timegrid-cols", ref: this.rootElRef }, p("table", { role: "presentation", style: { minWidth: e.tableMinWidth, width: e.clientWidth } }, e.tableColGroupNode, p("tbody", { role: "presentation" }, p("tr", { role: "row" }, e.axis && p("td", { "aria-hidden": !0, className: "fc-timegrid-col fc-timegrid-axis" }, p("div", { className: "fc-timegrid-col-frame" }, p("div", { className: "fc-timegrid-now-indicator-container" }, "number" == typeof n && p(Jo, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: n }, isAxis: !0, date: e.nowDate })))), e.cells.map(((t, n) => p(jl, { key: t.key, elRef: this.cellElRefs.createRef(t.key), dateProfile: e.dateProfile, date: t.date, nowDate: e.nowDate, todayRange: e.todayRange, extraRenderProps: t.extraRenderProps, extraDataAttrs: t.extraDataAttrs, extraClassNames: t.extraClassNames, extraDateSpan: t.extraDateSpan, fgEventSegs: i[n], bgEventSegs: o[n], businessHourSegs: s[n], nowIndicatorSegs: a[n], dateSelectionSegs: l[n], eventDrag: d[n], eventResize: c[n], slatCoords: e.slatCoords, eventSelection: e.eventSelection, forPrint: e.forPrint }))))))) } componentDidMount() { this.updateCoords() } componentDidUpdate() { this.updateCoords() } updateCoords() { let { props: e } = this; var t; e.onColCoords && null !== e.clientWidth && e.onColCoords(new Hr(this.rootElRef.current, (t = this.cellElRefs.currentMap, e.cells.map((e => t[e.key]))), !0, !1)) } } class Gl extends Xr { constructor() { super(...arguments), this.processSlotOptions = tn(ql), this.state = { slatCoords: null }, this.handleRootEl = e => { e ? this.context.registerInteractiveComponent(this, { el: e, isHitComboAllowed: this.props.isHitComboAllowed }) : this.context.unregisterInteractiveComponent(this) }, this.handleScrollRequest = e => { let { onScrollTopRequest: t } = this.props, { slatCoords: n } = this.state; if (t && n) { if (e.time) { let r = n.computeTimeTop(e.time); r = Math.ceil(r), r && (r += 1), t(r) } return !0 } return !1 }, this.handleColCoords = e => { this.colCoords = e }, this.handleSlatCoords = e => { this.setState({ slatCoords: e }), this.props.onSlatCoords && this.props.onSlatCoords(e) } } render() { let { props: e, state: t } = this; return p("div", { className: "fc-timegrid-body", ref: this.handleRootEl, style: { width: e.clientWidth, minWidth: e.tableMinWidth } }, p(kl, { axis: e.axis, dateProfile: e.dateProfile, slatMetas: e.slatMetas, clientWidth: e.clientWidth, minHeight: e.expandRows ? e.clientHeight : "", tableMinWidth: e.tableMinWidth, tableColGroupNode: e.axis ? e.tableColGroupNode : null, onCoords: this.handleSlatCoords }), p(Vl, { cells: e.cells, axis: e.axis, dateProfile: e.dateProfile, businessHourSegs: e.businessHourSegs, bgEventSegs: e.bgEventSegs, fgEventSegs: e.fgEventSegs, dateSelectionSegs: e.dateSelectionSegs, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, todayRange: e.todayRange, nowDate: e.nowDate, nowIndicatorSegs: e.nowIndicatorSegs, clientWidth: e.clientWidth, tableMinWidth: e.tableMinWidth, tableColGroupNode: e.tableColGroupNode, slatCoords: t.slatCoords, onColCoords: this.handleColCoords, forPrint: e.forPrint })) } componentDidMount() { this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest) } componentDidUpdate(e) { this.scrollResponder.update(e.dateProfile !== this.props.dateProfile) } componentWillUnmount() { this.scrollResponder.detach() } queryHit(e, t) { let { dateEnv: n, options: r } = this.context, { colCoords: i } = this, { dateProfile: o } = this.props, { slatCoords: s } = this.state, { snapDuration: a, snapsPerSlot: l } = this.processSlotOptions(this.props.slotDuration, r.snapDuration), d = i.leftToIndex(e), c = s.positions.topToIndex(t); if (null != d && null != c) { let e = this.props.cells[d], r = s.positions.tops[c], u = s.positions.getHeight(c), h = (t - r) / u, f = c * l + Math.floor(h * l), g = this.props.cells[d].date, p = ft(o.slotMinTime, gt(a, f)), m = n.add(g, p), v = n.add(m, a); return { dateProfile: o, dateSpan: Object.assign({ range: { start: m, end: v }, allDay: !1 }, e.extraDateSpan), dayEl: i.els[d], rect: { left: i.lefts[d], right: i.rights[d], top: r, bottom: r + u }, layer: 0 } } return null } } function ql(e, t) { let n = t || e, r = vt(e, n); return null === r && (n = e, r = 1), { snapDuration: n, snapsPerSlot: r } } class Yl extends po { sliceRange(e, t) { let n = []; for (let r = 0; r < t.length; r += 1) { let i = gr(e, t[r]); i && n.push({ start: i.start, end: i.end, isStart: i.start.valueOf() === e.start.valueOf(), isEnd: i.end.valueOf() === e.end.valueOf(), col: r }) } return n } } class Ql extends Xr { constructor() { super(...arguments), this.buildDayRanges = tn(Zl), this.slicer = new Yl, this.timeColsRef = { current: null } } render() { let { props: e, context: t } = this, { dateProfile: n, dayTableModel: r } = e, { nowIndicator: i, nextDayThreshold: o } = t.options, s = this.buildDayRanges(r, n, t.dateEnv); return p(lo, { unit: i ? "minute" : "day" }, ((a, l) => p(Gl, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(e, n, null, t, s), { forPrint: e.forPrint, axis: e.axis, dateProfile: n, slatMetas: e.slatMetas, slotDuration: e.slotDuration, cells: r.cells[0], tableColGroupNode: e.tableColGroupNode, tableMinWidth: e.tableMinWidth, clientWidth: e.clientWidth, clientHeight: e.clientHeight, expandRows: e.expandRows, nowDate: a, nowIndicatorSegs: i && this.slicer.sliceNowDate(a, n, o, t, s), todayRange: l, onScrollTopRequest: e.onScrollTopRequest, onSlatCoords: e.onSlatCoords })))) } } function Zl(e, t, n) { let r = []; for (let i of e.headerDates) r.push({ start: n.add(i, t.slotMinTime), end: n.add(i, t.slotMaxTime) }); return r } const Xl = [{ hours: 1 }, { minutes: 30 }, { minutes: 15 }, { seconds: 30 }, { seconds: 15 }]; function $l(e, t, n, r, i) { let o = new Date(0), s = e, a = ut(0), l = n || function (e) { let t, n, r; for (t = Xl.length - 1; t >= 0; t -= 1)if (n = ut(Xl[t]), r = vt(n, e), null !== r && r > 1) return n; return e }(r), d = []; for (; mt(s) < mt(t);) { let e = i.add(o, s), t = null !== vt(a, l); d.push({ date: e, time: s, key: e.toISOString(), isoTimeStr: Kt(e), isLabeled: t }), s = ft(s, r), a = ft(a, r) } return d } function Jl(e, t) { let n = new fo(e.renderRange, t); return new go(n, !1) } var Kl = _s({ name: "@fullcalendar/timegrid", initialView: "timeGridWeek", optionRefiners: { allDaySlot: Boolean }, views: { timeGrid: { component: class extends Dl { constructor() { super(...arguments), this.buildTimeColsModel = tn(Jl), this.buildSlatMetas = tn($l) } render() { let { options: e, dateEnv: t, dateProfileGenerator: n } = this.context, { props: r } = this, { dateProfile: i } = r, o = this.buildTimeColsModel(i, n), s = this.allDaySplitter.splitProps(r), a = this.buildSlatMetas(i.slotMinTime, i.slotMaxTime, e.slotLabelInterval, e.slotDuration, t), { dayMinWidth: l } = e, d = !l, c = l, u = e.dayHeaders && p(uo, { dates: o.headerDates, dateProfile: i, datesRepDistinctDays: !0, renderIntro: d ? this.renderHeadAxis : null }), h = !1 !== e.allDaySlot && (t => p(fl, Object.assign({}, s.allDay, { dateProfile: i, dayTableModel: o, nextDayThreshold: e.nextDayThreshold, tableMinWidth: t.tableMinWidth, colGroupNode: t.tableColGroupNode, renderRowIntro: d ? this.renderTableRowAxis : null, showWeekNumbers: !1, expandRows: !1, headerAlignElRef: this.headerElRef, clientWidth: t.clientWidth, clientHeight: t.clientHeight, forPrint: r.forPrint }, this.getAllDayMaxEventProps()))), f = t => p(Ql, Object.assign({}, s.timed, { dayTableModel: o, dateProfile: i, axis: d, slotDuration: e.slotDuration, slatMetas: a, forPrint: r.forPrint, tableColGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, clientWidth: t.clientWidth, clientHeight: t.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: t.expandRows, onScrollTopRequest: this.handleScrollTopRequest })); return c ? this.renderHScrollLayout(u, h, f, o.colCnt, l, a, this.state.slatCoords) : this.renderSimpleLayout(u, h, f) } }, usesMinMaxTime: !0, allDaySlot: !0, slotDuration: "00:30:00", slotEventOverlap: !0 }, timeGridDay: { type: "timeGrid", duration: { days: 1 } }, timeGridWeek: { type: "timeGrid", duration: { weeks: 1 } } } }); Re(':root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:"";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}'); class ed extends Qr { constructor() { super(...arguments), this.state = { textId: We() } } render() { let { theme: e, dateEnv: t, options: n, viewApi: r } = this.context, { cellId: i, dayDate: o, todayRange: s } = this.props, { textId: a } = this.state, l = br(o, s), d = n.listDayFormat ? t.format(o, n.listDayFormat) : "", c = n.listDaySideFormat ? t.format(o, n.listDaySideFormat) : "", u = Object.assign({ date: t.toDate(o), view: r, textId: a, text: d, sideText: c, navLinkAttrs: wr(this.context, o), sideNavLinkAttrs: wr(this.context, o, "day", !1) }, l); return p(ro, { elTag: "tr", elClasses: ["fc-list-day", ...Er(l, e)], elAttrs: { "data-date": $t(o) }, renderProps: u, generatorName: "dayHeaderContent", customGenerator: n.dayHeaderContent, defaultGenerator: td, classNameGenerator: n.dayHeaderClassNames, didMount: n.dayHeaderDidMount, willUnmount: n.dayHeaderWillUnmount }, (t => p("th", { scope: "colgroup", colSpan: 3, id: i, "aria-labelledby": a }, p(t, { elTag: "div", elClasses: ["fc-list-day-cushion", e.getClass("tableCellShaded")] })))) } } function td(e) { return p(v, null, e.text && p("a", Object.assign({ id: e.textId, className: "fc-list-day-text" }, e.navLinkAttrs), e.text), e.sideText && p("a", Object.assign({ "aria-hidden": !0, className: "fc-list-day-side-text" }, e.sideNavLinkAttrs), e.sideText)) } const nd = vn({ hour: "numeric", minute: "2-digit", meridiem: "short" }); class rd extends Qr { render() { let { props: e, context: t } = this, { options: n } = t, { seg: r, timeHeaderId: i, eventHeaderId: o, dateHeaderId: s } = e, a = n.eventTimeFormat || nd; return p(Zo, Object.assign({}, e, { elTag: "tr", elClasses: ["fc-list-event", r.eventRange.def.url && "fc-event-forced-url"], defaultGenerator: () => function (e, t) { let n = Ai(e, t); return p("a", Object.assign({}, n), e.eventRange.def.title) }(r, t), seg: r, timeText: "", disableDragging: !0, disableResizing: !0 }), ((e, n) => p(v, null, function (e, t, n, r, i) { let { options: o } = n; if (!1 !== o.displayEventTime) { let s, a = e.eventRange.def, l = e.eventRange.instance, d = !1; if (a.allDay ? d = !0 : er(e.eventRange.range) ? e.isStart ? s = Ei(e, t, n, null, null, l.range.start, e.end) : e.isEnd ? s = Ei(e, t, n, null, null, e.start, l.range.end) : d = !0 : s = Ei(e, t, n), d) { let e = { text: n.options.allDayText, view: n.viewApi }; return p(ro, { elTag: "td", elClasses: ["fc-list-event-time"], elAttrs: { headers: `${r} ${i}` }, renderProps: e, generatorName: "allDayContent", customGenerator: o.allDayContent, defaultGenerator: id, classNameGenerator: o.allDayClassNames, didMount: o.allDayDidMount, willUnmount: o.allDayWillUnmount }) } return p("td", { className: "fc-list-event-time" }, s) } return null }(r, a, t, i, s), p("td", { "aria-hidden": !0, className: "fc-list-event-graphic" }, p("span", { className: "fc-list-event-dot", style: { borderColor: n.borderColor || n.backgroundColor } })), p(e, { elTag: "td", elClasses: ["fc-list-event-title"], elAttrs: { headers: `${o} ${s}` } })))) } } function id(e) { return e.text } function od(e) { return e.text } function sd(e) { let t = jt(e.renderRange.start), n = e.renderRange.end, r = [], i = []; for (; t < n;)r.push(t), i.push({ start: t, end: Nt(t, 1) }), t = Nt(t, 1); return { dayDates: r, dayRanges: i } } function ad(e) { return !1 === e ? null : vn(e) } var ld = _s({ name: "@fullcalendar/list", optionRefiners: { listDayFormat: ad, listDaySideFormat: ad, noEventsClassNames: Tn, noEventsContent: Tn, noEventsDidMount: Tn, noEventsWillUnmount: Tn }, views: { list: { component: class extends Xr { constructor() { super(...arguments), this.computeDateVars = tn(sd), this.eventStoreToSegs = tn(this._eventStoreToSegs), this.state = { timeHeaderId: We(), eventHeaderId: We(), dateHeaderIdRoot: We() }, this.setRootEl = e => { e ? this.context.registerInteractiveComponent(this, { el: e }) : this.context.unregisterInteractiveComponent(this) } } render() { let { props: e, context: t } = this, { dayDates: n, dayRanges: r } = this.computeDateVars(e.dateProfile), i = this.eventStoreToSegs(e.eventStore, e.eventUiBases, r); return p(ms, { elRef: this.setRootEl, elClasses: ["fc-list", t.theme.getClass("table"), !1 !== t.options.stickyHeaderDates ? "fc-list-sticky" : ""], viewSpec: t.viewSpec }, p(Oo, { liquid: !e.isHeightAuto, overflowX: e.isHeightAuto ? "visible" : "hidden", overflowY: e.isHeightAuto ? "visible" : "auto" }, i.length > 0 ? this.renderSegList(i, n) : this.renderEmptyMessage())) } renderEmptyMessage() { let { options: e, viewApi: t } = this.context, n = { text: e.noEventsText, view: t }; return p(ro, { elTag: "div", elClasses: ["fc-list-empty"], renderProps: n, generatorName: "noEventsContent", customGenerator: e.noEventsContent, defaultGenerator: od, classNameGenerator: e.noEventsClassNames, didMount: e.noEventsDidMount, willUnmount: e.noEventsWillUnmount }, (e => p(e, { elTag: "div", elClasses: ["fc-list-empty-cushion"] }))) } renderSegList(e, t) { let { theme: n, options: r } = this.context, { timeHeaderId: i, eventHeaderId: o, dateHeaderIdRoot: s } = this.state, a = function (e) { let t, n, r = []; for (t = 0; t < e.length; t += 1)n = e[t], (r[n.dayIndex] || (r[n.dayIndex] = [])).push(n); return r }(e); return p(lo, { unit: "day" }, ((e, l) => { let d = []; for (let n = 0; n < a.length; n += 1) { let c = a[n]; if (c) { let a = $t(t[n]), u = s + "-" + a; d.push(p(ed, { key: a, cellId: u, dayDate: t[n], todayRange: l })), c = pi(c, r.eventOrder); for (let t of c) d.push(p(rd, Object.assign({ key: a + ":" + t.eventRange.instance.instanceId, seg: t, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: !1, timeHeaderId: i, eventHeaderId: o, dateHeaderId: u }, Si(t, l, e)))) } } return p("table", { className: "fc-list-table " + n.getClass("table") }, p("thead", null, p("tr", null, p("th", { scope: "col", id: i }, r.timeHint), p("th", { scope: "col", "aria-hidden": !0 }), p("th", { scope: "col", id: o }, r.eventHint))), p("tbody", null, d)) })) } _eventStoreToSegs(e, t, n) { return this.eventRangesToSegs(di(e, t, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, n) } eventRangesToSegs(e, t) { let n = []; for (let r of e) n.push(...this.eventRangeToSegs(r, t)); return n } eventRangeToSegs(e, t) { let n, r, i, { dateEnv: o } = this.context, { nextDayThreshold: s } = this.context.options, a = e.range, l = e.def.allDay, d = []; for (n = 0; n < t.length; n += 1)if (r = gr(a, t[n]), r && (i = { component: this, eventRange: e, start: r.start, end: r.end, isStart: e.isStart && r.start.valueOf() === a.start.valueOf(), isEnd: e.isEnd && r.end.valueOf() === a.end.valueOf(), dayIndex: n }, d.push(i), !i.isEnd && !l && n + 1 < t.length && a.end < o.add(t[n + 1].start, s))) { i.end = a.end, i.isEnd = !0; break } return d } }, buttonTextKey: "list", listDayFormat: { month: "long", day: "numeric", year: "numeric" } }, listDay: { type: "list", duration: { days: 1 }, listDayFormat: { weekday: "long" } }, listWeek: { type: "list", duration: { weeks: 1 }, listDayFormat: { weekday: "long" }, listDaySideFormat: { month: "long", day: "numeric", year: "numeric" } }, listMonth: { type: "list", duration: { month: 1 }, listDaySideFormat: { weekday: "long" } }, listYear: { type: "list", duration: { year: 1 }, listDaySideFormat: { weekday: "long" } } } }); class dd extends Xr { constructor() { super(...arguments), this.buildDayTableModel = tn(vl), this.slicer = new hl, this.state = { labelId: We() } } render() { const { props: e, state: t, context: n } = this, { dateProfile: r, forPrint: i } = e, { options: o } = n, s = this.buildDayTableModel(r, n.dateProfileGenerator), a = this.slicer.sliceProps(e, r, o.nextDayThreshold, n, s), l = null != e.tableWidth ? e.tableWidth / o.aspectRatio : null, d = s.cells.length, c = null != l ? l / d : null; return p("div", { ref: e.elRef, "data-date": e.isoDateStr, className: "fc-multimonth-month", style: { width: e.width }, role: "grid", "aria-labelledby": t.labelId }, p("div", { className: "fc-multimonth-header", style: { marginBottom: c }, role: "presentation" }, p("div", { className: "fc-multimonth-title", id: t.labelId }, n.dateEnv.format(e.dateProfile.currentRange.start, e.titleFormat)), p("table", { className: ["fc-multimonth-header-table", n.theme.getClass("table")].join(" "), role: "presentation" }, p("thead", { role: "rowgroup" }, p(uo, { dateProfile: e.dateProfile, dates: s.headerDates, datesRepDistinctDays: !1 })))), p("div", { className: ["fc-multimonth-daygrid", "fc-daygrid", "fc-daygrid-body", !i && "fc-daygrid-body-balanced", i && "fc-daygrid-body-unbalanced", i && "fc-daygrid-body-natural"].join(" "), style: { marginTop: -c } }, p("table", { className: ["fc-multimonth-daygrid-table", n.theme.getClass("table")].join(" "), style: { height: i ? "" : l }, role: "presentation" }, p("tbody", { role: "rowgroup" }, p(dl, Object.assign({}, a, { dateProfile: r, cells: s.cells, eventSelection: e.eventSelection, dayMaxEvents: !i, dayMaxEventRows: !i, showWeekNumbers: o.weekNumbers, clientWidth: e.clientWidth, clientHeight: e.clientHeight, forPrint: i })))))) } } const cd = ut(1, "month"); function ud(e, t, n, r, i) { const { start: o, end: s } = t.currentRange; let a = o; const l = []; for (; a.valueOf() < s.valueOf();) { const o = n.add(a, cd), s = { start: e.skipHiddenDays(a), end: e.skipHiddenDays(o, -1, !0) }; let d = pl({ currentRange: s, snapToWeek: !0, fixedWeekCount: r, dateEnv: n }); d = { start: e.skipHiddenDays(d.start), end: e.skipHiddenDays(d.end, -1, !0) }; const c = t.activeRange ? gr(t.activeRange, i ? d : s) : null; l.push({ currentDate: t.currentDate, isValid: t.isValid, validRange: t.validRange, renderRange: d, activeRange: c, currentRange: s, currentRangeUnit: "month", isRangeAllDay: !0, dateIncrement: t.dateIncrement, slotMinTime: t.slotMaxTime, slotMaxTime: t.slotMinTime }), a = o } return l } const hd = vn({ year: "numeric", month: "long" }), fd = vn({ month: "long" }); function gd(e, t) { return e || (t[0].currentRange.start.getUTCFullYear() !== t[t.length - 1].currentRange.start.getUTCFullYear() ? hd : fd) } const pd = { multiMonthTitleFormat: vn, multiMonthMaxColumns: Number, multiMonthMinWidth: Number }; Re(".fc .fc-multimonth{border:1px solid var(--fc-border-color);display:flex;flex-wrap:wrap;overflow-x:hidden;overflow-y:auto}.fc .fc-multimonth-title{font-size:1.2em;font-weight:700;padding:1em 0;text-align:center}.fc .fc-multimonth-daygrid{background:var(--fc-page-bg-color)}.fc .fc-multimonth-daygrid-table,.fc .fc-multimonth-header-table{table-layout:fixed;width:100%}.fc .fc-multimonth-daygrid-table{border-top-style:hidden!important}.fc .fc-multimonth-singlecol .fc-multimonth{position:relative}.fc .fc-multimonth-singlecol .fc-multimonth-header{background:var(--fc-page-bg-color);position:relative;top:0;z-index:2}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid{position:relative;z-index:1}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid-table,.fc .fc-multimonth-singlecol .fc-multimonth-header-table{border-left-style:hidden;border-right-style:hidden}.fc .fc-multimonth-singlecol .fc-multimonth-month:last-child .fc-multimonth-daygrid-table{border-bottom-style:hidden}.fc .fc-multimonth-multicol{line-height:1}.fc .fc-multimonth-multicol .fc-multimonth-month{padding:0 1.2em 1.2em}.fc .fc-multimonth-multicol .fc-daygrid-more-link{border:1px solid var(--fc-event-border-color);display:block;float:none;padding:1px}.fc .fc-multimonth-compact{line-height:1}.fc .fc-multimonth-compact .fc-multimonth-daygrid-table,.fc .fc-multimonth-compact .fc-multimonth-header-table{font-size:.9em}.fc-media-screen .fc-multimonth-singlecol .fc-multimonth-header{position:sticky}.fc-media-print .fc-multimonth{overflow:visible}"); var md = _s({ name: "@fullcalendar/multimonth", initialView: "multiMonthYear", optionRefiners: pd, views: { multiMonth: { component: class extends Xr { constructor() { super(...arguments), this.splitDateProfileByMonth = tn(ud), this.buildMonthFormat = tn(gd), this.scrollElRef = { current: null }, this.firstMonthElRef = { current: null }, this.needsScrollReset = !1, this.handleSizing = e => { e && this.updateSize() } } render() { const { context: e, props: t, state: n } = this, { options: r } = e, { clientWidth: i, clientHeight: o } = n, s = n.monthHPadding || 0, a = Math.min(null != i ? Math.floor(i / (r.multiMonthMinWidth + s)) : 1, r.multiMonthMaxColumns) || 1, l = 100 / a + "%", d = null == i ? null : i / a - s, c = null != i && 1 === a, u = this.splitDateProfileByMonth(e.dateProfileGenerator, t.dateProfile, e.dateEnv, !c && r.fixedWeekCount, r.showNonCurrentDates), h = this.buildMonthFormat(r.multiMonthTitleFormat, u), f = ["fc-multimonth", c ? "fc-multimonth-singlecol" : "fc-multimonth-multicol", null != d && d < 400 ? "fc-multimonth-compact" : ""]; return p(ms, { elRef: this.scrollElRef, elClasses: f, viewSpec: e.viewSpec }, u.map(((e, n) => { const r = Jt(e.currentRange.start); return p(dd, Object.assign({}, t, { key: r, isoDateStr: r, elRef: 0 === n ? this.firstMonthElRef : void 0, titleFormat: h, dateProfile: e, width: l, tableWidth: d, clientWidth: i, clientHeight: o })) }))) } componentDidMount() { this.updateSize(), this.context.addResizeHandler(this.handleSizing), this.requestScrollReset() } componentDidUpdate(e) { Dt(e, this.props) || this.handleSizing(!1), e.dateProfile !== this.props.dateProfile ? this.requestScrollReset() : this.flushScrollReset() } componentWillUnmount() { this.context.removeResizeHandler(this.handleSizing) } updateSize() { const e = this.scrollElRef.current, t = this.firstMonthElRef.current; e && this.setState({ clientWidth: e.clientWidth, clientHeight: e.clientHeight }), t && e && null == this.state.monthHPadding && this.setState({ monthHPadding: e.clientWidth - t.firstChild.offsetWidth }) } requestScrollReset() { this.needsScrollReset = !0, this.flushScrollReset() } flushScrollReset() { if (this.needsScrollReset && null != this.state.monthHPadding) { const { currentDate: e } = this.props.dateProfile, t = this.scrollElRef.current, n = t.querySelector(`[data-date="${Jt(e)}"]`); t.scrollTop = n.getBoundingClientRect().top - this.firstMonthElRef.current.getBoundingClientRect().top, this.needsScrollReset = !1 } } shouldComponentUpdate() { return !0 } }, dateProfileGeneratorClass: gl, multiMonthMinWidth: 350, multiMonthMaxColumns: 3 }, multiMonthYear: { type: "multiMonth", duration: { years: 1 }, fixedWeekCount: !0, showNonCurrentDates: !1 } } }); return ta.push(qa, yl, Kl, ld, md), e.Calendar = class extends Ss { constructor(e, t = {}) { super(), this.isRendering = !1, this.isRendered = !1, this.currentClassNames = [], this.customContentRenderId = 0, this.handleAction = e => { switch (e.type) { case "SET_EVENT_DRAG": case "SET_EVENT_RESIZE": this.renderRunner.tryDrain() } }, this.handleData = e => { this.currentData = e, this.renderRunner.request(e.calendarOptions.rerenderDelay) }, this.handleRenderRequest = () => { if (this.isRendering) { this.isRendered = !0; let { currentData: e } = this; jr((() => { W(p(Qi, { options: e.calendarOptions, theme: e.theme, emitter: e.emitter }, ((t, n, r, i) => (this.setClassNames(t), this.setHeight(n), p(no.Provider, { value: this.customContentRenderId }, p(Ea, Object.assign({ isHeightAuto: r, forPrint: i }, e)))))), this.el) })) } else this.isRendered && (this.isRendered = !1, W(null, this.el), this.setClassNames([]), this.setHeight("")) }, function (e) { e.isConnected && xe(e.getRootNode()) }(e), this.el = e, this.renderRunner = new Mo(this.handleRenderRequest), new ia({ optionOverrides: t, calendarApi: this, onAction: this.handleAction, onData: this.handleData }) } render() { let e = this.isRendering; e ? this.customContentRenderId += 1 : this.isRendering = !0, this.renderRunner.request(), e && this.updateSize() } destroy() { this.isRendering && (this.isRendering = !1, this.renderRunner.request()) } updateSize() { jr((() => { super.updateSize() })) } batchRendering(e) { this.renderRunner.pause("batchRendering"), e(), this.renderRunner.resume("batchRendering") } pauseRendering() { this.renderRunner.pause("pauseRendering") } resumeRendering() { this.renderRunner.resume("pauseRendering", !0) } resetOptions(e, t) { this.currentDataManager.resetOptions(e, t) } setClassNames(e) { if (!Mt(e, this.currentClassNames)) { let { classList: t } = this.el; for (let e of this.currentClassNames) t.remove(e); for (let n of e) t.add(n); this.currentClassNames = e } } setHeight(e) { Pe(this.el, "height", e) } }, e.Draggable = class { constructor(e, t = {}) { this.handlePointerDown = e => { let { dragging: t } = this, { minDistance: n, longPressDelay: r } = this.settings; t.minDistance = null != n ? n : e.isTouch ? 0 : bn.eventDragMinDistance, t.delay = e.isTouch ? null != r ? r : bn.longPressDelay : 0 }, this.handleDragStart = e => { e.isTouch && this.dragging.delay && e.subjectEl.classList.contains("fc-event") && this.dragging.mirror.getMirrorEl().classList.add("fc-event-selected") }, this.settings = t; let n = this.dragging = new Ha(e); n.touchScrollAllowed = !1, null != t.itemSelector && (n.pointer.selector = t.itemSelector), null != t.appendTo && (n.mirror.parentNode = t.appendTo), n.emitter.on("pointerdown", this.handlePointerDown), n.emitter.on("dragstart", this.handleDragStart), new Va(n, t.eventData) } destroy() { this.dragging.destroy() } }, e.Internal = Cs, e.JsonRequestError = ko, e.Preact = ws, e.ThirdPartyDraggable = class { constructor(e, t) { let n = document; e === document || e instanceof Element ? (n = e, t = t || {}) : t = e || {}; let r = this.dragging = new Ga(n); "string" == typeof t.itemSelector ? r.pointer.selector = t.itemSelector : n === document && (r.pointer.selector = "[data-event]"), "string" == typeof t.mirrorSelector && (r.mirrorSelector = t.mirrorSelector), new Va(r, t.eventData) } destroy() { this.dragging.destroy() } }, e.createPlugin = _s, e.formatDate = function (e, t = {}) { let n = wa(t), r = vn(t), i = n.createMarkerMeta(e); return i ? n.format(i.marker, r, { forcedTzo: i.forcedTzo }) : "" }, e.formatRange = function (e, t, n) { let r = wa("object" == typeof n && n ? n : {}), i = vn(n), o = r.createMarkerMeta(e), s = r.createMarkerMeta(t); return o && s ? r.formatRange(o.marker, s.marker, i, { forcedStartTzo: o.forcedTzo, forcedEndTzo: s.forcedTzo, isEndExclusive: n.isEndExclusive, defaultSeparator: bn.defaultRangeSeparator }) : "" }, e.globalLocales = As, e.globalPlugins = ta, e.sliceEvents = function (e, t) { return di(e.eventStore, e.eventUiBases, e.dateProfile.activeRange, t ? e.nextDayThreshold : null).fg }, e.version = "6.1.8", Object.defineProperty(e, "__esModule", { value: !0 }), e }({}); const on = (e, t, n, r) => { const i = document.querySelectorAll(e); for (element of i) element.addEventListener(t, (e => { e.target.closest(n) && r(e) })) }, animateCSS = (e, t, n = "animate__") => new Promise(((r, i) => { const o = `${n}${t}`, s = e; s.classList.add(`${n}animated`, `${n}faster`, o); s.addEventListener("animationend", (e => { e.stopPropagation(), s.classList.remove(`${n}animated`, `${n}faster`, o), r("Animation Ended.") }), { once: !0 }) })), openCollapse = (e, t) => { setTimeout((() => { e.style.height = e.scrollHeight + "px", e.style.opacity = 1 }), 200), e.addEventListener("transitionend", (() => { e.classList.add("open"), e.style.removeProperty("height"), e.style.removeProperty("opacity"), "function" == typeof t && t() }), { once: !0 }) }, closeCollapse = (e, t) => { e.style.overflowY = "hidden", e.style.height = e.scrollHeight + "px", setTimeout((() => { e.style.height = 0, e.style.opacity = 0 }), 200), e.addEventListener("transitionend", (() => { e.classList.remove("open"), e.style.removeProperty("overflow-y"), e.style.removeProperty("height"), e.style.removeProperty("opacity"), "function" == typeof t && t() }), { once: !0 }) }, alerts = () => { on(".alert", "click", '[data-dismiss="alert"]', (e => { (e => { e.style.overflowY = "hidden", e.style.height = e.offsetHeight + "px", animateCSS(e, "fadeOut").then((() => { e.style.opacity = 0, e.style.height = 0, e.style.marginTop = 0, e.style.marginBottom = 0, e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.border = 0 })), e.addEventListener("transitionend", (() => { e.parentNode && e.parentNode.removeChild(e) }), { once: !0 }) })(e.target.closest(".alert")) })) }; alerts(); const showBackdrop = e => { if (document.querySelector(".backdrop")) return; document.body.classList.add("backdrop-show"); const t = document.createElement("div"); e ? t.setAttribute("class", "backdrop backdrop_workspace") : t.setAttribute("class", "backdrop"), document.body.appendChild(t), t.classList.add("active") }, hideBackdrop = () => { backdropToRemove = document.querySelector(".backdrop"), backdropToRemove && (document.body.classList.remove("backdrop-show"), backdropToRemove.classList.remove("active"), document.body.removeChild(backdropToRemove)) }, cards = () => { on("body", "click", '[data-toggle="cardSelection"]', (e => { (e => { e.target.closest(".card").classList.toggle("card_selected") })(e) })), on("body", "click", '[data-toggle="rowSelection"]', (e => { (e => { e.target.closest("tr").classList.toggle("row_selected") })(e) })) }; on("body", "click", '[data-toggle="cardSelection"]', (e => { (e => { e.target.closest(".card").classList.toggle("card_selected") })(e) })), on("body", "click", '[data-toggle="rowSelection"]', (e => { (e => { e.target.closest("tr").classList.toggle("row_selected") })(e) })); const collapse = () => { const e = '[data-toggle="collapse"]'; on("body", "click", e, (t => { (t => { t.classList.toggle("active"), document.querySelectorAll(t.dataset.target).forEach((e => { e.classList.contains("open") ? closeCollapse(e) : openCollapse(e) })); const n = t.closest(".accordion"); n && (n.querySelectorAll(e).forEach((e => { e !== t && e.classList.remove("active") })), n.querySelectorAll(".collapsible").forEach((e => { e.classList.contains("open") && closeCollapse(e) }))) })(t.target.closest(e)) })) }; collapse(); const customizer = () => { const e = document.documentElement, t = document.getElementById("customizer"), n = document.querySelector(".menu-bar"), r = document.querySelector(".menu-items"); if (!t) return; const i = [{ id: "default", label: "Default" }, { id: "hidden", label: "Hidden" }, { id: "icon-only", label: "Icon Only" }, { id: "wide", label: "Wide" }]; let o = ""; i.forEach((e => { o += `\n      <label class="custom-radio">\n        <input\n          type="radio"\n          name="menuType"\n          data-toggle="menu-type"\n          data-value=${e.id}\n        />\n        <span></span>\n        <span>${e.label}</span>\n      </label>` })); document.getElementById("customizerMenuTypes").innerHTML = o; const s = [{ id: "default", label: "Sky", color: "#0284C7" }, { id: "red", label: "Red", color: "#DC2626" }, { id: "orange", label: "Orange", color: "#EA580C" }, { id: "amber", label: "Amber", color: "#D97706" }, { id: "yellow", label: "Yellow", color: "#CA8A04" }, { id: "lime", label: "Lime", color: "#65A30D" }, { id: "green", label: "Green", color: "#65A30D" }, { id: "emerald", label: "Emerald", color: "#059669" }, { id: "teal", label: "Teal", color: "#0D9488" }, { id: "cyan", label: "Cyan", color: "#0891B2" }, { id: "blue", label: "Blue", color: "#2563EB" }, { id: "indigo", label: "Indigo", color: "#4F46E5" }, { id: "violet", label: "Violet", color: "#7C3AED" }, { id: "purple", label: "Purple", color: "#9333EA" }, { id: "fuchsia", label: "Fuchsia", color: "#C026D3" }, { id: "pink", label: "Pink", color: "#DB2777" }, { id: "rose", label: "Rose", color: "#E11D48" }]; let a = ""; s.forEach((e => { a += `\n      <button data-toggle="theme" data-value=${e.id}>\n        <span class="color bg-[${e.color}]"></span>\n        <span>${e.label}</span>\n      </button>` })); document.getElementById("customizerThemes").innerHTML = a; const l = [{ id: "default", label: "Pure", color: "#4B5563" }, { id: "slate", label: "Slate", color: "#475569" }, { id: "zinc", label: "Zinc", color: "#52525B" }, { id: "neutral", label: "Neutral", color: "#525252" }, { id: "stone", label: "Stone", color: "#57534E" }]; let d = ""; l.forEach((e => { d += `\n      <button data-toggle="gray" data-value=${e.id}>\n        <span class="color bg-[${e.color}]"></span>\n        <span>${e.label}</span>\n      </button>` })); document.getElementById("customizerGrays").innerHTML = d; const c = [{ id: "default", heading: "Nunito", headingLabel: "Nunito", body: "Nunito_Sans", bodyLabel: "Nunito Sans" }, { id: "montserrat", heading: "Montserrat", headingLabel: "Montserrat", body: "Montserrat", bodyLabel: "Montserrat" }, { id: "raleway", heading: "Raleway", headingLabel: "Raleway", body: "Raleway", bodyLabel: "Raleway" }, { id: "poppins", heading: "Poppins", headingLabel: "Poppins", body: "Poppins", bodyLabel: "Poppins" }, { id: "oswald", heading: "Oswald", headingLabel: "Oswald", body: "Oswald", bodyLabel: "Oswald" }, { id: "roboto-condensed-roboto", heading: "Roboto Condensed", headingLabel: "Roboto Condensed", body: "Roboto", bodyLabel: "Roboto" }, { id: "inter", heading: "Inter", headingLabel: "Inter", body: "Inter", bodyLabel: "Inter" }, { id: "yantramanav", heading: "Yantramanav", headingLabel: "Yantramanav", body: "Yantramanav", bodyLabel: "Yantramanav" }]; let u = ""; c.forEach((e => { u += `\n      <button data-toggle="font" data-value=${e.id}>\n        <h5 class="font-['${e.heading}']">${e.headingLabel}</h5>\n        <p class="font-['${e.body}']">${e.bodyLabel}</p>\n      </button>` })); document.getElementById("customizerFonts").innerHTML = u; const h = () => { const r = localStorage.getItem("scheme"), i = t.querySelector('[data-toggle="dark-mode"]'); i.checked = !!r; const o = localStorage.getItem("dir"); if (o) { document.dir = o; const e = t.querySelector('[data-toggle="rtl"]'); e.checked = "rtl" === o } let s = localStorage.getItem("brandedMenu"); const a = t.querySelector('[data-toggle="branded-menu"]'); s && n ? (e.classList.add("menu_branded"), n.classList.add("menu_branded"), a.checked = !0) : a.checked = !1; let l = localStorage.getItem("menuType"); l = l ? l.replace("menu-", "") : "default"; t.querySelector("[data-value='" + l + "']").checked = !0; let d, c = localStorage.getItem("theme"); c ? (e.classList.add("theme-" + c), d = t.querySelector("[data-toggle='theme'][data-value='" + c + "']")) : d = t.querySelector("[data-toggle='theme'][data-value='default']"), d && d.classList.add("active"); let u, h = localStorage.getItem("gray"); h ? (e.classList.add("gray-" + h), u = t.querySelector("[data-toggle='gray'][data-value='" + h + "']")) : u = t.querySelector("[data-toggle='gray'][data-value='default']"), u && u.classList.add("active"); let f, g = localStorage.getItem("font"); g ? (e.classList.add("font-" + g), f = t.querySelector("[data-toggle='font'][data-value='" + g + "']")) : f = t.querySelector("[data-toggle='font'][data-value='default']"), f && f.classList.add("active") }, f = e => e[Math.floor(Math.random() * e.length)], g = () => { document.getElementById("darkModeToggler").click() }, p = () => { e.classList.contains("menu_branded") ? (e.classList.remove("menu_branded"), n.classList.remove("menu_branded"), localStorage.removeItem("brandedMenu")) : (e.classList.add("menu_branded"), n.classList.add("menu_branded"), localStorage.setItem("brandedMenu", "menu_branded")) }, m = t => { const r = n.querySelector(".menu-detail.open"); switch (e.classList.remove("menu-icon-only"), n.classList.remove("menu-icon-only"), e.classList.remove("menu-wide"), n.classList.remove("menu-wide"), y(), e.classList.remove("menu-hidden"), n.classList.remove("menu-hidden"), t) { case "icon-only": e.classList.add("menu-icon-only"), n.classList.add("menu-icon-only"), localStorage.setItem("menuType", "menu-icon-only"), r && showBackdrop(!0); break; case "wide": e.classList.add("menu-wide"), n.classList.add("menu-wide"), localStorage.setItem("menuType", "menu-wide"), v(), r && hideBackdrop(); break; case "hidden": e.classList.add("menu-hidden"), n.classList.add("menu-hidden"), localStorage.setItem("menuType", "menu-hidden"), b(); break; default: localStorage.removeItem("menuType"), r && showBackdrop(!0) } }, v = () => { n.querySelector(".menu-header").classList.remove("hidden"), n.querySelectorAll(".menu-items .link").forEach((e => { const t = e.dataset.target, r = n.querySelector(".menu-detail" + t); r && (r.classList.add("collapse"), e.setAttribute("data-toggle", "collapse"), e.after(r)) })) }, y = () => { e.classList.remove("menu-wide"), n.classList.remove("menu-wide"), n.querySelector(".menu-header").classList.add("hidden"), n.querySelectorAll(".menu-items .link").forEach((e => { const t = e.dataset.target, i = n.querySelector(".menu-detail" + t); i && (i.classList.remove("collapse"), e.removeAttribute("data-toggle", "collapse"), r.after(i)) })) }, b = () => { n.querySelectorAll(".menu-detail.open").forEach((e => { hideBackdrop(), n.classList.contains("menu-wide") || e.classList.remove("open") })) }, E = n => { t.querySelectorAll("[data-toggle='theme']").forEach((e => { e.classList.remove("active") })); t.querySelector("[data-toggle='theme'][data-value='" + n + "']").classList.add("active"), e.classList.forEach((t => { t.startsWith("theme-") && e.classList.remove(t) })), "default" == n ? localStorage.removeItem("theme") : (e.classList.add("theme-" + n), localStorage.setItem("theme", n)); const r = new Event("ThemeChanged"); document.dispatchEvent(r) }, S = n => { t.querySelectorAll("[data-toggle='gray']").forEach((e => { e.classList.remove("active") })); t.querySelector("[data-toggle='gray'][data-value='" + n + "']").classList.add("active"), e.classList.forEach((t => { t.startsWith("gray-") && e.classList.remove(t) })), "default" == n ? localStorage.removeItem("gray") : (e.classList.add("gray-" + n), localStorage.setItem("gray", n)); const r = new Event("ThemeChanged"); document.dispatchEvent(r) }, C = n => { t.querySelectorAll("[data-toggle='font']").forEach((e => { e.classList.remove("active") })); t.querySelector("[data-toggle='font'][data-value='" + n + "']").classList.add("active"), e.classList.forEach((t => { t.startsWith("font-") && e.classList.remove(t) })), "default" == n ? localStorage.removeItem("font") : (e.classList.add("font-" + n), localStorage.setItem("font", n)); const r = new Event("ThemeChanged"); document.dispatchEvent(r), location.reload() }; on("#customizer", "click", '[data-toggle="customizer"]', (() => { t.classList.contains("open") ? t.classList.remove("open") : (h(), t.classList.add("open")) })), on("#customizer", "click", '[data-toggle="randomizer"]', (() => { (() => { const e = Math.random() < .25; e && g(), e && p(), e && m(f(i).id), E(f(s).id), S(f(l).id), C(f(c).id) })() })), on("#customizer", "click", '[data-toggle="dark-mode"]', (() => { g() })), on("#customizer", "click", '[data-toggle="rtl"]', (() => { "ltr" === document.dir ? (document.dir = "rtl", localStorage.setItem("dir", "rtl")) : (document.dir = "ltr", localStorage.setItem("dir", "ltr")) })), on("#customizer", "click", '[data-toggle="branded-menu"]', (() => { p() })), on("#customizer", "click", "[data-toggle='menu-type']", (e => { const t = e.target.closest("[data-toggle='menu-type']").dataset.value; m(t) })), on("#customizer", "click", '[data-toggle="theme"]', (e => { const t = e.target.closest("[data-toggle='theme']").dataset.value; E(t) })), on("#customizer", "click", '[data-toggle="gray"]', (e => { const t = e.target.closest("[data-toggle='gray']").dataset.value; S(t) })), on("#customizer", "click", '[data-toggle="font"]', (e => { const t = e.target.closest("[data-toggle='font']").dataset.value; C(t) })), h() }; customizer(); const darkMode = () => { const e = document.documentElement, t = document.getElementById("darkModeToggler"); if (!t) return; const n = localStorage.getItem("scheme"); n && e.classList.add(n), "dark" === n && t && (t.checked = "checked"); on("body", "change", "#darkModeToggler", (() => { e.classList.contains("dark") ? (e.classList.remove("dark"), e.classList.add("light"), localStorage.removeItem("scheme")) : (e.classList.remove("light"), e.classList.add("dark"), localStorage.setItem("scheme", "dark")) })) }; if (darkMode(), "undefined" != typeof Chart) { let e = {}, t = {}; const n = getComputedStyle(document.body); e.primary = n.getPropertyValue("--color-primary"), e.text = n.getPropertyValue("--color-text-normal"), t.body = n.getPropertyValue("--font-body"), document.addEventListener("ThemeChanged", (() => { e.primary = n.getPropertyValue("--color-primary"), e.text = n.getPropertyValue("--color-text-normal") })); const r = { backgroundColor: "white", borderColor: "rgb(" + e.primary + ")", borderWidth: .5, bodyColor: "rgb(" + e.text + ")", bodySpacing: 8, cornerRadius: 4, padding: 16, boxPadding: 2, titleColor: "rgb(" + e.primary + ")" }; Chart.defaults.color = "rgb(" + e.text + ")", Chart.defaults.font.family = t.body; class i extends Chart.elements.LineElement { draw(e) { const t = e.stroke; e.stroke = function () { e.save(), e.shadowColor = "rgba(0, 0, 0, 0.25)", e.shadowBlur = 8, e.shadowOffsetX = 0, e.shadowOffsetY = 4, t.apply(this, arguments), e.restore() }, Chart.elements.LineElement.prototype.draw.apply(this, arguments) } } i.id = "lineWithShadowElement", Chart.register(i); class o extends Chart.controllers.line { } o.id = "lineWithShadow", o.defaults = { datasetElementType: "lineWithShadowElement" }, Chart.register(o); class s extends Chart.controllers.bar { draw(e) { const t = this.chart.ctx, n = t.stroke; t.stroke = function () { t.save(), t.shadowColor = "rgba(0, 0, 0, 0.25)", t.shadowBlur = 8, t.shadowOffsetX = 0, t.shadowOffsetY = 4, n.apply(this, arguments), t.restore() }, Chart.controllers.bar.prototype.draw.call(this, e), t.save(), t.shadowColor = "rgba(0, 0, 0, 0.25)", t.shadowBlur = 8, t.shadowOffsetX = 0, t.shadowOffsetY = 4, Chart.controllers.bar.prototype.draw.apply(this, arguments), t.restore() } } s.id = "barWithShadow", Chart.register(s); class a extends Chart.controllers.pie { } a.id = "pieWithShadow", a.defaults = { datasetElementType: "lineWithShadowElement" }, Chart.register(a); class l extends Chart.controllers.doughnut { } l.id = "doughnutWithShadow", l.defaults = { datasetElementType: "lineWithShadowElement" }, Chart.register(l); class d extends Chart.controllers.radar { } d.id = "radarWithShadow", d.defaults = { datasetElementType: "lineWithShadowElement" }, Chart.register(d); class c extends Chart.controllers.polarArea { } c.id = "polarAreaWithShadow", c.defaults = { datasetElementType: "lineWithShadowElement" }, Chart.register(c); class u extends Chart.controllers.line { draw(e) { const t = this.chart.ctx; if (Chart.controllers.line.prototype.draw.call(this, e), this.chart.tooltip._active && this.chart.tooltip._active.length) { const e = this.chart.tooltip._active[0].element.x, n = this.chart.scales.y.top, r = this.chart.scales.y.bottom; t.save(), t.beginPath(), t.moveTo(e, n), t.lineTo(e, r), t.lineWidth = 1, t.stroke(), t.restore() } } } u.id = "lineWithAnnotation", Chart.register(u); class h extends Chart.controllers.line { draw(e) { const t = this.chart.ctx; if (Chart.controllers.line.prototype.draw.call(this, e), this.chart.tooltip._active && this.chart.tooltip._active.length) { const e = this.chart.tooltip._active[0].element.x, n = this.chart.scales.y.top, r = this.chart.scales.y.bottom; t.save(), t.beginPath(), t.moveTo(e, n), t.lineTo(e, r), t.lineWidth = 1, t.stroke(), t.restore() } } } h.id = "lineWithAnnotationAndShadow", h.defaults = { datasetElementType: "lineWithShadowElement" }, Chart.register(h); let f = ""; if (f = document.getElementById("visitorsChart"), f) { f = f.getContext("2d"); let t = f.createLinearGradient(0, 0, 0, 450); t.addColorStop(0, "rgb(" + e.primary + "/ .5)"), t.addColorStop(.75, "rgb(" + e.primary + "/ 0)"); var visitorsChart = new Chart(f, { type: "lineWithShadow", data: { labels: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], datasets: [{ data: [6.25, 7.5, 10, 7.5, 10, 12.5, 10, 12.5, 10, 12.5, 15, 16.25], backgroundColor: "rgb(" + e.primary + "/ .1)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2, fill: !0, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 4, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverBorderWidth: 2, pointHoverRadius: 6, tension: .5 }] }, options: { plugins: { legend: { display: !1 }, tooltip: r }, scales: { y: { border: { display: !1 }, grid: { display: !0 }, min: 0, max: 20, ticks: { stepSize: 5 } }, x: { grid: { display: !1 } } } } }) } if (document.addEventListener("ThemeChanged", (() => { if (visitorsChart) { const t = visitorsChart.data.datasets[0]; t.backgroundColor = "rgb(" + e.primary + "/ .1)", t.borderColor = "rgb(" + e.primary + ")", t.pointBorderColor = "rgb(" + e.primary + ")", t.pointHoverBackgroundColor = "rgb(" + e.primary + ")", visitorsChart.options.plugins.tooltip.borderColor = "rgb(" + e.primary + ")", visitorsChart.options.plugins.tooltip.titleColor = "rgb(" + e.primary + ")", visitorsChart.update() } })), f = document.getElementById("categoriesChart"), f) { f.getContext("2d"); var categoriesChart = new Chart(f, { type: "polarAreaWithShadow", data: { labels: ["Potatoes", "Tomatoes", "Onions"], datasets: [{ data: [25, 10, 15], backgroundColor: ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { maintainAspectRatio: !1, plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r }, scales: { r: { ticks: { display: !1 } } }, layout: { padding: 5 } } }) } document.addEventListener("ThemeChanged", (() => { if (categoriesChart) { const t = categoriesChart.data.datasets[0]; t.backgroundColor = ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], t.borderColor = "rgb(" + e.primary + ")", categoriesChart.options.plugins.tooltip.borderColor = "rgb(" + e.primary + ")", categoriesChart.options.plugins.tooltip.titleColor = "rgb(" + e.primary + ")", categoriesChart.update() } })), f = document.getElementById("areaChart"), f && (f.getContext("2d"), new Chart(f, { type: "line", data: { labels: ["January", "February", "March", "April", "May", "June"], datasets: [{ data: [5, 10, 15, 10, 15, 10], backgroundColor: "rgb(" + e.primary + "/ .1)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2, fill: !0, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 4, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverBorderWidth: 2, pointHoverRadius: 6, tension: .5 }] }, options: { plugins: { legend: { display: !1 }, tooltip: r }, scales: { y: { border: { display: !1 }, grid: { display: !0 }, min: 0, max: 20, ticks: { stepSize: 5 } }, x: { grid: { display: !1 } } } } })), f = document.getElementById("areaChartWithShadow"), f && (f.getContext("2d"), new Chart(f, { type: "lineWithShadow", data: { labels: ["January", "February", "March", "April", "May", "June"], datasets: [{ data: [5, 10, 15, 10, 15, 10], backgroundColor: "rgb(" + e.primary + "/ .1)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2, fill: !0, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 4, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverBorderWidth: 2, pointHoverRadius: 6, tension: .5 }] }, options: { plugins: { legend: { display: !1 }, tooltip: r }, scales: { y: { border: { display: !1 }, grid: { display: !0 }, min: 0, max: 20, ticks: { stepSize: 5 } }, x: { grid: { display: !1 } } } } })), f = document.getElementById("barChart"), f && (f.getContext("2d"), new Chart(f, { type: "bar", data: { labels: ["January", "February", "March", "April", "May", "June"], datasets: [{ label: "Potatoes", data: [5, 10, 15, 10, 15, 10], backgroundColor: "rgb(" + e.primary + "/ .1)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }, { label: "Tomatoes", data: [7.5, 10, 17.5, 15, 12.5, 5], backgroundColor: "rgb(" + e.primary + "/ .5)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r }, scales: { y: { border: { display: !1 }, grid: { display: !0 }, min: 0, max: 20, ticks: { stepSize: 5 } }, x: { grid: { display: !1 } } } } })), f = document.getElementById("barChartWithShadow"), f && (f.getContext("2d"), new Chart(f, { type: "barWithShadow", data: { labels: ["January", "February", "March", "April", "May", "June"], datasets: [{ label: "Potatoes", data: [5, 10, 15, 10, 15, 10], backgroundColor: "rgb(" + e.primary + "/ .1)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }, { label: "Tomatoes", data: [7.5, 10, 17.5, 15, 12.5, 5], backgroundColor: "rgb(" + e.primary + "/ .5)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r }, scales: { y: { border: { display: !1 }, grid: { display: !0 }, min: 0, max: 20, ticks: { stepSize: 5 } }, x: { grid: { display: !1 } } } } })), f = document.getElementById("lineChart"), f && (f.getContext("2d"), new Chart(f, { type: "line", data: { labels: ["January", "February", "March", "April", "May", "June"], datasets: [{ data: [5, 10, 15, 10, 15, 10], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 6, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 8, pointHoverBorderWidth: 2, tension: .5 }] }, options: { plugins: { legend: { display: !1 }, tooltip: r }, scales: { y: { border: { display: !1 }, grid: { display: !0 }, min: 0, max: 20, ticks: { stepSize: 5 } }, x: { grid: { display: !1 } } } } })), f = document.getElementById("lineChartWithShadow"), f && (f.getContext("2d"), new Chart(f, { type: "lineWithShadow", data: { labels: ["January", "February", "March", "April", "May", "June"], datasets: [{ data: [5, 10, 15, 10, 15, 10], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 6, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 8, pointHoverBorderWidth: 2, tension: .5 }] }, options: { plugins: { legend: { display: !1 }, tooltip: r }, scales: { y: { border: { display: !1 }, grid: { display: !0 }, min: 0, max: 20, ticks: { stepSize: 5 } }, x: { grid: { display: !1 } } } } })), f = document.getElementById("pieChart"), f && (f.getContext("2d"), new Chart(f, { type: "pie", data: { labels: ["Potatoes", "Tomatoes", "Onions"], datasets: [{ data: [25, 10, 15], backgroundColor: ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { maintainAspectRatio: !1, plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r } } })), f = document.getElementById("pieChartWithShadow"), f && (f.getContext("2d"), new Chart(f, { type: "pieWithShadow", data: { labels: ["Potatoes", "Tomatoes", "Onions"], datasets: [{ data: [25, 10, 15], backgroundColor: ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { maintainAspectRatio: !1, plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r } } })), f = document.getElementById("doughnutChart"), f && (f.getContext("2d"), new Chart(f, { type: "doughnut", data: { labels: ["Potatoes", "Tomatoes", "Onions"], datasets: [{ data: [25, 10, 15], backgroundColor: ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { maintainAspectRatio: !1, cutout: "75%", plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r } } })), f = document.getElementById("doughnutChartWithShadow"), f && (f.getContext("2d"), new Chart(f, { type: "doughnutWithShadow", data: { labels: ["Potatoes", "Tomatoes", "Onions"], datasets: [{ data: [25, 10, 15], backgroundColor: ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { maintainAspectRatio: !1, cutout: "75%", plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r } } })), f = document.getElementById("radarChart"), f && (f.getContext("2d"), new Chart(f, { type: "radar", data: { labels: ["Drinks", "Snacks", "Lunch", "Dinner"], datasets: [{ label: "Potatoes", data: [25, 25, 25, 25], backgroundColor: "rgb(" + e.primary + "/ .1)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2, fill: !0, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 4, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverBorderWidth: 2, pointHoverRadius: 6 }, { label: "Tomatoes", data: [15, 15, 0, 15], backgroundColor: "rgb(" + e.primary + "/ .25", borderColor: "rgb(" + e.primary + ")", borderWidth: 2, fill: !0, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 4, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverBorderWidth: 2, pointHoverRadius: 6 }] }, options: { maintainAspectRatio: !1, plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r }, scales: { r: { max: 30, ticks: { display: !1 } } } } })), f = document.getElementById("radarChartWithShadow"), f && (f.getContext("2d"), new Chart(f, { type: "radarWithShadow", data: { labels: ["Drinks", "Snacks", "Lunch", "Dinner"], datasets: [{ label: "Potatoes", data: [25, 25, 25, 25], backgroundColor: "rgb(" + e.primary + "/ .1)", borderColor: "rgb(" + e.primary + ")", borderWidth: 2, fill: !0, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 4, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverBorderWidth: 2, pointHoverRadius: 6 }, { label: "Tomatoes", data: [15, 15, 0, 15], backgroundColor: "rgb(" + e.primary + "/ .25", borderColor: "rgb(" + e.primary + ")", borderWidth: 2, fill: !0, pointBackgroundColor: "white", pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 2, pointRadius: 4, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverBorderWidth: 2, pointHoverRadius: 6 }] }, options: { maintainAspectRatio: !1, plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r }, scales: { r: { max: 30, ticks: { display: !1 } } } } })), f = document.getElementById("polarChart"), f && (f.getContext("2d"), new Chart(f, { type: "polarArea", data: { labels: ["Potatoes", "Tomatoes", "Onions"], datasets: [{ data: [25, 10, 15], backgroundColor: ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { maintainAspectRatio: !1, plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r }, scales: { r: { ticks: { display: !1 } } }, layout: { padding: 5 } } })), f = document.getElementById("polarChartWithShadow"), f && (f.getContext("2d"), new Chart(f, { type: "polarAreaWithShadow", data: { labels: ["Potatoes", "Tomatoes", "Onions"], datasets: [{ data: [25, 10, 15], backgroundColor: ["rgb(" + e.primary + "/ .1)", "rgb(" + e.primary + "/ .5)", "rgb(" + e.primary + "/ .25)"], borderColor: "rgb(" + e.primary + ")", borderWidth: 2 }] }, options: { maintainAspectRatio: !1, plugins: { legend: { position: "bottom", labels: { usePointStyle: !0, padding: 20 } }, tooltip: r }, scales: { r: { ticks: { display: !1 } } }, layout: { padding: 5 } } })); const g = { afterInit: e => { const t = e.canvas.parentNode, n = e.data.datasets[0].data[0].toLocaleString(), r = e.data.datasets[0].label, i = e.data.labels[0]; t.querySelector(".chart-heading").innerHTML = r, t.querySelector(".chart-value").innerHTML = "$" + n, t.querySelector(".chart-label").innerHTML = i } }, p = { plugins: { legend: { display: !1 }, tooltip: { enabled: !1, intersect: !1, external: e => { const t = e.chart.canvas.parentNode, n = e.tooltip.dataPoints[0].formattedValue, r = e.tooltip.dataPoints[0].dataset.label, i = e.tooltip.dataPoints[0].label; t.querySelector(".chart-heading").innerHTML = r, t.querySelector(".chart-value").innerHTML = "$" + n, t.querySelector(".chart-label").innerHTML = i } } }, scales: { y: { display: !1 }, x: { display: !1 } }, layout: { padding: { left: 5, right: 5, top: 10, bottom: 10 } } }; if (f = document.getElementById("lineWithAnnotationChart1"), f) { f.getContext("2d"); var lineWithAnnotationChart1 = new Chart(f, { type: "lineWithAnnotation", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Total Orders", data: [1250, 1300, 1550, 900, 1800, 1100, 1600], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p }) } if (document.addEventListener("ThemeChanged", (() => { if (lineWithAnnotationChart1) { const t = lineWithAnnotationChart1.data.datasets[0]; t.borderColor = "rgb(" + e.primary + ")", t.pointBorderColor = "rgb(" + e.primary + ")", t.pointHoverBackgroundColor = "rgb(" + e.primary + ")", lineWithAnnotationChart1.update() } })), f = document.getElementById("lineWithAnnotationChart2"), f) { f.getContext("2d"); var lineWithAnnotationChart2 = new Chart(f, { type: "lineWithAnnotation", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Active Orders", data: [100, 125, 75, 125, 100, 75, 75], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p }) } if (document.addEventListener("ThemeChanged", (() => { if (lineWithAnnotationChart2) { const t = lineWithAnnotationChart2.data.datasets[0]; t.borderColor = "rgb(" + e.primary + ")", t.pointBorderColor = "rgb(" + e.primary + ")", t.pointHoverBackgroundColor = "rgb(" + e.primary + ")", lineWithAnnotationChart2.update() } })), f = document.getElementById("lineWithAnnotationChart3"), f) { f.getContext("2d"); var lineWithAnnotationChart3 = new Chart(f, { type: "lineWithAnnotation", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Pending Orders", data: [300, 300, 600, 700, 600, 300, 300], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p }) } if (document.addEventListener("ThemeChanged", (() => { if (lineWithAnnotationChart3) { const t = lineWithAnnotationChart3.data.datasets[0]; t.borderColor = "rgb(" + e.primary + ")", t.pointBorderColor = "rgb(" + e.primary + ")", t.pointHoverBackgroundColor = "rgb(" + e.primary + ")", lineWithAnnotationChart3.update() } })), f = document.getElementById("lineWithAnnotationChart4"), f) { f.getContext("2d"); var lineWithAnnotationChart4 = new Chart(f, { type: "lineWithAnnotation", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Shipped Orders", data: [200, 400, 200, 500, 100, 100, 400], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p }) } document.addEventListener("ThemeChanged", (() => { if (lineWithAnnotationChart4) { const t = lineWithAnnotationChart4.data.datasets[0]; t.borderColor = "rgb(" + e.primary + ")", t.pointBorderColor = "rgb(" + e.primary + ")", t.pointHoverBackgroundColor = "rgb(" + e.primary + ")", lineWithAnnotationChart4.update() } })), f = document.getElementById("lineWithAnnotationAndShadowChart1"), f && (f.getContext("2d"), new Chart(f, { type: "lineWithAnnotationAndShadow", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Total Orders", data: [1250, 1300, 1550, 900, 1800, 1100, 1600], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p })), f = document.getElementById("lineWithAnnotationAndShadowChart2"), f && (f.getContext("2d"), new Chart(f, { type: "lineWithAnnotationAndShadow", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Active Orders", data: [100, 125, 75, 125, 100, 75, 75], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p })), f = document.getElementById("lineWithAnnotationAndShadowChart3"), f && (f.getContext("2d"), new Chart(f, { type: "lineWithAnnotationAndShadow", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Pending Orders", data: [300, 300, 600, 700, 600, 300, 300], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p })), f = document.getElementById("lineWithAnnotationAndShadowChart4"), f && (f.getContext("2d"), new Chart(f, { type: "lineWithAnnotationAndShadow", plugins: [g], data: { labels: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], datasets: [{ label: "Shipped Orders", data: [200, 400, 200, 500, 100, 100, 400], borderColor: "rgb(" + e.primary + ")", borderWidth: 2, pointBorderColor: "rgb(" + e.primary + ")", pointBorderWidth: 4, pointRadius: 2, pointHoverBackgroundColor: "rgb(" + e.primary + ")", pointHoverBorderColor: "white", pointHoverRadius: 2, tension: .5 }] }, options: p })) } const customFileInput = () => { on("body", "change", 'input[type="file"]', (e => { const t = e.target.value.split("\\").pop(); e.target.parentNode.querySelector(".file-name").innerHTML = t })) }; on("body", "change", 'input[type="file"]', (e => { const t = e.target.value.split("\\").pop(); e.target.parentNode.querySelector(".file-name").innerHTML = t })); const fullscreen = () => { const e = document.getElementById("fullScreenToggler"); if (!e) return; const t = document.documentElement; on("body", "click", "#fullScreenToggler", (() => { document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement ? document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen() : t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.msRequestFullscreen && t.msRequestFullscreen(), e.classList.contains("la-expand-arrows-alt") ? (e.classList.remove("la-expand-arrows-alt"), e.classList.add("la-compress-arrows-alt")) : (e.classList.remove("la-compress-arrows-alt"), e.classList.add("la-expand-arrows-alt")) })) }; fullscreen(); const menu = () => { const e = document.documentElement, t = document.querySelector(".menu-bar"), n = document.querySelector(".menu-items"); if (!t && !n) return; const r = localStorage.getItem("menuType"); r && (e.classList.add(r), t.classList.add(r)); const i = () => { t.querySelectorAll(".menu-detail.open").forEach((e => { hideBackdrop(), t.classList.contains("menu-wide") || e.classList.remove("open") })) }, o = () => { e.classList.remove("menu-hidden"), t.classList.remove("menu-hidden") }, s = () => { e.classList.add("menu-hidden"), t.classList.add("menu-hidden") }, a = () => { t.querySelector(".menu-header").classList.remove("hidden"), t.querySelectorAll(".menu-items .link").forEach((e => { const n = e.dataset.target, r = t.querySelector(".menu-detail" + n); r && (r.classList.add("collapse"), e.setAttribute("data-toggle", "collapse"), e.after(r)) })) }, l = () => { e.classList.remove("menu-wide"), t.classList.remove("menu-wide"), t.querySelector(".menu-header").classList.add("hidden"), t.querySelectorAll(".menu-items .link").forEach((e => { const r = e.dataset.target, i = t.querySelector(".menu-detail" + r); i && (i.classList.remove("collapse"), e.removeAttribute("data-toggle", "collapse"), n.after(i)) })) }; window.addEventListener("resize", (() => { (() => { const e = window.innerWidth || document.documentElement.clientWidth; e < 640 && (t.querySelector(".menu-detail.open") || s()); e > 640 && o() })() }), !1), t.classList.contains("menu-wide") && a(), document.addEventListener("click", (e => { e.target.closest(".menu-bar") || t.classList.contains("menu-wide") || i() })), on(".top-bar", "click", "[data-toggle='menu']", (e => { t.classList.contains("menu-hidden") ? o() : s() })), on(".menu-items", "click", ".link", (e => { (e => { const n = e.target.closest(".link").dataset.target, r = t.querySelector(n); if (r && !t.classList.contains("menu-wide")) { const e = r.classList.contains("open"); i(), r && !e ? (showBackdrop(!0), r.classList.add("open")) : hideBackdrop() } })(e) })), on(".menu-bar", "click", "[data-toggle='menu-type']", (n => { (n => { const r = t.querySelector(".menu-detail.open"); switch (e.classList.remove("menu-icon-only"), t.classList.remove("menu-icon-only"), e.classList.remove("menu-wide"), t.classList.remove("menu-wide"), l(), e.classList.remove("menu-hidden"), t.classList.remove("menu-hidden"), n) { case "icon-only": e.classList.add("menu-icon-only"), t.classList.add("menu-icon-only"), localStorage.setItem("menuType", "menu-icon-only"), r && showBackdrop(!0); break; case "wide": e.classList.add("menu-wide"), t.classList.add("menu-wide"), localStorage.setItem("menuType", "menu-wide"), a(), r && hideBackdrop(); break; case "hidden": e.classList.add("menu-hidden"), t.classList.add("menu-hidden"), localStorage.setItem("menuType", "menu-hidden"), i(); break; default: localStorage.removeItem("menuType"), r && showBackdrop(!0) } })(n.target.closest("[data-toggle='menu-type']").dataset.value) })) }; menu(); const showActivePage = () => { const e = window.location.href.split(/[?#]/)[0], t = document.querySelectorAll(".menu-bar a"); t && t.forEach((t => { if (t.href === e) { t.classList.add("active"); const e = t.closest(".menu-detail"); if (!e) return; document.querySelector('.menu-items .link[data-target="[data-menu=' + e.dataset.menu + ']"]').classList.add("active") } })) }; showActivePage(); const modal = () => { const e = '[data-toggle="modal"]', t = e => { hideBackdrop(); const t = e.dataset.animations.split(", ")[1], n = e.querySelector(".modal-content"); animateCSS(n, t).then((() => { e.classList.remove("active") })) }; on("body", "click", e, (n => { const r = n.target.closest(e); (e => { showBackdrop(), e.classList.add("active"); const n = e.dataset.animations.split(", ")[0], r = e.querySelector(".modal-content"); animateCSS(r, n), e.addEventListener("click", (n => { void 0 === e.dataset.staticBackdrop && e === n.target && t(e) })) })(document.querySelector(r.dataset.target)) })), on(".modal", "click", '[data-dismiss="modal"]', (e => { const n = e.target.closest(".modal"); t(n) })) }; modal(); const ratingStars = () => { rateStars = e => { const t = e.target.closest(".rating-stars"), n = Array.from(t.children); let r = 0; r = n.length - n.indexOf(e.target), n.forEach((e => e.classList.remove("active"))), e.target.classList.add("active"), console.log("You have rated " + r + " stars.") }, on("body", "click", ".rating-stars", (e => { rateStars(e) })) }; rateStars = e => { const t = e.target.closest(".rating-stars"), n = Array.from(t.children); let r = 0; r = n.length - n.indexOf(e.target), n.forEach((e => e.classList.remove("active"))), e.target.classList.add("active"), console.log("You have rated " + r + " stars.") }, on("body", "click", ".rating-stars", (e => { rateStars(e) })); const showPassword = () => { on("body", "click", '[data-toggle="password-visibility"]', (e => { (e => { const t = e.closest(".form-control-addon-within").querySelector("input"); "password" === t.type ? (t.type = "text", e.classList.remove("text-gray-600", "dark:text-gray-600"), e.classList.add("text-primary", "dark:text-primary")) : (t.type = "password", e.classList.remove("text-primary", "dark:text-primary"), e.classList.add("text-gray-600", "dark:text-gray-600")) })(e.target.closest('[data-toggle="password-visibility"]')) })) }; on("body", "click", '[data-toggle="password-visibility"]', (e => { (e => { const t = e.closest(".form-control-addon-within").querySelector("input"); "password" === t.type ? (t.type = "text", e.classList.remove("text-gray-600", "dark:text-gray-600"), e.classList.add("text-primary", "dark:text-primary")) : (t.type = "password", e.classList.remove("text-primary", "dark:text-primary"), e.classList.add("text-gray-600", "dark:text-gray-600")) })(e.target.closest('[data-toggle="password-visibility"]')) })); const sidebar = () => { const e = document.querySelector(".sidebar:not(.sidebar_customizer)"); if (!e) return; const t = () => { hideBackdrop(), e.classList.remove("open") }, n = () => { e.classList.contains("open") ? t() : (showBackdrop(!0), e.classList.add("open")) }; window.addEventListener("resize", (() => { (window.innerWidth || document.documentElement.clientWidth) > 1024 && t() }), !1), on("body", "click", '[data-toggle="sidebar"]', (() => { n() })) }; sidebar(); const tabs = () => { let e = !1; on("body", "click", '[data-toggle="tab"]', (t => { const n = t.target.closest('[data-toggle="tab"]'), r = n.closest(".tabs"), i = r.querySelector(".tab-nav .active"), o = r.querySelector(".collapsible.open"), s = r.querySelector(n.dataset.target); e || i !== n && (i.classList.remove("active"), n.classList.add("active"), e = !0, closeCollapse(o, (() => { openCollapse(s, (() => { e = !1 })) }))) })), on("body", "click", '[data-toggle="wizard"]', (e => { const t = e.target.closest(".wizard"), n = e.target.dataset.direction, r = t.querySelectorAll(".nav-link"), i = t.querySelector(".nav-link.active"); let o = 0; switch (r.forEach(((e, t) => { e === i && (o = t) })), n) { case "next": r[o + 1] && r[o + 1].click(); break; case "previous": r[o - 1] && r[o - 1].click() } })) }; tabs(); const customTippy = () => { tippy.delegate("body", { target: '.menu-icon-only [data-toggle="tooltip-menu"]', touch: ["hold", 500], theme: "light-border tooltip", offset: [0, 12], interactive: !0, animation: "scale", placement: "right", appendTo: () => document.body }), tippy('[data-toggle="tooltip"]', { theme: "light-border tooltip", touch: ["hold", 500], offset: [0, 12], interactive: !0, animation: "scale", appendTo: () => document.body }), tippy('[data-toggle="popover"]', { theme: "light-border popover", offset: [0, 12], interactive: !0, allowHTML: !0, trigger: "click", animation: "shift-toward-extreme", content: e => "<h5>" + e.dataset.popoverTitle + '</h5><div class="mt-5">' + e.dataset.popoverContent + "</div>", appendTo: () => document.body }), tippy('[data-toggle="dropdown-menu"]', { theme: "light-border", offset: [0, 8], arrow: !1, placement: "bottom-start", interactive: !0, allowHTML: !0, animation: "shift-toward-extreme", content: e => { let t = e.closest(".dropdown").querySelector(".dropdown-menu"); return t = t.outerHTML, t }, appendTo: () => document.body }), tippy('[data-toggle="custom-dropdown-menu"]', { theme: "light-border", offset: [0, 8], arrow: !1, placement: "bottom-start", interactive: !0, allowHTML: !0, animation: "shift-toward-extreme", content: e => { let t = e.closest(".dropdown").querySelector(".custom-dropdown-menu"); return t = t.outerHTML, t }, appendTo: () => document.body }), tippy('[data-toggle="search-select"]', { theme: "light-border", offset: [0, 8], maxWidth: "none", arrow: !1, placement: "bottom-start", trigger: "click", interactive: !0, allowHTML: !0, animation: "shift-toward-extreme", content: e => { let t = e.closest(".search-select").querySelector(".search-select-menu"); return t = t.outerHTML, t }, appendTo: e => e.closest(".search-select") }) }; tippy.delegate("body", { target: '.menu-icon-only [data-toggle="tooltip-menu"]', touch: ["hold", 500], theme: "light-border tooltip", offset: [0, 12], interactive: !0, animation: "scale", placement: "right", appendTo: () => document.body }), tippy('[data-toggle="tooltip"]', { theme: "light-border tooltip", touch: ["hold", 500], offset: [0, 12], interactive: !0, animation: "scale", appendTo: () => document.body }), tippy('[data-toggle="popover"]', { theme: "light-border popover", offset: [0, 12], interactive: !0, allowHTML: !0, trigger: "click", animation: "shift-toward-extreme", content: e => "<h5>" + e.dataset.popoverTitle + '</h5><div class="mt-5">' + e.dataset.popoverContent + "</div>", appendTo: () => document.body }), tippy('[data-toggle="dropdown-menu"]', { theme: "light-border", offset: [0, 8], arrow: !1, placement: "bottom-start", interactive: !0, allowHTML: !0, animation: "shift-toward-extreme", content: e => { let t = e.closest(".dropdown").querySelector(".dropdown-menu"); return t = t.outerHTML, t }, appendTo: () => document.body }), tippy('[data-toggle="custom-dropdown-menu"]', { theme: "light-border", offset: [0, 8], arrow: !1, placement: "bottom-start", interactive: !0, allowHTML: !0, animation: "shift-toward-extreme", content: e => { let t = e.closest(".dropdown").querySelector(".custom-dropdown-menu"); return t = t.outerHTML, t }, appendTo: () => document.body }), tippy('[data-toggle="search-select"]', { theme: "light-border", offset: [0, 8], maxWidth: "none", arrow: !1, placement: "bottom-start", trigger: "click", interactive: !0, allowHTML: !0, animation: "shift-toward-extreme", content: e => { let t = e.closest(".search-select").querySelector(".search-select-menu"); return t = t.outerHTML, t }, appendTo: e => e.closest(".search-select") }); const toasts = () => { const e = document.getElementById("toasts-container"); if (!e) return; const t = e => { e.style.overflowY = "hidden", e.style.height = e.offsetHeight + "px", animateCSS(e, "fadeOutUp").then((() => { e.style.opacity = 0, e.style.height = 0, e.style.marginTop = 0, e.style.marginBottom = 0, e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.border = 0 })), e.addEventListener("transitionend", (() => { e.parentNode && e.parentNode.removeChild(e) }), { once: !0 }) }; on("body", "click", '[data-toggle="toast"]', (n => { (n => { const r = n.dataset.title, i = n.dataset.content; let o = `\n    <div class="toast mb-5">\n      <div class="toast-header">\n        <h5>${r}</h5><small>${n.dataset.time}</small>\n        <button class="close" data-dismiss="toast">&times</button>\n      </div>\n      <div class="toast-body">${i}</div>\n    </div>`; o = (new DOMParser).parseFromString(o, "text/html").body.firstChild, e.appendChild(o), animateCSS(o, "fadeInUp"), n.dataset.dismiss && setTimeout((() => t(o)), n.dataset.dismiss) })(n.target) })), on("body", "click", '[data-dismiss="toast"]', (e => { const n = e.target.closest(".toast"); t(n) })) }; toasts();